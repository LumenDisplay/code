#define LV_CONF_INCLUDE_SIMPLE
#include <LilyGo_AMOLED.h>
#include <LV_Helper.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <WebSocketsClient.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include "LumenLogo.h"
#include "Wifi1bar.h"
#include "Wifi2bar.h"
#include "Wifi3bar.h"
#include "Lock.h"
#include "Alert.h"
#include <time.h>
#include <cstdlib>
#include <cmath>
#include <limits.h>
#include <esp_heap_caps.h>
#include "esp_sleep.h"

// ===== OTA UPDATE INCLUDES =====
#include <Update.h>
#include <ArduinoOTA.h>
#include <esp_ota_ops.h>
#include <esp_https_ota.h>
#include <esp_http_client.h>
#include <esp_tls.h>

/* ===== Fonts ===== */
#include "Poppins-SemiBold-64.c"
LV_FONT_DECLARE(poppins_extralight_14);
LV_FONT_DECLARE(poppins_light_20);
LV_FONT_DECLARE(poppins_medium_20);
LV_FONT_DECLARE(poppins_regular_32);
LV_FONT_DECLARE(poppins_semibold_32);
LV_FONT_DECLARE(poppins_semibold_64);

/* ===== Display ===== */
LilyGo_Class amoled;

/* ===== Colors ===== */
static const lv_color_t COLOR_GREEN     = LV_COLOR_MAKE(0x0E, 0xCB, 0x81);
static const lv_color_t COLOR_RED       = LV_COLOR_MAKE(0xF6, 0x46, 0x5D);
static const lv_color_t COLOR_WHITE     = LV_COLOR_MAKE(0xFF, 0xFF, 0xFF);
static const lv_color_t COLOR_BLACK     = LV_COLOR_MAKE(0x00, 0x00, 0x00);
static const lv_color_t COLOR_GRAY      = LV_COLOR_MAKE(0x80, 0x80, 0x80);
static const lv_color_t COLOR_POPUP_BG  = LV_COLOR_MAKE(0x20, 0x20, 0x20);
static const lv_color_t COLOR_DARK_GRAY = LV_COLOR_MAKE(0x0A, 0x0A, 0x0A);  // RGB(10, 10, 10) - Main UI background
static const lv_coord_t BUTTON_RADIUS   = 25;

/* ===== UI Layout Constants ===== */
// Popup dimensions
#define POPUP_WIDTH_STANDARD        450
#define POPUP_HEIGHT_STANDARD       480
#define POPUP_HEIGHT_TALL           500
#define POPUP_RADIUS                20
#define POPUP_PADDING               20
#define POPUP_TITLE_Y_OFFSET        20
#define POPUP_TITLE_Y_OFFSET_ALT    25  // Alternative offset for some popups

// Button dimensions
#define BUTTON_HEIGHT_STANDARD      50
#define BUTTON_HEIGHT_LARGE         70
#define BUTTON_WIDTH_BACK           120
#define BUTTON_WIDTH_STANDARD       200

// Coin list layout
#define COIN_BUTTON_HEIGHT          70
#define COIN_BUTTON_SPACING         12
#define COIN_BUTTON_WIDTH           390
#define COIN_LIST_START_X           10
#define COIN_LIST_START_Y           10
#define COIN_NAME_PADDING_LEFT      25
#define COIN_PRICE_PADDING_RIGHT    25

// List dimensions
#define COINS_POPUP_LIST_WIDTH      410
#define COINS_POPUP_LIST_HEIGHT     320
#define COINS_POPUP_LIST_Y_OFFSET   60

// Spacing and alignment
#define SPACING_SMALL               10
#define SPACING_MEDIUM              15
#define SPACING_LARGE               20
#define SPACING_EXTRA_LARGE         30

/* ===== Candles ===== */
#define CANDLE_AREA_WIDTH   600
#define CANDLE_AREA_HEIGHT  150
#define MAX_CANDLES         40

/* ===== Pairs ===== */
#define PAIR_COUNT 10  // Maximum number of favorite coins for live price display

// ===== OTA CONFIGURATION =====
#define FIRMWARE_VERSION "1.0.0"  // Update this for each release
#define UPDATE_SERVER_URL "https://github.com/JGarp/lumen-updates/releases/download/v1.0.1/firmware.bin"
#define VERSION_CHECK_URL "https://raw.githubusercontent.com/JGarp/lumen-updates/main/version.json"
#define OTA_UPDATE_INTERVAL 86400000  // Check for updates every 24 hours (in milliseconds)

// ===== Battery Sensing Defaults (override via build flags or headers) =====
#ifndef LUMEN_VBAT_PIN
#define LUMEN_VBAT_PIN 1   // T4-S3 uses GPIO1 for battery sense (changed from GPIO4)
#endif
#ifndef LUMEN_VBAT_DIV
#define LUMEN_VBAT_DIV 2.0f  // Typical 2:1 resistor divider
#endif

// USB presence/charge detection (from T4-S3 schematic)
#ifndef LUMEN_VBUS_PIN
#define LUMEN_VBUS_PIN 45     // VBUS sense (HIGH when USB 5V present)
#endif
#ifndef LUMEN_CHG_INT_PIN
#define LUMEN_CHG_INT_PIN 39  // SY6970 INT/STAT routed to ESP32-S3 (logic-level)
#endif

// Battery image positioning
#define BATTERY_GAP_X 6  // gap between battery icon and WiFi icon

// ===== Optional Battery Image Includes (use step images if available) =====
#if defined(__has_include)
  // Force-include Battery100 first to ensure image path is enabled
#  if __has_include("Battery100.h")
#    include "Battery100.h"
#    if !defined(HAVE_BATTERY_IMAGES)
#      define HAVE_BATTERY_IMAGES 1
#    endif
#  elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery100.h")
#    include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery100.h"
#    if !defined(HAVE_BATTERY_IMAGES)
#      define HAVE_BATTERY_IMAGES 1
#    endif
#  endif
  // 10
#  if __has_include("Battery10.h")
#    include "Battery10.h"
#    if !defined(HAVE_BATTERY_IMAGES)
#      define HAVE_BATTERY_IMAGES 1
#    endif
#  elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery10.h")
#    include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery10.h"
#    if !defined(HAVE_BATTERY_IMAGES)
#      define HAVE_BATTERY_IMAGES 1
#    endif
#  endif


  // 25
#  if __has_include("Battery25.h")
#    include "Battery25.h"
#  elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery25.h")
#    include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery25.h"
#  endif

  // 50
#  if __has_include("Battery50.h")
#    include "Battery50.h"
#  elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery50.h")
#    include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery50.h"
#  endif

  // 75
#  if __has_include("Battery75.h")
#    include "Battery75.h"
#  elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery75.h")
#    include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery75.h"
#  endif

  // 100
#  if !defined(HAVE_BATTERY_IMAGES)
#    if __has_include("Battery100.h")
#      include "Battery100.h"
#      define HAVE_BATTERY_IMAGES 1
#    elif __has_include("C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery100.h")
#      include "C:\\Users\\garpj\\Documents\\Arduino\\Lumen\\Battery100.h"
#      define HAVE_BATTERY_IMAGES 1
#    endif
#  endif
#endif

#ifdef HAVE_BATTERY_IMAGES
LV_IMG_DECLARE(Battery10);
LV_IMG_DECLARE(Battery25);
LV_IMG_DECLARE(Battery50);
LV_IMG_DECLARE(Battery75);
LV_IMG_DECLARE(Battery100);
// Charge variants removed - no longer showing charging state
#endif

// ===== ROTARY ENCODER =====
// PIN MAPPING (consistent across all features):
// ENCODER_PIN_A (IO47) = Counterclockwise rotation
// ENCODER_PIN_B (IO40) = Clockwise rotation  
// ENCODER_PIN_SW (IO38) = Click/Button press
#define ENCODER_PIN_A    47  // IO47 - Counterclockwise
#define ENCODER_PIN_B    40  // IO40 - Clockwise
#define ENCODER_PIN_SW   38  // IO38 - Click/Button
static int encoder_last_A = HIGH;
static int encoder_last_B = HIGH;
static int encoder_state = 0;  // Combined state: (A << 1) | B
static int encoder_last_sw = HIGH;
static int encoder_pulse_count = 0;  // Accumulate pulses for detent detection
static int encoder_last_direction = 0;  // Track direction consistency
static unsigned long last_encoder_check = 0;
static unsigned long last_sw_press = 0;
#define ENCODER_DEBOUNCE_MS 2
#define ENCODER_SW_DEBOUNCE_MS 50
#define ENCODER_PULSES_PER_DETENT 4  // Most encoders have 4 pulses per detent
#define ALERT_ENCODER_SPEED_WINDOW_MS 200  // Window to detect encoder speed

struct Candle { float open, high, low, close, volume; unsigned long long open_time; };

/* ===== UI Globals ===== */
static lv_obj_t *wifi_label      = nullptr;
static lv_obj_t *wifi_list       = nullptr;
static lv_obj_t *refresh_btn     = nullptr;
static lv_obj_t *popup           = nullptr;
static lv_obj_t *popup_label     = nullptr;
static lv_obj_t *password_ta     = nullptr;
static lv_obj_t *kb              = nullptr;
static lv_obj_t *cancel_btn      = nullptr;
static lv_obj_t *connect_btn     = nullptr;
static lv_obj_t *connecting_label= nullptr;

// Homepage UI
static lv_obj_t *homepage_screen = nullptr;
static lv_obj_t *favorites_btn   = nullptr;
static lv_obj_t *utilities_btn   = nullptr;
static lv_obj_t *settings_btn    = nullptr;

// Utilities page UI
static lv_obj_t *utilities_screen = nullptr;
static lv_obj_t *portfolio_btn   = nullptr;
static lv_obj_t *fear_greed_btn  = nullptr;
static lv_obj_t *utilities_back_btn = nullptr;

// Fear & Greed Index page UI
static lv_obj_t *fear_greed_screen = nullptr;
static lv_obj_t *fear_greed_arcs[7] = {nullptr};  // 7 arc segments
static lv_obj_t *fear_greed_triangle = nullptr;  // Triangle indicator
static lv_color_t fear_greed_triangle_buf[24 * 24];  // Canvas buffer for triangle
static lv_obj_t *fear_greed_value_label = nullptr;
static lv_obj_t *fear_greed_text_label = nullptr;
static lv_obj_t *fear_greed_yesterday_label = nullptr;
static lv_obj_t *fear_greed_week_label = nullptr;
static lv_obj_t *fear_greed_back_btn = nullptr;

// Fear & Greed Index data
static int fg_current_value = 0;
static String fg_current_classification = "";
static int fg_yesterday_value = 0;
static String fg_yesterday_classification = "";
static int fg_last_week_value = 0;
static String fg_last_week_classification = "";

// Settings page UI
static lv_obj_t *settings_wifi_btn = nullptr;
static lv_obj_t *settings_brightness_btn = nullptr;
static lv_obj_t *settings_about_btn = nullptr;

// Favorites page UI
static lv_obj_t *favorites_screen = nullptr;
static lv_obj_t *favorites_list   = nullptr;
static lv_obj_t *back_btn         = nullptr;
static lv_obj_t *continue_btn     = nullptr;
static bool favorites_list_scrolling = false;

// Search/Favorites selection page UI
static lv_obj_t *search_favorites_screen = nullptr;
static lv_obj_t *search_btn_screen = nullptr;
static lv_obj_t *favorites_btn_screen = nullptr;
static lv_obj_t *search_favorites_back_btn = nullptr;

// Coin search page UI
static lv_obj_t *coin_search_screen = nullptr;
static lv_obj_t *coin_search_bar = nullptr;
static lv_obj_t *coin_search_kb = nullptr;
static lv_obj_t *coin_search_list = nullptr;
static lv_obj_t *coin_search_back_btn = nullptr;
static lv_obj_t *coin_search_favorites_btn = nullptr;
static lv_obj_t *coin_search_counter_label = nullptr;
static String coin_search_query = "";
static bool coin_search_list_scrolling = false;

// New favorites page (from search) UI
static lv_obj_t *new_favorites_screen = nullptr;
static lv_obj_t *new_favorites_list = nullptr;
static lv_obj_t *new_favorites_back_btn = nullptr;
static lv_obj_t *new_favorites_continue_btn = nullptr;
static lv_obj_t *new_favorites_manage_btn = nullptr;
static lv_obj_t *unfavorite_popup = nullptr;
static lv_obj_t *unfavorite_popup_label = nullptr;
static lv_obj_t *unfavorite_no_btn = nullptr;
static lv_obj_t *unfavorite_yes_btn = nullptr;
static String coin_to_unfavorite = "";
static lv_coord_t saved_favorites_scroll_y = 0;  // Save scroll position when showing popup

// Coin data storage
#define MAX_SEARCH_RESULTS 20  // Show 20 results at a time from API
#define MAX_FAVORITE_COINS 10  // Limit to 10 favorites for live price display
struct CoinSearchInfo {
  String symbol;      // e.g., "BTCUSDT"
  String baseCoin;    // e.g., "BTC"
  bool isFavorite;
};
static CoinSearchInfo searchResults[MAX_SEARCH_RESULTS];
static int searchResultCount = 0;

/**
 * @brief Enhanced favorite coin structure with direct pair reference
 * @details Improves performance by eliminating the need to search for matching pairs.
 *          Maintains backward compatibility with favoriteCoinSymbols array.
 */
struct FavoriteCoin {
  String symbol;         // e.g., "BTCUSDT"
  String display_name;   // e.g., "BTC"
  int pair_index;        // Direct index into pairs[] array (-1 if not loaded)
  bool has_active_alerts;// Quick check if this coin has alerts
  unsigned long last_price_update;  // Timestamp of last price update
  
  FavoriteCoin() : symbol(""), display_name(""), pair_index(-1), has_active_alerts(false), last_price_update(0) {}
};

// New enhanced favorite coins array (with direct pair references)
static FavoriteCoin favorites[MAX_FAVORITE_COINS];

// Legacy arrays (maintained for backward compatibility with existing code)
String favoriteCoinSymbols[MAX_FAVORITE_COINS];  // Removed 'static' for forward declaration
int favoriteCoinCount = 0;  // Removed 'static' for forward declaration
static Preferences coinPrefs;  // For storing favorite coins

// Forward declaration of syncFavoritesWithPairs (defined later after necessary variables)
static void syncFavoritesWithPairs();

// Drag-and-drop reordering for favorites list
static bool favorites_dragging = false;
static int drag_source_index = -1;
static lv_obj_t *drag_ghost_button = nullptr;  // Visual indicator for drag
static int32_t drag_start_y = 0;
static int32_t drag_current_y = 0;

// Portfolio storage and UI
#define MAX_PORTFOLIO_COINS 100
struct PortfolioCoin {
  String symbol;       // e.g., "BTCUSDT"
  String baseCoin;     // e.g., "BTC"
  float amount;        // Quantity owned
  float last_price;    // Latest fetched USD price
  unsigned long last_price_update;
};
static PortfolioCoin portfolioCoins[MAX_PORTFOLIO_COINS];
static int portfolioCoinCount = 0;
static Preferences portfolioPrefs;
static float portfolio_total_value = 0.0f;
static unsigned long last_portfolio_price_check = 0;
static const unsigned long PORTFOLIO_PRICE_REFRESH_MS = 60000;
static int portfolio_next_price_index = 0;
static bool portfolio_amount_input_started = false;
static lv_timer_t *portfolio_total_revert_timer = nullptr;
static double portfolio_last_total_displayed = 0.0;

#define MAX_ENCODER_FOCUS_ITEMS 16

// Forward declarations for customization screen (used in encoder focus functions)
static lv_obj_t *customization_bg;
static lv_obj_t *customization_panel;

// Forward declarations for alerts popup (used in encoder focus functions)
lv_obj_t *alerts_popup_bg;
lv_obj_t *alerts_popup;

// Forward declarations for coins popup (used in encoder focus functions)
static lv_obj_t *coins_popup_bg;
static lv_obj_t *coins_popup;

// Forward declarations for pairs and favorites (needed by encoder focus functions)
// NOTE: These are declared without 'static' so they can be forward declared
// NOTE: PAIR_COUNT and MAX_FAVORITE_COINS are defined earlier in the file

// PairData struct (full definition needed for encoder focus functions)
// NOTE: Candle and MAX_CANDLES are already defined at lines 55 and 173
struct PairData {
  String symbol;
  String display_name;
  float last_price;
  unsigned long last_update;
  float daily_change_percent;
  unsigned long last_ticker_update;
  Candle candles[MAX_CANDLES];
  int candle_count;
  WebSocketsClient ws_client;
  bool is_selected;
};

extern PairData pairs[];
extern int active_pair_count;
extern String favoriteCoinSymbols[];
extern int favoriteCoinCount;

struct EncoderFocusItem {
  lv_obj_t *target;
  lv_obj_t *label;
  lv_obj_t *text_obj;
  lv_color_t base_bg;
  lv_color_t base_text;
  lv_opa_t base_bg_opa;
  bool highlight_bg;
};

struct EncoderFocusContext {
  bool active;
  lv_obj_t *screen;
  EncoderFocusItem items[MAX_ENCODER_FOCUS_ITEMS];
  int count;
  int index;
  bool has_highlight;
  bool just_highlighted_top;  // Track if we just highlighted the top button
};

static EncoderFocusContext encoder_focus_ctx = {false, nullptr, {}, 0, 0, false, false};

static void encoderFocusReset() {
  Serial.printf("[EncoderFocus] RESET called - active was: %d, count was: %d, screen was: %p\n", 
                encoder_focus_ctx.active, encoder_focus_ctx.count, encoder_focus_ctx.screen);
  
  // DON'T try to restore highlights during reset - we might be switching screens
  // and the "on_edit_page" check would give wrong results
  // Just clear the data structure
  
  encoder_focus_ctx.active = false;
  encoder_focus_ctx.screen = nullptr;
  encoder_focus_ctx.count = 0;
  encoder_focus_ctx.index = 0;
  encoder_focus_ctx.has_highlight = false;
  encoder_focus_ctx.just_highlighted_top = false;
  Serial.println("[EncoderFocus] RESET complete");
}

static bool encoderFocusItemFocusable(const EncoderFocusItem &item) {
  if (!item.target || !lv_obj_is_valid(item.target)) return false;
  if (lv_obj_has_flag(item.target, LV_OBJ_FLAG_HIDDEN)) return false;
  if (lv_obj_has_state(item.target, LV_STATE_DISABLED)) return false;
  return true;
}

static void encoderFocusApplyHighlight(int idx) {
  if (idx < 0 || idx >= encoder_focus_ctx.count) return;
  EncoderFocusItem &item = encoder_focus_ctx.items[idx];
  if (!encoderFocusItemFocusable(item)) return;

  // Check if we're on the Edit page (customization screen)
  // Check against customization_panel since that's the screen used in encoderFocusBegin
  bool on_edit_page = (encoder_focus_ctx.screen == customization_panel || 
                       (customization_bg && lv_obj_is_valid(customization_bg) && 
                        !lv_obj_has_flag(customization_bg, LV_OBJ_FLAG_HIDDEN)));
  
  // Check if we're on the Coins popup
  bool on_coins_popup = (encoder_focus_ctx.screen == coins_popup);
  
  // Check if this is the back button (last item in Edit page)
  bool is_back_button = on_edit_page && (idx == encoder_focus_ctx.count - 1);
  
  Serial.printf("[EncoderFocus] ApplyHighlight idx=%d, on_edit_page=%d, on_coins_popup=%d, is_back_button=%d, text_obj=%p\n", 
                idx, on_edit_page, on_coins_popup, is_back_button, item.text_obj);
  
  if (on_coins_popup) {
    // Coins popup: Make ALL text BLACK (name, price, %) when highlighted
    // Green background, but all child labels become black
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    
    // Set ALL child labels to black (coin name, price, %)
    uint32_t child_count = lv_obj_get_child_cnt(item.target);
    for (uint32_t i = 0; i < child_count; i++) {
      lv_obj_t *child = lv_obj_get_child(item.target, i);
      if (child && lv_obj_is_valid(child)) {
        lv_obj_set_style_text_color(child, COLOR_BLACK, LV_PART_MAIN | LV_STATE_DEFAULT);
      }
    }
    Serial.printf("[EncoderFocus] Set Coins popup button to GREEN bg with ALL text BLACK\n");
  }
  else if (on_edit_page && !is_back_button) {
    // On Edit page toggle rows: ONLY highlight text in green, no background change
    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      lv_obj_set_style_text_color(item.text_obj, COLOR_GREEN, LV_PART_MAIN | LV_STATE_DEFAULT);
      Serial.printf("[EncoderFocus] Set Edit page text to GREEN for idx %d\n", idx);
    }
  } else if (is_back_button) {
    // Back button: Green background with black text
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      lv_obj_set_style_text_color(item.text_obj, COLOR_BLACK, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    Serial.printf("[EncoderFocus] Set back button to GREEN bg with BLACK text\n");
  } else {
    // Other pages: Use normal highlighting with green background
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_FOCUSED);
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_PRESSED);
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
      lv_obj_set_style_bg_color(item.target, COLOR_GREEN, LV_PART_MAIN | LV_STATE_CHECKED);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_FOCUSED);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_PRESSED);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
      lv_obj_set_style_bg_opa(item.target, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_CHECKED);
    }

    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      lv_color_t highlight_text_color = item.highlight_bg ? COLOR_BLACK : COLOR_GREEN;
      lv_obj_set_style_text_color(item.text_obj, highlight_text_color, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
  }

  encoder_focus_ctx.index = idx;
  encoder_focus_ctx.has_highlight = true;
}

static void encoderFocusClearHighlight(int idx) {
  if (idx < 0 || idx >= encoder_focus_ctx.count) return;
  EncoderFocusItem &item = encoder_focus_ctx.items[idx];
  if (!item.target || !lv_obj_is_valid(item.target)) {
    Serial.printf("[EncoderFocus] ClearHighlight: item %d target is invalid, skipping\n", idx);
    return;
  }

  // Check if we're on the Edit page (customization screen)
  bool on_edit_page = (encoder_focus_ctx.screen == customization_panel || 
                       (customization_bg && lv_obj_is_valid(customization_bg) && 
                        !lv_obj_has_flag(customization_bg, LV_OBJ_FLAG_HIDDEN)));
  
  // Check if we're on the Coins popup
  bool on_coins_popup = (encoder_focus_ctx.screen == coins_popup);
  
  // Check if this is the back button (last item in Edit page OR last item in Coins popup)
  bool is_back_button = (on_edit_page && (idx == encoder_focus_ctx.count - 1)) ||
                        (on_coins_popup && (idx == encoder_focus_ctx.count - 1));
  
  if (on_coins_popup && !is_back_button) {
    // Coins popup coin buttons: Restore original background and ALL text colors
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    
    // Restore ALL child labels to their saved colors (green/red/white)
    // We need to re-fetch the colors from the pair data since they weren't saved
    int coin_idx = (int)(intptr_t)lv_obj_get_user_data(item.target);
    if (coin_idx >= 0 && coin_idx < favoriteCoinCount) {
      // Find the pair for this coin
      int pairIdx = -1;
      for (int p = 0; p < active_pair_count; p++) {
        if (pairs[p].symbol == favoriteCoinSymbols[coin_idx]) {
          pairIdx = p;
          break;
        }
      }
      
      if (pairIdx >= 0 && pairs[pairIdx].last_price > 0.0f) {
        // Determine color based on daily change
        lv_color_t text_color = COLOR_WHITE;
        if (pairs[pairIdx].daily_change_percent > 0.0f) {
          text_color = COLOR_GREEN;
        } else if (pairs[pairIdx].daily_change_percent < 0.0f) {
          text_color = COLOR_RED;
        }
        
        // Set all child labels to the appropriate color
        uint32_t child_count = lv_obj_get_child_cnt(item.target);
        for (uint32_t i = 0; i < child_count; i++) {
          lv_obj_t *child = lv_obj_get_child(item.target, i);
          if (child && lv_obj_is_valid(child)) {
            lv_obj_set_style_text_color(child, text_color, LV_PART_MAIN | LV_STATE_DEFAULT);
          }
        }
      } else {
        // No price data - coin name white, "Loading price.." red
        uint32_t child_count = lv_obj_get_child_cnt(item.target);
        for (uint32_t i = 0; i < child_count; i++) {
          lv_obj_t *child = lv_obj_get_child(item.target, i);
          if (child && lv_obj_is_valid(child)) {
            // First child is coin name (white), second is "Loading price.." (red)
            lv_color_t color = (i == 0) ? COLOR_WHITE : COLOR_RED;
            lv_obj_set_style_text_color(child, color, LV_PART_MAIN | LV_STATE_DEFAULT);
          }
        }
      }
    }
    Serial.printf("[EncoderFocus] Restored Coins popup button colors\n");
  }
  else if (on_edit_page && !is_back_button) {
    // On Edit page toggle rows: Restore original text color only
    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      Serial.printf("[EncoderFocus] About to restore Edit page text color for idx %d\n", idx);
      lv_obj_set_style_text_color(item.text_obj, item.base_text, LV_PART_MAIN | LV_STATE_DEFAULT);
      Serial.printf("[EncoderFocus] Restored Edit page text color for idx %d\n", idx);
    } else {
      Serial.printf("[EncoderFocus] ClearHighlight: item %d text_obj is invalid, skipping\n", idx);
    }
  } else if (is_back_button) {
    // Back button: Restore original background and text
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      lv_obj_set_style_text_color(item.text_obj, item.base_text, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
  } else {
    // Other pages: Restore original background and text
    if (item.highlight_bg) {
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_FOCUSED);
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_PRESSED);
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
      lv_obj_set_style_bg_color(item.target, item.base_bg, LV_PART_MAIN | LV_STATE_CHECKED);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_DEFAULT);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_FOCUSED);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_PRESSED);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
      lv_obj_set_style_bg_opa(item.target, item.base_bg_opa, LV_PART_MAIN | LV_STATE_CHECKED);
    }

    if (item.text_obj && lv_obj_is_valid(item.text_obj)) {
      lv_obj_set_style_text_color(item.text_obj, item.base_text, LV_PART_MAIN | LV_STATE_DEFAULT);
    }
  }

  if (idx == encoder_focus_ctx.index) {
    encoder_focus_ctx.has_highlight = false;
  }
}

static bool encoderFocusEnsureValidIndex() {
  if (encoder_focus_ctx.count == 0) {
    encoder_focus_ctx.active = false;
    encoder_focus_ctx.has_highlight = false;
    return false;
  }

  int idx = encoder_focus_ctx.index;
  if (idx < 0 || idx >= encoder_focus_ctx.count) {
    idx = 0;
  }

  int attempts = encoder_focus_ctx.count;
  while (attempts-- > 0) {
    EncoderFocusItem &item = encoder_focus_ctx.items[idx];
    if (encoderFocusItemFocusable(item)) {
      encoder_focus_ctx.index = idx;
      return true;
    }
    idx = (idx + 1) % encoder_focus_ctx.count;
  }

  // No focusable items
  encoder_focus_ctx.active = false;
  encoder_focus_ctx.has_highlight = false;
  return false;
}

static void encoderFocusBegin(lv_obj_t *screen) {
  encoderFocusReset();
  encoder_focus_ctx.screen = screen;
}

static bool encoderFocusIsActive() {
  if (!encoder_focus_ctx.active || encoder_focus_ctx.count == 0) return false;
  
  // For Edit page, check if customization_bg is visible (not the active screen itself)
  if (encoder_focus_ctx.screen == customization_panel) {
    return customization_bg && lv_obj_is_valid(customization_bg) && 
           !lv_obj_has_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  // For All Alerts popup, check if alerts_popup is visible (layer on top, not a screen)
  if (encoder_focus_ctx.screen == alerts_popup) {
    return alerts_popup_bg && lv_obj_is_valid(alerts_popup_bg) && 
           !lv_obj_has_flag(alerts_popup_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  // For Coins popup, check if coins_popup is visible (layer on top, not a screen)
  if (encoder_focus_ctx.screen == coins_popup) {
    return coins_popup_bg && lv_obj_is_valid(coins_popup_bg) && 
           !lv_obj_has_flag(coins_popup_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  // For other screens, check if the screen is active
  return (lv_scr_act() == encoder_focus_ctx.screen);
}

static bool encoderFocusHasHighlight() {
  return encoder_focus_ctx.has_highlight;
}

static void encoderFocusAdd(lv_obj_t *target, lv_obj_t *label) {
  if (!target || !lv_obj_is_valid(target)) return;
  if (encoder_focus_ctx.count >= MAX_ENCODER_FOCUS_ITEMS) return;

  EncoderFocusItem &item = encoder_focus_ctx.items[encoder_focus_ctx.count++];
  item.target = target;
  item.label = (label && lv_obj_is_valid(label)) ? label : nullptr;
  item.text_obj = item.label ? item.label : target;
  item.base_bg = lv_obj_get_style_bg_color(target, LV_PART_MAIN);
  item.base_bg_opa = lv_obj_get_style_bg_opa(target, LV_PART_MAIN);
  item.base_text = lv_obj_get_style_text_color(item.text_obj, LV_PART_MAIN);
  item.highlight_bg = (item.base_bg_opa > 0);
}

static void encoderFocusCommit(int initial_index) {
  if (encoder_focus_ctx.count == 0) {
    encoder_focus_ctx.active = false;
    Serial.printf("[EncoderFocus] Commit: count=0, setting active=false\n");
    return;
  }

  encoder_focus_ctx.active = true;
  if (!encoderFocusEnsureValidIndex()) {
    Serial.printf("[EncoderFocus] Commit: encoderFocusEnsureValidIndex failed\n");
    return;
  }
  
  // DO NOT auto-highlight - only highlight when user actually rotates the wheel
  // Set initial index to top button, but don't highlight yet
  int top_index = encoderFocusFindTopIndex();
  if (top_index >= 0) {
    encoder_focus_ctx.index = top_index;
  } else {
    // Fallback to preferred index if no top found
    int preferred = encoderFocusFindPreferredIndex();
    if (preferred >= 0) {
      encoder_focus_ctx.index = preferred;
    } else {
      encoder_focus_ctx.index = 0;
    }
  }
  
  // Don't highlight until user rotates
  encoder_focus_ctx.has_highlight = false;
  encoder_focus_ctx.just_highlighted_top = false;
  
  Serial.printf("[EncoderFocus] Commit: active=%d, count=%d, index=%d, screen=%p\n", 
                encoder_focus_ctx.active, encoder_focus_ctx.count, 
                encoder_focus_ctx.index, encoder_focus_ctx.screen);
}

static lv_coord_t encoderFocusGetAbsoluteX(lv_obj_t *obj) {
  lv_coord_t x = 0;
  lv_obj_t *current = obj;
  while (current && lv_obj_is_valid(current)) {
    x += lv_obj_get_x(current);
    lv_obj_t *parent = lv_obj_get_parent(current);
    if (!parent) break;
    current = parent;
  }
  return x;
}

static lv_coord_t encoderFocusGetAbsoluteY(lv_obj_t *obj) {
  if (!obj || !lv_obj_is_valid(obj)) return INT32_MAX;
  
  // For Edit page items (children of customization_panel), just use relative Y
  // Don't accumulate parent positions as they're all in the same scrollable panel
  if (encoder_focus_ctx.screen == customization_panel) {
    return lv_obj_get_y(obj);
  }
  
  // For other screens, accumulate absolute position
  lv_coord_t y = 0;
  lv_obj_t *current = obj;
  int depth = 0;
  while (current && lv_obj_is_valid(current) && depth < 10) {
    y += lv_obj_get_y(current);
    lv_obj_t *parent = lv_obj_get_parent(current);
    if (!parent || parent == lv_scr_act()) break;
    current = parent;
    depth++;
  }
  return y;
}

static int encoderFocusFindTopIndex() {
  // ALWAYS return the first focusable item (index 0)
  // This works for all pages: items are added in visual order (top to bottom)
  // Edit page: 0=Clock, 1=WiFi, 2=Alerts, etc.
  // Welcome page: 0=Get Started, 1=Portfolio, 2=Settings
  // Settings page: 0=WiFi, 1=About, 2=Back
  for (int i = 0; i < encoder_focus_ctx.count; i++) {
    if (encoderFocusItemFocusable(encoder_focus_ctx.items[i])) {
      Serial.printf("[EncoderFocus] FindTopIndex: idx=%d (first focusable item)\n", i);
      return i;
    }
  }
  
  Serial.println("[EncoderFocus] FindTopIndex: no focusable items found");
  return -1;
}

static int encoderFocusFindMiddleIndex() {
  lv_coord_t screen_mid_y = lv_disp_get_ver_res(NULL) / 2;
  int candidate = -1;
  int32_t best_delta = INT32_MAX;
  lv_coord_t best_x = INT32_MAX;

  for (int i = 0; i < encoder_focus_ctx.count; i++) {
    EncoderFocusItem &item = encoder_focus_ctx.items[i];
    if (!encoderFocusItemFocusable(item)) continue;

    lv_coord_t top = encoderFocusGetAbsoluteY(item.target);
    lv_coord_t height = lv_obj_get_height(item.target);
    lv_coord_t center = top + (height / 2);
    int32_t delta = abs(center - screen_mid_y);
    lv_coord_t x = encoderFocusGetAbsoluteX(item.target);
    if (delta < best_delta || (delta == best_delta && x < best_x)) {
      candidate = i;
      best_delta = delta;
      best_x = x;
    }
  }

  return candidate;
}

static int encoderFocusFindLeftIndex() {
  int candidate = -1;
  lv_coord_t best_x = INT32_MAX;
  lv_coord_t best_y = INT32_MAX;

  for (int i = 0; i < encoder_focus_ctx.count; i++) {
    EncoderFocusItem &item = encoder_focus_ctx.items[i];
    if (!encoderFocusItemFocusable(item)) continue;

    lv_coord_t x = encoderFocusGetAbsoluteX(item.target);
    lv_coord_t y = encoderFocusGetAbsoluteY(item.target);
    if (x < best_x || (x == best_x && y < best_y)) {
      candidate = i;
      best_x = x;
      best_y = y;
    }
  }

  return candidate;
}

static int encoderFocusFindPreferredIndex() {
  // ALWAYS prefer top index first - user wants top button highlighted initially
  int idx = encoderFocusFindTopIndex();
  if (idx >= 0) return idx;

  // Only fall back to middle if no top found
  idx = encoderFocusFindMiddleIndex();
  if (idx >= 0) return idx;

  return encoderFocusFindLeftIndex();
}

static bool encoderFocusEnsureHighlight() {
  if (!encoderFocusEnsureValidIndex()) {
    return false;
  }

  if (encoder_focus_ctx.has_highlight) {
    EncoderFocusItem &item = encoder_focus_ctx.items[encoder_focus_ctx.index];
    if (encoderFocusItemFocusable(item)) {
      return true;
    }
    encoderFocusClearHighlight(encoder_focus_ctx.index);
  }

  // ALWAYS prefer top index first - user wants top button highlighted initially
  int preferred = encoderFocusFindTopIndex();
  if (preferred < 0) {
    // Fall back to preferred index if no top found
    preferred = encoderFocusFindPreferredIndex();
  }
  
  if (preferred < 0) {
    encoder_focus_ctx.active = false;
    return false;
  }

  encoder_focus_ctx.index = preferred;
  encoderFocusApplyHighlight(preferred);
  
  // Check if we highlighted the top button
  int top_index = encoderFocusFindTopIndex();
  encoder_focus_ctx.just_highlighted_top = (preferred == top_index);
  
  return encoder_focus_ctx.has_highlight;
}

static void encoderFocusDisable() {
  encoderFocusReset();
}

static void encoderFocusMove(int delta) {
  if (!encoderFocusIsActive()) {
    Serial.println("[EncoderFocus] Move called but not active");
    return;
  }
  
  Serial.printf("[EncoderFocus] Move delta=%d, has_highlight=%d, count=%d, index=%d\n", 
                delta, encoder_focus_ctx.has_highlight, encoder_focus_ctx.count, encoder_focus_ctx.index);
  
  if (!encoder_focus_ctx.has_highlight) {
    // First rotation: ALWAYS highlight the top button - use FindTopIndex directly
    // This ensures we always get the actual topmost button, not a fallback
    // Find the absolute topmost button by Y position, then leftmost if same Y
    // Don't call encoderFocusEnsureValidIndex first as it might change the index
    int top_index = encoderFocusFindTopIndex();
    Serial.printf("[EncoderFocus] First rotation: top_index=%d\n", top_index);
    if (top_index >= 0 && top_index < encoder_focus_ctx.count) {
      // Verify this index is actually focusable
      EncoderFocusItem &item = encoder_focus_ctx.items[top_index];
      if (encoderFocusItemFocusable(item)) {
        encoder_focus_ctx.index = top_index;
        encoderFocusApplyHighlight(top_index);
        encoder_focus_ctx.just_highlighted_top = true;
        Serial.printf("[EncoderFocus] Highlighted top item %d\n", top_index);
        return;  // First rotation just highlights - don't move yet
      }
    }
    // Fallback only if no valid top index found
    if (!encoderFocusEnsureValidIndex()) return;
    int preferred = encoderFocusFindPreferredIndex();
    if (preferred >= 0 && preferred < encoder_focus_ctx.count) {
      EncoderFocusItem &item = encoder_focus_ctx.items[preferred];
      if (encoderFocusItemFocusable(item)) {
        encoder_focus_ctx.index = preferred;
        encoderFocusApplyHighlight(preferred);
        encoder_focus_ctx.just_highlighted_top = false;
        return;
      }
    }
    return;
  }
  
  // After first highlight, ensure valid index before moving
  if (!encoderFocusEnsureValidIndex()) return;
  
  // If we just highlighted the top button, ignore the first rotation
  // User wants to rotate once more before highlight drops down
  if (encoder_focus_ctx.just_highlighted_top) {
    encoder_focus_ctx.just_highlighted_top = false;  // Clear flag - next rotation will move
    return;  // Stay at top on first rotation after highlighting
  }

  if (encoder_focus_ctx.count <= 1) return;

  int old_index = encoder_focus_ctx.index;
  int new_index = old_index;
  int attempts = encoder_focus_ctx.count;

  do {
    new_index = (new_index + delta + encoder_focus_ctx.count) % encoder_focus_ctx.count;
    if (encoderFocusItemFocusable(encoder_focus_ctx.items[new_index])) {
      break;
    }
  } while (--attempts > 0);

  if (new_index == old_index) return;

  encoderFocusClearHighlight(old_index);
  encoder_focus_ctx.index = new_index;
  encoderFocusApplyHighlight(new_index);
  
  // Auto-scroll the Edit page panel to keep focused item visible
  if (encoder_focus_ctx.screen == customization_panel && customization_panel && lv_obj_is_valid(customization_panel)) {
    // Detect wrapping from bottom to top (back button to Clock)
    if (old_index == encoder_focus_ctx.count - 1 && new_index == 0) {
      // Wrapped to top - scroll to top
      lv_obj_scroll_to_y(customization_panel, 0, LV_ANIM_ON);
      Serial.println("[Edit] Wrapped to top - scrolling to start");
    }
    // Don't auto-scroll when on back button (last item)
    else if (new_index != encoder_focus_ctx.count - 1) {
      EncoderFocusItem &item = encoder_focus_ctx.items[new_index];
      if (item.target && lv_obj_is_valid(item.target)) {
        // Get the Y position of the focused item relative to the panel
        lv_coord_t item_y = lv_obj_get_y(item.target);
        lv_coord_t item_height = lv_obj_get_height(item.target);
        
        // Get panel scroll position and dimensions
        lv_coord_t scroll_y = lv_obj_get_scroll_y(customization_panel);
        lv_coord_t panel_height = lv_obj_get_height(customization_panel);
        
        // Define margins (how much space to keep from edges)
        // Smaller margins = scroll earlier when approaching edges
        const lv_coord_t top_margin = 40;    // Keep 40px from top
        const lv_coord_t bottom_margin = 120; // Keep 120px from bottom (scroll earlier)
        
        // Calculate visible area (accounting for scroll)
        lv_coord_t visible_top = scroll_y + top_margin;
        lv_coord_t visible_bottom = scroll_y + panel_height - bottom_margin;
        
        // Check if item is above visible area (need to scroll up)
        if (item_y < visible_top) {
          lv_coord_t new_scroll = item_y - top_margin;
          if (new_scroll < 0) new_scroll = 0;
          lv_obj_scroll_to_y(customization_panel, new_scroll, LV_ANIM_ON);
          Serial.printf("[Edit] Auto-scroll UP: item_y=%d, new_scroll=%d\n", item_y, new_scroll);
        }
        // Check if item is below visible area (need to scroll down)
        else if (item_y + item_height > visible_bottom) {
          lv_coord_t new_scroll = (item_y + item_height) - panel_height + bottom_margin;
          lv_obj_scroll_to_y(customization_panel, new_scroll, LV_ANIM_ON);
          Serial.printf("[Edit] Auto-scroll DOWN: item_y=%d, item_height=%d, new_scroll=%d\n", 
                        item_y, item_height, new_scroll);
        }
      }
    } else {
      Serial.println("[Edit] On back button - no auto-scroll");
    }
  }
}

static void encoderFocusActivate() {
  if (!encoderFocusIsActive()) return;

  if (!encoderFocusEnsureValidIndex()) return;

  if (!encoder_focus_ctx.has_highlight) {
    int preferred = encoderFocusFindPreferredIndex();
    if (preferred < 0) return;
    encoder_focus_ctx.index = preferred;
  }

  EncoderFocusItem &item = encoder_focus_ctx.items[encoder_focus_ctx.index];
  if (!encoderFocusItemFocusable(item)) return;

  // Store current index before activation
  int current_index = encoder_focus_ctx.index;
  
  // Check if we're on the Edit page by checking screen
  bool on_edit_page = (encoder_focus_ctx.screen == customization_panel);

  if (on_edit_page && encoder_focus_ctx.index < 7) {
    // This is a toggle row on Edit page - find the click_area (child 2) and trigger it
    lv_obj_t *row = item.target;
    
    if (row && lv_obj_is_valid(row)) {
      // click_area is the 3rd child (index 2: label=0, toggle_bg=1, click_area=2)
      lv_obj_t *click_area = lv_obj_get_child(row, 2);
      
      if (click_area && lv_obj_is_valid(click_area)) {
        // Just trigger the click event - the callback has the state_var in its event user data
        Serial.printf("[Edit] Toggling item %d\n", encoder_focus_ctx.index);
        lv_event_send(click_area, LV_EVENT_CLICKED, NULL);
        // Highlight stays on Edit page - user is still navigating toggles
        return;
      }
    }
  }

  // Normal activation for other pages (only if has highlight)
  if (encoder_focus_ctx.has_highlight) {
    // ALWAYS clear highlight before clicking to prevent race conditions
    encoderFocusClearHighlight(current_index);
    encoder_focus_ctx.has_highlight = false;
    
    // Then trigger the click event
    lv_event_send(item.target, LV_EVENT_CLICKED, NULL);
    
    Serial.printf("[EncoderFocus] Cleared highlight before activation (idx %d)\n", current_index);
  }
}

/* ===== Reusable UI Component Helper Functions ===== */

/**
 * @brief Creates a standard popup with consistent styling
 * @param parent Parent object (typically lv_layer_top())
 * @param width Popup width in pixels
 * @param height Popup height in pixels
 * @param title Title text (NULL for no title)
 * @return Pointer to the created popup panel
 * @note Popup has dark gray background, 20px radius, 20px padding
 */
static lv_obj_t* createStandardPopup(lv_obj_t* parent, int width, int height, const char* title) {
  lv_obj_t* popup = lv_obj_create(parent);
  lv_obj_set_size(popup, width, height);
  lv_obj_align(popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(popup, COLOR_DARK_GRAY, 0);
  lv_obj_set_style_radius(popup, POPUP_RADIUS, 0);
  lv_obj_set_style_border_width(popup, 0, 0);
  lv_obj_set_style_pad_all(popup, POPUP_PADDING, 0);
  lv_obj_set_scrollbar_mode(popup, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(popup, LV_OBJ_FLAG_SCROLLABLE);
  
  // Add title if provided
  if (title) {
    lv_obj_t* title_label = lv_label_create(popup);
    lv_label_set_text(title_label, title);
    lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
    lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, POPUP_TITLE_Y_OFFSET);
  }
  
  return popup;
}

/**
 * @brief Creates a dark overlay background for popups
 * @param parent Parent object (typically lv_layer_top())
 * @param click_callback Optional callback for background clicks (NULL for no callback)
 * @return Pointer to the created overlay background
 */
static lv_obj_t* createPopupOverlay(lv_obj_t* parent, lv_event_cb_t click_callback) {
  lv_obj_t* overlay = lv_obj_create(parent);
  lv_obj_set_size(overlay, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_bg_color(overlay, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(overlay, LV_OPA_50, 0);
  lv_obj_set_style_border_width(overlay, 0, 0);
  lv_obj_clear_flag(overlay, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(overlay, LV_OBJ_FLAG_CLICKABLE);
  
  if (click_callback) {
    lv_obj_add_event_cb(overlay, click_callback, LV_EVENT_CLICKED, NULL);
  }
  
  return overlay;
}

/**
 * @brief Creates a standard back button with consistent styling
 * @param parent Parent container
 * @param callback Click callback function
 * @param user_data Optional user data to pass to callback
 * @return Pointer to the created button
 * @note Button is white with black text, standard size (120x50)
 */
static lv_obj_t* createBackButton(lv_obj_t* parent, lv_event_cb_t callback, void* user_data = nullptr) {
  lv_obj_t* btn = lv_btn_create(parent);
  lv_obj_set_size(btn, BUTTON_WIDTH_BACK, BUTTON_HEIGHT_STANDARD);
  lv_obj_set_style_bg_color(btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
  
  if (callback) {
    lv_obj_add_event_cb(btn, callback, LV_EVENT_CLICKED, user_data);
  }
  
  lv_obj_t* label = lv_label_create(btn);
  lv_label_set_text(label, "Back");
  lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(label, &poppins_medium_20, 0);
  lv_obj_center(label);
  
  // Ensure text stays black in all states
  lv_obj_set_style_text_color(label, COLOR_BLACK, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_text_color(label, COLOR_BLACK, LV_PART_MAIN | LV_STATE_FOCUSED);
  
  return btn;
}

/**
 * @brief Creates a standard button with custom text and styling
 * @param parent Parent container
 * @param text Button text
 * @param width Button width
 * @param height Button height
 * @param bg_color Background color
 * @param text_color Text color
 * @param callback Click callback function
 * @return Pointer to the created button
 */
static lv_obj_t* createStandardButton(lv_obj_t* parent, const char* text, int width, int height, 
                                      lv_color_t bg_color, lv_color_t text_color, lv_event_cb_t callback) {
  lv_obj_t* btn = lv_btn_create(parent);
  lv_obj_set_size(btn, width, height);
  lv_obj_set_style_bg_color(btn, bg_color, 0);
  lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
  
  if (callback) {
    lv_obj_add_event_cb(btn, callback, LV_EVENT_CLICKED, NULL);
  }
  
  lv_obj_t* label = lv_label_create(btn);
  lv_label_set_text(label, text);
  lv_obj_set_style_text_color(label, text_color, 0);
  lv_obj_set_style_text_font(label, &poppins_medium_20, 0);
  lv_obj_center(label);
  
  return btn;
}

/**
 * @brief Creates a scrollable list container with consistent styling
 * @param parent Parent container
 * @param width List width
 * @param height List height
 * @param enable_scrollbar Show scrollbar (true) or hide (false)
 * @return Pointer to the created list container
 */
static lv_obj_t* createScrollableList(lv_obj_t* parent, int width, int height, bool enable_scrollbar = true) {
  lv_obj_t* list = lv_obj_create(parent);
  lv_obj_set_size(list, width, height);
  lv_obj_set_style_bg_color(list, COLOR_DARK_GRAY, 0);
  lv_obj_set_style_border_width(list, 0, 0);
  lv_obj_set_style_pad_all(list, 0, 0);
  lv_obj_set_scrollbar_mode(list, enable_scrollbar ? LV_SCROLLBAR_MODE_AUTO : LV_SCROLLBAR_MODE_OFF);
  lv_obj_set_scroll_dir(list, LV_DIR_VER);
  
  return list;
}

/**
 * @brief Safely deletes a popup and resets encoder focus
 * @param popup_bg Pointer to popup background overlay
 * @param popup_name Name for logging (optional)
 * @note Also resets sleep timer to prevent accidental sleep
 */
// Forward declaration (function defined after encoderPressStart is declared)
static void safeDeletePopup(lv_obj_t*& popup_bg, const char* popup_name = "Popup");

/* ===== Popup Management System ===== */
// Forward declaration (struct defined later after UI globals)
struct PopupManager;


/* ===== Error Handling & Validation Helpers ===== */

/**
 * @brief Validates if a pair index is within valid range and has data
 * @param pair_idx Pair index to validate
 * @param function_name Name of calling function (for logging)
 * @return true if valid, false otherwise
 */
static bool validatePairIndex(int pair_idx, const char* function_name = "Unknown") {
  if (pair_idx < 0 || pair_idx >= active_pair_count) {
    Serial.printf("[ERROR] %s: Invalid pair index %d (active_pair_count=%d)\n", 
                  function_name, pair_idx, active_pair_count);
    return false;
  }
  
  if (pairs[pair_idx].symbol.length() == 0) {
    Serial.printf("[ERROR] %s: Pair %d has no symbol\n", function_name, pair_idx);
    return false;
  }
  
  return true;
}

/**
 * @brief Validates if a price is valid (> 0 and not NaN)
 * @param price Price to validate
 * @param coin_symbol Symbol of the coin (for logging)
 * @param function_name Name of calling function (for logging)
 * @return true if valid, false otherwise
 */
static bool validatePrice(float price, const char* coin_symbol = "Unknown", const char* function_name = "Unknown") {
  if (price <= 0.0f || isnan(price) || isinf(price)) {
    Serial.printf("[ERROR] %s: Invalid price for %s: %.8f\n", 
                  function_name, coin_symbol, price);
    return false;
  }
  return true;
}

/**
 * @brief Validates if an LVGL object is valid and not null
 * @param obj Object to validate
 * @param obj_name Name of object (for logging)
 * @param function_name Name of calling function (for logging)
 * @return true if valid, false otherwise
 */
static bool validateLVObject(lv_obj_t* obj, const char* obj_name = "Object", const char* function_name = "Unknown") {
  if (!obj) {
    Serial.printf("[ERROR] %s: %s is NULL\n", function_name, obj_name);
    return false;
  }
  
  if (!lv_obj_is_valid(obj)) {
    Serial.printf("[ERROR] %s: %s is invalid (deleted or corrupted)\n", function_name, obj_name);
    return false;
  }
  
  return true;
}

/**
 * @brief Validates if WiFi is connected
 * @param function_name Name of calling function (for logging)
 * @return true if connected, false otherwise
 */
static bool validateWiFiConnection(const char* function_name = "Unknown") {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.printf("[ERROR] %s: WiFi not connected (status=%d)\n", 
                  function_name, WiFi.status());
    return false;
  }
  return true;
}

/**
 * @brief Safely gets a coin name from favorites, with bounds checking
 * @param idx Index in favoriteCoinSymbols array
 * @return Coin symbol or "UNKNOWN" if invalid
 */
static String safeGetCoinSymbol(int idx) {
  if (idx < 0 || idx >= favoriteCoinCount) {
    Serial.printf("[ERROR] safeGetCoinSymbol: Index %d out of range (0-%d)\n", 
                  idx, favoriteCoinCount - 1);
    return "UNKNOWN";
  }
  
  if (favoriteCoinSymbols[idx].length() == 0) {
    Serial.printf("[ERROR] safeGetCoinSymbol: Empty symbol at index %d\n", idx);
    return "UNKNOWN";
  }
  
  return favoriteCoinSymbols[idx];
}

// Portfolio main page UI
static lv_obj_t *portfolio_screen = nullptr;
static lv_obj_t *portfolio_list = nullptr;
static lv_obj_t *portfolio_total_label = nullptr;
static lv_obj_t *portfolio_empty_label = nullptr;
static lv_obj_t *portfolio_manage_btn = nullptr;
static lv_obj_t *portfolio_back_btn = nullptr;
static const int PORTFOLIO_SCROLL_MAX = 225;

// Portfolio popup UI
static lv_obj_t *portfolio_popup_overlay = nullptr;
static lv_obj_t *portfolio_popup = nullptr;
static lv_obj_t *portfolio_popup_title = nullptr;
static lv_obj_t *portfolio_popup_amount = nullptr;
static lv_obj_t *portfolio_amount_btn = nullptr;
static lv_obj_t *portfolio_remove_btn = nullptr;
static lv_obj_t *portfolio_amount_ta = nullptr;
static lv_obj_t *portfolio_amount_kb = nullptr;
static int portfolio_selected_index = -1;

// Portfolio manage/search UI
static lv_obj_t *portfolio_manage_screen = nullptr;
static lv_obj_t *portfolio_search_bar = nullptr;
static lv_obj_t *portfolio_search_kb = nullptr;
static lv_obj_t *portfolio_search_list = nullptr;
static lv_obj_t *portfolio_manage_back_btn = nullptr;
static String portfolio_search_query = "";
static bool portfolio_search_list_scrolling = false;
static CoinSearchInfo portfolioSearchResults[MAX_SEARCH_RESULTS];
static int portfolioSearchResultCount = 0;

// Crypto display screen (coin screen with live prices)
static lv_obj_t *crypto_display_screen = nullptr;

// Settings page UI
static lv_obj_t *settings_screen = nullptr;
static lv_obj_t *settings_list   = nullptr;
static lv_obj_t *settings_back_btn = nullptr;

// Wi-Fi settings page UI
static lv_obj_t *wifi_settings_screen = nullptr;
static lv_obj_t *wifi_settings_list = nullptr;
static lv_obj_t *wifi_settings_refresh_btn = nullptr;
static lv_obj_t *wifi_settings_back_btn = nullptr;
static lv_obj_t *wifi_settings_popup = nullptr;
static lv_obj_t *wifi_settings_popup_label = nullptr;
static lv_obj_t *wifi_settings_password_ta = nullptr;
static lv_obj_t *wifi_settings_kb = nullptr;
static lv_obj_t *wifi_settings_cancel_btn = nullptr;
static lv_obj_t *wifi_settings_connect_btn = nullptr;
static lv_obj_t *wifi_settings_connecting_label = nullptr;
static lv_obj_t *wifi_settings_logo = nullptr;
static lv_obj_t *wifi_settings_status_label = nullptr;
static lv_obj_t *wifi_connecting_screen = nullptr;
static lv_obj_t *wifi_connecting_label = nullptr;
static lv_timer_t *wifi_connecting_timer = nullptr;
static int wifi_connecting_dots = 0;
static bool wifi_screen_transitioning = false;
static lv_obj_t *wifi_prev_screen = nullptr; // screen to return to after connecting
// Display & Brightness settings page UI
static lv_obj_t *brightness_screen = nullptr;
static lv_obj_t *brightness_slider = nullptr;
static lv_obj_t *brightness_value_label = nullptr;
static lv_obj_t *brightness_back_btn = nullptr;
static int current_brightness_percent = 80; // Store current brightness percentage
// About page UI
static lv_obj_t *about_screen = nullptr;
static lv_obj_t *about_back_btn = nullptr;
static lv_obj_t *about_ota_btn = nullptr;
static lv_obj_t *about_reboot_btn = nullptr;

// WiFi overlay for darkening background
static lv_obj_t *wifi_overlay = nullptr;

// Wi-Fi persistence and info popup
static Preferences wifiPrefs;
static Preferences customPrefs; // For customization settings
static lv_obj_t *wifi_info_popup = nullptr;
static lv_obj_t *wifi_info_label = nullptr;
static lv_obj_t *wifi_info_forget_btn = nullptr;
static lv_obj_t *wifi_info_close_btn = nullptr;
static String wifi_info_current_ssid = ""; // Store SSID for popup

// Control Panel (draggable from top)
static lv_obj_t *control_panel = nullptr;
static lv_obj_t *control_panel_bg = nullptr;
static lv_obj_t *control_panel_grabber = nullptr;
static lv_obj_t *control_brightness_slider = nullptr;
static lv_obj_t *control_menu_btn = nullptr;
static lv_obj_t *control_customization_btn = nullptr;
static lv_obj_t *control_alert_btn = nullptr;

// Alert popup UI
static lv_obj_t *alert_bg = nullptr;  // Background overlay for alert
static lv_obj_t *alert_popup = nullptr;
static lv_obj_t *alert_popup_title = nullptr;
static lv_obj_t *alert_coin_label = nullptr;
static lv_obj_t *alert_price_display = nullptr;  // Container for price display
static lv_obj_t *alert_price_labels[30] = {nullptr};  // Individual character labels for highlighting
static lv_obj_t *alert_create_btn = nullptr;
static lv_obj_t *alert_back_btn = nullptr;
static float alert_price_value = 0.0f;  // Current alert price value
static bool alert_encoder_mode = false;  // True when encoder is controlling alert price
static int alert_digit_index = 0;  // Current digit being edited (0 = leftmost digit)
static int alert_char_positions[30] = {0};  // Maps digit index to character position in string
static int alert_num_digits = 0;  // Total number of editable digits (excluding punctuation)
static bool control_panel_visible = false;

// Alert system - universal alerts for all coins
#define MAX_TOTAL_ALERTS 50
struct PriceAlert {
  String coin_symbol;    // Coin symbol (e.g., "BTC", "XRP")
  String coin_name;      // Display name (e.g., "Bitcoin", "XRP")
  float price;           // Alert price level
  unsigned long created; // Timestamp when created
  bool active;           // Is this alert slot active?
  bool is_upward;        // True if alert is above creation price (GREEN), false if below (RED)
};
static PriceAlert coin_alerts[MAX_TOTAL_ALERTS];  // Universal alerts for all coins
static lv_obj_t *alert_bell_icon = nullptr;           // Bell icon on homepage
// alerts_popup_bg and alerts_popup are forward declared at lines 276-277 (no redeclaration needed)
static lv_obj_t *alert_delete_popup = nullptr;        // Confirmation popup for delete
static int selected_alert_index = -1;                 // Alert selected for deletion
static bool alert_triggered = false;                  // Is an alert currently showing?
static lv_obj_t *alert_flash_border = nullptr;        // Alert badge card
static float triggered_alert_price = 0.0f;            // Price that was just triggered
static String triggered_alert_coin = "";              // Coin name that triggered (e.g., "BTC")
static bool alert_is_upward = false;                  // Flash direction (green=up, red=down)

// Coin Info button and popup
static lv_obj_t *coin_info_button = nullptr;          // Coin info button in control panel
static lv_obj_t *coin_info_popup_bg = nullptr;        // Coin info popup background overlay
static lv_obj_t *coin_info_popup = nullptr;           // Coin info popup panel
static lv_obj_t *coin_info_label = nullptr;           // Label displaying coin stats

// Coins Quick Navigation popup (from rotary menu)
// coins_popup_bg and coins_popup are forward declared earlier for encoder focus
static lv_obj_t *coins_popup_list = nullptr;          // List of coins in popup

// Coin Info Cache (to prevent 429 rate limit errors)
#define COIN_INFO_CACHE_SIZE 10
#define COIN_INFO_CACHE_DURATION 600000  // 10 minutes in milliseconds
struct CoinInfoCache {
  String symbol;
  String displayData;  // Pre-formatted display string with colors
  unsigned long timestamp;
  bool valid;
};
static CoinInfoCache coin_info_cache[COIN_INFO_CACHE_SIZE];

// Customization screen (UI visibility settings)
static lv_obj_t *customization_screen = nullptr;
// customization_panel and customization_bg forward declared earlier for encoder focus functions
static lv_obj_t *customization_back_btn = nullptr;
static lv_obj_t *customization_toggle_rows[7] = {nullptr}; // Store toggle rows for encoder focus

// UI visibility preferences
static bool show_clock = true;
static bool show_wifi = true;
static bool show_coin_name = true;
static bool show_timeframe = true;
static bool show_candles = true;
static bool show_price = true;
static bool show_alert_bell = true;
static bool show_coin_info = true;

// ===== OTA UPDATE GLOBALS =====
static lv_obj_t *ota_update_screen = nullptr;
static lv_obj_t *ota_update_label = nullptr;
static lv_obj_t *ota_progress_bar = nullptr;
static lv_obj_t *ota_status_label = nullptr;
static lv_obj_t *ota_back_btn = nullptr;
static lv_obj_t *ota_check_btn = nullptr;
static lv_obj_t *ota_version_label = nullptr;
static lv_obj_t *ota_check_btn_label = nullptr; // Store label for text changes

// OTA state variables
static bool ota_update_available = false;
static bool ota_update_in_progress = false;
static String latest_version = "";
static unsigned long last_ota_check = 0;
static String ota_update_status = "";

// OTA warning popup
static lv_obj_t *ota_warning_popup = nullptr;
static lv_obj_t *ota_warning_label = nullptr;
static lv_obj_t *ota_warning_cancel_btn = nullptr;
static lv_obj_t *ota_warning_continue_btn = nullptr;

// OTA progress screen
static lv_obj_t *ota_progress_screen = nullptr;
static lv_obj_t *ota_progress_logo = nullptr;
static lv_obj_t *ota_progress_bar_modern = nullptr;
static lv_obj_t *ota_progress_label = nullptr;
// Crypto loading screen (when loading favorites)
static lv_obj_t *crypto_loading_screen = nullptr;
static lv_obj_t *crypto_loading_logo = nullptr;
static lv_obj_t *crypto_loading_bar = nullptr;
static lv_obj_t *crypto_loading_label = nullptr;
static int crypto_loading_progress = 0;
static lv_timer_t *crypto_loading_step_timer = nullptr;
static int crypto_loading_step = 0;
static bool control_panel_dragging = false;
static int32_t control_panel_start_y = 0;
static int32_t control_panel_press_base_y = 0;
static int32_t control_panel_current_y = -600;
static int32_t control_panel_height = 420; // Increased to add more space
static int32_t control_panel_width = 450;
static int32_t control_panel_max_drag = 600;
// Crypto loading logo (old system - for showing coin logo on pair change)
static lv_obj_t *crypto_loading_logo_overlay = nullptr;
static lv_anim_t crypto_loading_fade_anim;
static lv_timer_t *crypto_loading_timer = nullptr;
// WiFi sorting structure
struct WiFiNetwork {
  String ssid;
  int32_t rssi;
  int index;
};
static lv_obj_t *price_label     = nullptr;
static lv_obj_t *pair_label      = nullptr;
static lv_obj_t *crypto_logo_obj = nullptr;  // label (BTC) or image (XRP)
static lv_obj_t *clock_label     = nullptr;
static lv_obj_t *tf_label        = nullptr;
static lv_obj_t *tf_btn          = nullptr;
static lv_obj_t *tf_menu         = nullptr;
static lv_obj_t *loading_pair_label = nullptr;

static lv_obj_t *wifi_signal     = nullptr;   // iOS bars (foreground)
static lv_obj_t *wifi_signal_bg  = nullptr;   // 3-bar background at 10% opacity
static unsigned long lastWiFiUpdate = 0;
static unsigned long lastWiFiReconnectCheck = 0;  // For auto-reconnect
static unsigned long lastTickerUpdate = 0;  // For 24h ticker updates
static bool wifi_scan_in_progress = false;
static unsigned long wifi_scan_start_time = 0;
static const unsigned long WIFI_SCAN_TIMEOUT = 15000; // 15 seconds timeout

// Battery UI
static lv_obj_t *battery_label = nullptr;
static unsigned long lastBatteryUpdate = 0;
static lv_obj_t *battery_img = nullptr;
static int lastBatteryClass = -1; // 10,25,50,75,100
static bool sleepRequested = false;
static unsigned long encoderPressStart = 0;
static unsigned long lastWakeTime = 0; // Wake cooldown timer (3s minimum after wake)
static unsigned long lastStatusIconsUpdate = 0;

/* Swipe container */
static lv_obj_t *swipe_container = nullptr;
static int32_t swipe_start_x = 0;
static int32_t current_offset = 0;
static bool is_dragging = false;
static bool pair_changed = false;
static const int32_t SWIPE_THRESHOLD = 180;

/* ===== State ===== */
static int selectedIndex = -1;
static String pendingPassword = "";
static bool connecting = false;
static unsigned long connectStart = 0;

static unsigned long lastPriceUpdate = 0;
static unsigned long lastClockUpdate = 0;

/* ===== Pairs ===== */
// Dynamic pairs - now only holds favorited coins (max 10)
// PAIR_COUNT and PairData struct are defined earlier for forward declarations

// Dynamic pairs array - populated from favorites (max 10)
PairData pairs[PAIR_COUNT];  // Removed 'static' for forward declaration
int active_pair_count = 0;  // Removed 'static' for forward declaration - Track how many pairs are actually populated
static int current_pair = 0;
static int selected_pair_count = 0;

/* ===== TFs ===== */
static const char* tfOptions[] = {"1m","15m","30m","1h","4h","8h","1d","1w","1M"};
static const int    tfCount    = 9;
static const char*  currentTFStr = "4h";
static int          tf_current_index = 4; // index of "4h"
static int          tf_preview_index = 4; // preview index for encoder scrolling
static bool         tf_menu_visible = false;
static lv_timer_t*  tf_timer = nullptr;
static bool         tf_encoder_mode = false; // true when encoder is controlling TF menu

/* ===== Rotary Quick Menu ===== */
static const char* rotaryMenuOptions[] = {
  "MENU",
  "ALERT",
  "TF",
  "INFO",
  "EDIT",
  "COINS"
};
static const int ROTARY_MENU_COUNT = sizeof(rotaryMenuOptions) / sizeof(rotaryMenuOptions[0]);
static lv_obj_t *rotary_menu_container = nullptr;
static lv_obj_t *rotary_menu_circles[ROTARY_MENU_COUNT] = {nullptr};
static lv_obj_t *rotary_menu_labels[ROTARY_MENU_COUNT] = {nullptr};
static lv_timer_t *rotary_menu_timer = nullptr;
static bool rotary_menu_active = false;
static int rotary_menu_index = 0;
static const uint32_t ROTARY_MENU_TIMEOUT_MS = 3000;  // 3 seconds (reduced from 4)

/* ===== Candle canvas + animation ===== */
static lv_obj_t   *candle_canvas = nullptr;
static lv_color_t *candle_buf    = nullptr;
static int   visible_candles      = 0;
static bool  candle_reveal_active = false;
static lv_timer_t *candle_timer = nullptr;

/* ===== Candle Inspection (hold to view) ===== */
static bool candle_inspection_active = false;
static unsigned long candle_touch_start_time = 0;
static int candle_touch_x = 0;
static int candle_touch_y = 0;
static int candle_selected_index = -1;
static lv_obj_t *candle_info_popup = nullptr;
static lv_obj_t *candle_info_label = nullptr;

/* ===== Coin Indicator Dots ===== */
static lv_obj_t *coin_dots_container = nullptr;
static lv_obj_t *coin_dots[PAIR_COUNT]; // Array to hold individual dot objects
static lv_timer_t *coin_dots_fade_timer = nullptr;
static lv_anim_t coin_dots_fade_anim;

/* ===== Helper Function Implementations (needed early) ===== */

/**
 * @brief Safely deletes a popup and resets encoder focus
 * @param popup_bg Pointer to popup background overlay
 * @param popup_name Name for logging (optional)
 * @note Also resets sleep timer to prevent accidental sleep
 */
static void safeDeletePopup(lv_obj_t*& popup_bg, const char* popup_name) {
  if (popup_bg && lv_obj_is_valid(popup_bg)) {
    // Reset encoder focus
    encoderFocusReset();
    
    // Reset sleep timer to prevent accidental sleep mode
    encoderPressStart = 0;
    
    // Delete the popup
    lv_obj_del(popup_bg);
    popup_bg = nullptr;
    
    Serial.printf("[%s] Closed and cleaned up\n", popup_name);
  }
}

/**
 * @brief Synchronizes favorites array with favoriteCoinSymbols and pairs arrays
 * @details Call this after loading favorites or updating pairs to maintain consistency.
 *          Updates pair_index and has_active_alerts fields in favorites array.
 * @note This provides O(1) lookups instead of O(n) searches
 */
static void syncFavoritesWithPairs() {
  for (int i = 0; i < favoriteCoinCount && i < MAX_FAVORITE_COINS; i++) {
    favorites[i].symbol = favoriteCoinSymbols[i];
    
    // Extract display name
    favorites[i].display_name = favoriteCoinSymbols[i];
    if (favorites[i].display_name.endsWith("USDT")) {
      favorites[i].display_name = favorites[i].display_name.substring(0, favorites[i].display_name.length() - 4);
    }
    
    // Find matching pair index
    favorites[i].pair_index = -1;
    for (int p = 0; p < active_pair_count; p++) {
      if (pairs[p].symbol == favoriteCoinSymbols[i]) {
        favorites[i].pair_index = p;
        break;
      }
    }
    
    // Check for active alerts
    favorites[i].has_active_alerts = false;
    for (int a = 0; a < MAX_TOTAL_ALERTS; a++) {
      if (coin_alerts[a].active && coin_alerts[a].coin_symbol == favoriteCoinSymbols[i]) {
        favorites[i].has_active_alerts = true;
        break;
      }
    }
  }
  
  Serial.printf("[FavoriteSync] Synced %d favorites with pairs and alerts\n", favoriteCoinCount);
}

/**
 * @brief Centralized popup management to track and control all popups
 * @details Prevents multiple popups from being open, provides easy cleanup,
 *          and ensures consistent behavior across all popup types
 */
struct PopupManager {
  enum PopupType {
    NONE,
    ALERTS,
    COINS,
    COIN_INFO,
    ALERT_DELETE_CONFIRM,
    PORTFOLIO_MANAGE,
    CUSTOMIZATION,
    UNFAVORITE_CONFIRM
  };
  
  static PopupType current_popup;
  
  /**
   * @brief Check if any popup is currently open
   * @return true if a popup is open, false otherwise
   */
  static bool isAnyPopupOpen() {
    return (alerts_popup_bg && lv_obj_is_valid(alerts_popup_bg)) ||
           (coins_popup_bg && lv_obj_is_valid(coins_popup_bg)) ||
           (coin_info_popup_bg && lv_obj_is_valid(coin_info_popup_bg)) ||
           (alert_delete_popup && lv_obj_is_valid(alert_delete_popup)) ||
           (portfolio_popup_overlay && lv_obj_is_valid(portfolio_popup_overlay)) ||
           (customization_bg && lv_obj_is_valid(customization_bg)) ||
           (unfavorite_popup && lv_obj_is_valid(unfavorite_popup));
  }
  
  /**
   * @brief Close all open popups
   * @note Useful for cleanup or when switching screens
   */
  static void closeAll() {
    Serial.println("[PopupManager] Closing all popups");
    
    if (alerts_popup_bg) safeDeletePopup(alerts_popup_bg, "Alerts");
    if (coins_popup_bg) {
      safeDeletePopup(coins_popup_bg, "Coins");
      coins_popup = nullptr;
      coins_popup_list = nullptr;
    }
    if (coin_info_popup_bg) {
      safeDeletePopup(coin_info_popup_bg, "CoinInfo");
      coin_info_popup = nullptr;
      coin_info_label = nullptr;
    }
    if (alert_delete_popup && lv_obj_is_valid(alert_delete_popup)) {
      lv_obj_del(alert_delete_popup);
      alert_delete_popup = nullptr;
    }
    if (portfolio_popup_overlay && lv_obj_is_valid(portfolio_popup_overlay)) {
      lv_obj_del(portfolio_popup_overlay);
      portfolio_popup_overlay = nullptr;
      portfolio_popup = nullptr;
    }
    if (customization_bg && lv_obj_is_valid(customization_bg)) {
      lv_obj_add_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
    }
    if (unfavorite_popup && lv_obj_is_valid(unfavorite_popup)) {
      lv_obj_del(unfavorite_popup);
      unfavorite_popup = nullptr;
    }
    
    current_popup = NONE;
  }
  
  /**
   * @brief Close a specific popup by type
   * @param type Type of popup to close
   */
  static void closePopup(PopupType type) {
    switch(type) {
      case ALERTS:
        if (alerts_popup_bg) safeDeletePopup(alerts_popup_bg, "Alerts");
        break;
      case COINS:
        if (coins_popup_bg) {
          safeDeletePopup(coins_popup_bg, "Coins");
          coins_popup = nullptr;
          coins_popup_list = nullptr;
        }
        break;
      case COIN_INFO:
        if (coin_info_popup_bg) {
          safeDeletePopup(coin_info_popup_bg, "CoinInfo");
          coin_info_popup = nullptr;
          coin_info_label = nullptr;
        }
        break;
      case CUSTOMIZATION:
        if (customization_bg && lv_obj_is_valid(customization_bg)) {
          lv_obj_add_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
        }
        break;
      default:
        break;
    }
    
    if (current_popup == type) {
      current_popup = NONE;
    }
  }
  
  /**
   * @brief Register that a popup has been opened
   * @param type Type of popup that was opened
   * @note Automatically closes other popups if one is already open
   */
  static void registerPopup(PopupType type) {
    if (current_popup != NONE && current_popup != type) {
      Serial.printf("[PopupManager] Popup %d already open, closing before opening %d\n", current_popup, type);
      closeAll();
    }
    current_popup = type;
    Serial.printf("[PopupManager] Registered popup type: %d\n", type);
  }
  
  /**
   * @brief Get the currently open popup type
   * @return Current popup type (NONE if no popup is open)
   */
  static PopupType getCurrentPopup() {
    return current_popup;
  }
};

// Initialize static member
PopupManager::PopupType PopupManager::current_popup = PopupManager::NONE;

/* ===== Function Prototypes ===== */
// UI helpers
static void showLogo();
static void showLoadingScreen();
static void formatPriceWithCommas(float price, char* buffer, size_t bufferSize, int pairIndex);
static void getDefaultPriceText(int pairIndex, char* buffer, size_t bufferSize);
static void addCryptoLogo(lv_obj_t *btn, int pairIndex);

// Wi-Fi UI + callbacks
static void createWiFiSignal(lv_obj_t *parent);
static void updateWiFiSignal();
static void ensureStatusIcons(lv_obj_t *parent);
static const lv_img_dsc_t* wifiImgForRssi(int rssi);
static void refresh_btn_cb(lv_event_t * e);
static void wifi_btn_cb(lv_event_t * e);
static void cancel_btn_cb(lv_event_t * e);
static void connect_btn_cb(lv_event_t * e);

// Portfolio helpers
static void loadPortfolioCoins();
static void savePortfolioCoins();
static bool isCoinInPortfolio(const String& symbol);
static void addCoinToPortfolio(const String& symbol, const String& baseCoin);
static void removePortfolioCoin(int index);
static void ensurePortfolioPrices(bool force);
static bool fetchPortfolioPrice(int index, bool force);
static void updatePortfolioTotal();
static void createPortfolioPage();
static void refreshPortfolioList();
static void createPortfolioManagePage();
static void refreshPortfolioManageList();
static void showPortfolioCoinPopup(int index);
static void hidePortfolioPopup();
static void showPortfolioAmountKeyboard();
static void hidePortfolioAmountKeyboard(bool save_value);
static void updatePortfolioPopupContent();
static void portfolio_btn_cb(lv_event_t * e);
static void portfolio_manage_btn_cb(lv_event_t * e);
static void portfolio_back_btn_cb(lv_event_t * e);
static void portfolio_manage_back_btn_cb(lv_event_t * e);
static bool fetchBinanceCoinsForPortfolio(const String& query);
static void updatePortfolioEmptyState();
static void portfolio_amount_btn_cb(lv_event_t * e);
static void portfolio_remove_btn_cb(lv_event_t * e);

// Alerts panel
static void showAlertBellIcon();
static void hideAlertBellIcon();
static bool hasActiveAlerts();
static void refreshAlertBellIcon();

// Encoder focus helpers
static void encoderFocusBegin(lv_obj_t *screen);
static void encoderFocusAdd(lv_obj_t *target, lv_obj_t *label);
static void encoderFocusCommit(int initial_index);
static void encoderFocusDisable();
static void encoderFocusMove(int delta);
static void encoderFocusActivate();
static bool encoderFocusIsActive();

// Battery functions DISABLED - removed per user request
int __attribute__((weak)) getBatteryPercent() {
  return -1; // Battery disabled
}

bool __attribute__((weak)) isCharging() {
  return false; // Battery disabled
}
/* ===== Battery UI (Image steps when available, else text) ===== */
static void createBatteryLabel(lv_obj_t *parent) {
  if (!parent || !lv_obj_is_valid(parent)) return;
#ifdef HAVE_BATTERY_IMAGES
  // Persistent battery icon - matches WiFi exactly
  static int lastBatteryIconClass = -1; // Local static like WiFi's lastWifiBars
  
  // Create or reparent battery icon (like WiFi does)
  if (!battery_img || !lv_obj_is_valid(battery_img)) {
    battery_img = lv_img_create(parent);
    lastBatteryIconClass = -1; // force initial icon set
  } else if (lv_obj_get_parent(battery_img) != parent) {
    lv_obj_set_parent(battery_img, parent);
  }
  
  // Position ONLY on create/reparent (like WiFi - line 1315)
  static lv_obj_t *last_parent = nullptr;
  if (last_parent != parent) {
    // First time or parent changed - position it
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      lv_obj_align_to(battery_img, wifi_signal, LV_ALIGN_OUT_LEFT_MID, -BATTERY_GAP_X, 2);
  } else {
      lv_obj_align(battery_img, LV_ALIGN_TOP_RIGHT, -70, 7);
    }
    last_parent = parent;
  }
  
  // Visibility check (like WiFi does for customization)
  lv_obj_clear_flag(battery_img, LV_OBJ_FLAG_HIDDEN);
  
  // Get battery percentage and determine icon class
  int pct = getBatteryPercent();
  int cls = 10;
  if (pct >= 100) cls = 100;
  else if (pct >= 75) cls = 75;
  else if (pct >= 50) cls = 50;
  else if (pct >= 25) cls = 25;
  else cls = 10;

  // Only update icon SOURCE if battery class changed (like WiFi's if (barsIdx != lastWifiBars))
  if (cls != lastBatteryIconClass) {
    const lv_img_dsc_t *img = nullptr;
    switch (cls) {
      case 100: img = &Battery100; break;
      case 75:  img = &Battery75;  break;
      case 50:  img = &Battery50;  break;
      case 25:  img = &Battery25;  break;
      default:  img = &Battery10;  break;
    }
    if (img) {
      lv_img_set_src(battery_img, img);
      
      // Match battery height to WiFi icon height (only when icon changes)
    int target_h = 20;
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      int wifi_h = lv_obj_get_height(wifi_signal);
      if (wifi_h > 0) target_h = wifi_h;
    }
      int img_h = img->header.h;
    if (target_h > 0 && img_h > 0) {
      int32_t zoom = (int32_t)((target_h * 256) / img_h);
      if (zoom < 16) zoom = 16;
      if (zoom > 256) zoom = 256;
      lv_img_set_zoom(battery_img, zoom);
    }
  }
    lastBatteryIconClass = cls; // Update local static (like lastWifiBars)
  }
#else
  // Text fallback
  if (!battery_label || !lv_obj_is_valid(battery_label)) {
    battery_label = lv_label_create(parent);
    lv_obj_set_style_text_font(battery_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(battery_label, COLOR_WHITE, 0);
  } else if (lv_obj_get_parent(battery_label) != parent) {
    lv_obj_set_parent(battery_label, parent);
  }
  
  lv_obj_clear_flag(battery_label, LV_OBJ_FLAG_HIDDEN);
  lv_obj_align(battery_label, LV_ALIGN_TOP_RIGHT, -70, 8);
  
  int pct = getBatteryPercent();
  if (pct >= 0 && pct <= 100) {
    static char buf[8];
    snprintf(buf, sizeof(buf), "%d%%", pct);
    lv_label_set_text(battery_label, buf);
  } else {
    lv_label_set_text(battery_label, "--%");
  }
#endif
}

static void updateBatteryLabel() {
  // Just call createBatteryLabel with current screen - it handles everything
  // This matches how WiFi works (updateWiFiSignal calls createWiFiSignal)
  lv_obj_t *current_screen = lv_scr_act();
  createBatteryLabel(current_screen);
}

static void positionBatteryIcon() {
  // Legacy function - positioning is now handled in createBatteryLabel
  // Keeping for compatibility but it does nothing
}

// Clock
static void updateClock();
static void syncTimeWithAPI();
// Wi-Fi persistence helpers - Multi-network support (up to 10 networks)
#define MAX_SAVED_NETWORKS 10

static void wifi_save_credentials(const String& ssid, const String& password);
static bool wifi_load_credentials(String& ssid, String& password); // Legacy - loads first network
static bool wifi_load_network(int index, String& ssid, String& password);
static int wifi_get_saved_count();
static bool wifi_is_network_saved(const String& ssid);
static int wifi_find_network_index(const String& ssid);
static void wifi_forget_credentials(); // Legacy - forgets all
static void wifi_forget_network(const String& ssid);
static void wifi_try_autoconnect();
static void show_wifi_info_popup(const String& ssid = "");
static void wifi_info_forget_cb(lv_event_t * e);
static void wifi_info_close_cb(lv_event_t * e);

static void wifi_save_credentials(const String& ssid, const String& password) {
  // Check if network already exists
  int existingIdx = wifi_find_network_index(ssid);
  
  if (existingIdx >= 0) {
    // Update existing network
    String key_pass = "pass" + String(existingIdx);
    wifiPrefs.putString(key_pass.c_str(), password);
    Serial.printf("Updated saved Wi-Fi: %s at index %d\n", ssid.c_str(), existingIdx);
    return;
  }
  
  // Find empty slot or oldest network to replace
  int count = wifiPrefs.getInt("count", 0);
  int saveIdx = count;
  
  if (count >= MAX_SAVED_NETWORKS) {
    // Replace the last network (oldest)
    saveIdx = MAX_SAVED_NETWORKS - 1;
  } else {
    count++;
    wifiPrefs.putInt("count", count);
  }
  
  String key_ssid = "ssid" + String(saveIdx);
  String key_pass = "pass" + String(saveIdx);
  
  wifiPrefs.putString(key_ssid.c_str(), ssid);
  wifiPrefs.putString(key_pass.c_str(), password);
  Serial.printf("Saved Wi-Fi: %s at index %d\n", ssid.c_str(), saveIdx);
}

static bool wifi_load_credentials(String& ssid, String& password) {
  // Legacy function - loads first network for compatibility
  return wifi_load_network(0, ssid, password);
}

static bool wifi_load_network(int index, String& ssid, String& password) {
  if (index < 0 || index >= MAX_SAVED_NETWORKS) return false;
  
  String key_ssid = "ssid" + String(index);
  String key_pass = "pass" + String(index);
  
  ssid = wifiPrefs.getString(key_ssid.c_str(), "");
  password = wifiPrefs.getString(key_pass.c_str(), "");
  
  return ssid.length() > 0;
}

static int wifi_get_saved_count() {
  return wifiPrefs.getInt("count", 0);
}
static bool wifi_is_network_saved(const String& ssid) {
  return wifi_find_network_index(ssid) >= 0;
}
static int wifi_find_network_index(const String& ssid) {
  int count = wifi_get_saved_count();
  for (int i = 0; i < count; i++) {
    String key_ssid = "ssid" + String(i);
    String savedSsid = wifiPrefs.getString(key_ssid.c_str(), "");
    if (savedSsid == ssid) {
      return i;
    }
  }
  return -1;
}

static void wifi_forget_credentials() {
  // Legacy function - clears all networks
  int count = wifi_get_saved_count();
  for (int i = 0; i < count; i++) {
    String key_ssid = "ssid" + String(i);
    String key_pass = "pass" + String(i);
    wifiPrefs.remove(key_ssid.c_str());
    wifiPrefs.remove(key_pass.c_str());
  }
  wifiPrefs.putInt("count", 0);
  Serial.println("Forgot all saved Wi-Fi credentials");
}

static void wifi_forget_network(const String& ssid) {
  int idx = wifi_find_network_index(ssid);
  if (idx < 0) return;
  
  int count = wifi_get_saved_count();
  
  // Shift all networks after this one down
  for (int i = idx; i < count - 1; i++) {
    String src_ssid_key = "ssid" + String(i + 1);
    String src_pass_key = "pass" + String(i + 1);
    String dst_ssid_key = "ssid" + String(i);
    String dst_pass_key = "pass" + String(i);
    
    String ssid_val = wifiPrefs.getString(src_ssid_key.c_str(), "");
    String pass_val = wifiPrefs.getString(src_pass_key.c_str(), "");
    
    wifiPrefs.putString(dst_ssid_key.c_str(), ssid_val);
    wifiPrefs.putString(dst_pass_key.c_str(), pass_val);
  }
  
  // Remove the last entry
  String last_ssid_key = "ssid" + String(count - 1);
  String last_pass_key = "pass" + String(count - 1);
  wifiPrefs.remove(last_ssid_key.c_str());
  wifiPrefs.remove(last_pass_key.c_str());
  
  wifiPrefs.putInt("count", count - 1);
  Serial.printf("Forgot Wi-Fi network: %s\n", ssid.c_str());
}

static void wifi_migrate_old_credentials() {
  // Check if we have old-style credentials (single "ssid" and "pass" keys)
  String oldSsid = wifiPrefs.getString("ssid", "");
  String oldPass = wifiPrefs.getString("pass", "");
  
  if (oldSsid.length() > 0 && wifi_get_saved_count() == 0) {
    // Migrate old credential to new format
    Serial.println("Migrating old WiFi credential to new multi-network format...");
    wifiPrefs.putString("ssid0", oldSsid);
    wifiPrefs.putString("pass0", oldPass);
    wifiPrefs.putInt("count", 1);
    
    // Remove old keys
    wifiPrefs.remove("ssid");
    wifiPrefs.remove("pass");
    
    Serial.printf("Migrated network: %s\n", oldSsid.c_str());
  }
}
static void wifi_try_autoconnect() {
  // First, migrate any old credentials
  wifi_migrate_old_credentials();
  
  // Get saved networks
  int count = wifi_get_saved_count();
  Serial.printf("Auto-connect: Found %d saved network(s)\n", count);
  
  if (count == 0) {
    Serial.println("Auto-connect: No saved networks");
    return;
  }
  
  // Quick scan to see which networks are available (faster boot)
  Serial.println("Auto-connect: Scanning for available networks...");
  int networksFound = WiFi.scanNetworks(false, false); // Non-async, show hidden
  
  if (networksFound <= 0) {
    Serial.println("Auto-connect: No networks found in scan");
    WiFi.scanDelete();
    return;
  }
  
  Serial.printf("Auto-connect: Found %d networks in range\n", networksFound);
  
  // Try each saved network, but only if it's visible in the scan
  for (int i = 0; i < count; i++) {
    String ssid, pass;
    if (wifi_load_network(i, ssid, pass)) {
      // Check if this network is in the scan results
      bool networkVisible = false;
      for (int j = 0; j < networksFound; j++) {
        if (WiFi.SSID(j) == ssid) {
          networkVisible = true;
          break;
        }
      }
      
      if (!networkVisible) {
        Serial.printf("Auto-connect: %s not in range, skipping\n", ssid.c_str());
        continue;
      }
      
      Serial.printf("Auto-connecting to %s (network %d/%d)...\n", ssid.c_str(), i+1, count);
      WiFi.begin(ssid.c_str(), pass.c_str());
      
      // Wait a bit to see if connection succeeds
      unsigned long startTime = millis();
      while (millis() - startTime < 5000) { // Wait up to 5 seconds per network
        if (WiFi.status() == WL_CONNECTED) {
          Serial.printf("Successfully connected to %s\n", ssid.c_str());
          WiFi.scanDelete(); // Clean up scan results
          return;
        }
        delay(100);
      }
      
      Serial.printf("Failed to connect to %s, trying next network...\n", ssid.c_str());
      WiFi.disconnect(true, false); // Fully disconnect but preserve credentials
      delay(100); // Give WiFi time to fully disconnect
    }
  }
  
  WiFi.scanDelete(); // Clean up scan results
  Serial.println("Auto-connect: No saved networks could connect");
  
  // CRITICAL FIX: Properly reset WiFi state when no networks connect
  // This ensures WiFi is ready for scanning when user opens settings
  // Use TRUE for first param to fully disconnect, FALSE for second to preserve credentials
  WiFi.disconnect(true, false); // Fully disconnect but DON'T erase stored credentials
  
  // Wait for WiFi to fully disconnect
  unsigned long disconnectStart = millis();
  while (WiFi.status() != WL_DISCONNECTED && millis() - disconnectStart < 1000) {
    delay(50);
  }
  
  WiFi.mode(WIFI_STA); // Ensure we're in station mode
  delay(100); // Let mode stabilize
  Serial.println("WiFi state reset and ready for scanning");
}

static void wifi_info_forget_cb(lv_event_t * e) {
  // Forget the network shown in the popup
  if (wifi_info_current_ssid.length() > 0) {
    wifi_forget_network(wifi_info_current_ssid);
    Serial.printf("Forgetting network: %s\n", wifi_info_current_ssid.c_str());
  }
  
  // Only disconnect if it's the currently connected network
  if (WiFi.status() == WL_CONNECTED && WiFi.SSID() == wifi_info_current_ssid) {
    WiFi.disconnect(true, true);
  }
  
  if (wifi_info_popup && lv_obj_is_valid(wifi_info_popup)) {
    lv_obj_del(wifi_info_popup);
    wifi_info_popup = nullptr;
  }
  
  wifi_info_current_ssid = "";
}

static void wifi_info_close_cb(lv_event_t * e) {
  if (wifi_info_popup && lv_obj_is_valid(wifi_info_popup)) {
    lv_obj_del(wifi_info_popup);
    wifi_info_popup = nullptr;
  }
}

static void show_wifi_info_popup(const String& ssid) {
  if (wifi_info_popup && lv_obj_is_valid(wifi_info_popup)) {
    lv_obj_del(wifi_info_popup);
    wifi_info_popup = nullptr;
  }
  
  // Use passed SSID or fall back to current connected network
  wifi_info_current_ssid = (ssid.length() > 0) ? ssid : WiFi.SSID();
  
  lv_obj_t *parent = lv_scr_act();
  wifi_info_popup = lv_obj_create(parent);
  lv_obj_set_size(wifi_info_popup, 420, 200);
  lv_obj_align(wifi_info_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(wifi_info_popup, lv_color_make(15,15,15), 0);
  lv_obj_set_style_radius(wifi_info_popup, 14, 0);
  lv_obj_set_style_border_width(wifi_info_popup, 0, 0);

  wifi_info_label = lv_label_create(wifi_info_popup);
  lv_label_set_text(wifi_info_label, wifi_info_current_ssid.c_str());
  lv_obj_set_style_text_font(wifi_info_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(wifi_info_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_align(wifi_info_label, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_align(wifi_info_label, LV_ALIGN_TOP_MID, 0, 20);

  // Close button (left side)
  wifi_info_close_btn = lv_btn_create(wifi_info_popup);
  lv_obj_set_size(wifi_info_close_btn, 160, 44);
  lv_obj_align(wifi_info_close_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(wifi_info_close_btn, COLOR_WHITE, 0); // White background
  lv_obj_set_style_radius(wifi_info_close_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(wifi_info_close_btn, wifi_info_close_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *close_label = lv_label_create(wifi_info_close_btn);
  lv_label_set_text(close_label, "Close");
  lv_obj_set_style_text_color(close_label, COLOR_BLACK, 0);
  lv_obj_center(close_label);

  // Forget button (right side)
  wifi_info_forget_btn = lv_btn_create(wifi_info_popup);
  lv_obj_set_size(wifi_info_forget_btn, 160, 44);
  lv_obj_align(wifi_info_forget_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -20);
  lv_obj_set_style_bg_color(wifi_info_forget_btn, COLOR_RED, 0); // Red background
  lv_obj_set_style_radius(wifi_info_forget_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(wifi_info_forget_btn, wifi_info_forget_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *forget_label = lv_label_create(wifi_info_forget_btn);
  lv_label_set_text(forget_label, "Forget Wi-Fi");
  lv_obj_set_style_text_color(forget_label, COLOR_BLACK, 0);
  lv_obj_center(forget_label);
}

// Swipe
static void swipe_event_cb(lv_event_t *e);
static void fadeInAfterDataLoad();

// TF selector
static void setupTFSelector(lv_obj_t *parent);
static void tf_main_btn_cb(lv_event_t *e);
static void tf_option_cb(lv_event_t *e);
static void tf_menu_event_cb(lv_event_t *e);
static void tf_hide_timer_cb(lv_timer_t *t);
static void reset_tf_timer();

// Rotary quick menu
static void ensureRotaryMenu();
static void updateRotaryMenuLayout();
static void updateRotaryMenuHighlight();
static void showRotaryMenu();
static void hideRotaryMenu();
static void reset_rotary_menu_timer();
static void rotary_menu_timer_cb(lv_timer_t *t);
static void rotaryMenuStep(bool clockwise);
static void activateRotaryMenuSelection();
static void openTFMenuFromRotary();
static void rotary_menu_set_opacity(lv_obj_t *obj, int32_t v);

// Candles
static void setupCandles(lv_obj_t *parent);
static void drawCandles();
static void revealCandleStep(lv_timer_t *t);
static void startCandleAnimation();
static void candle_inspection_event_cb(lv_event_t *e);

// Coin indicator dots
static void createCoinDots(lv_obj_t *parent);
static void showCoinDots();
static void updateCoinDots();
static void coin_dots_fade_timer_cb(lv_timer_t *t);
static void coin_dots_fade_anim_cb(void *var, int32_t v);

// Network (REST + WS)
static void fetchHistory(const char* tf);
static void fetch24hTicker(int pairIndex);
static void fetchAll24hTickers();  // Batch fetch all coins at once
static void wsKlineEvent(WStype_t type, uint8_t * payload, size_t length);
static void startKlineWS(const char* tf);
static void addCandle(float o, float h, float l, float c, float v, unsigned long long t, bool closed);

// Homepage
static void createHomepage();
static void favorites_btn_cb(lv_event_t * e);
static void utilities_btn_cb(lv_event_t * e);
static void settings_btn_cb(lv_event_t * e);
// Utilities page
static void createUtilitiesPage();
static void setupUtilitiesFocus();
static void utilities_back_btn_cb(lv_event_t * e);
// Fear & Greed Index page
static void createFearGreedPage();
static void setupFearGreedFocus();
static void fear_greed_btn_cb(lv_event_t * e);
static void fear_greed_back_btn_cb(lv_event_t * e);
static void fetchFearGreedData();
static void updateFearGreedGauge();
static String getFearGreedClassification(int value);
// Favorites page
static void createFavoritesPage();
static void back_btn_cb(lv_event_t * e);
static void favorite_pair_cb(lv_event_t * e);
static void startCryptoDisplay();
static void updateSelectedPairs();
// Coin search & favorites system
static void loadFavoriteCoins();
static void saveFavoriteCoins();
static bool isCoinFavorited(const String& symbol);
static void toggleCoinFavorite(const String& symbol, const String& baseCoin);
static bool fetchBinanceCoins(const String& query);
static int filterSearchResults(const String& query, CoinSearchInfo* results, int maxResults);
static void createSearchFavoritesSelectionPage();
static void createCoinSearchPage();
static void createNewFavoritesPage();
static void refreshCoinSearchList();
static void refreshNewFavoritesList();
static void createCryptoLoadingScreen();
static void updateCryptoLoadingProgress(int progress, const char* status);
static void cryptoLoadingStepTimer(lv_timer_t *timer);
// Settings page
static void createSettingsPage();
static void settings_back_btn_cb(lv_event_t * e);
static void wifi_settings_btn_cb(lv_event_t * e);
static void brightness_settings_btn_cb(lv_event_t * e);
static void about_settings_btn_cb(lv_event_t * e);
static void createAboutPage();
static void about_back_btn_cb(lv_event_t * e);
static void about_reboot_btn_cb(lv_event_t * e);
// ===== OTA UPDATE FUNCTION DECLARATIONS =====
static void createOTAUpdatePage();
static void ota_back_btn_cb(lv_event_t * e);
static void ota_check_btn_cb(lv_event_t * e);
static void ota_update_btn_cb(lv_event_t * e);
static void checkForUpdates();
static void performOTAUpdate();
static void startFakeProgressThenInstall();
static void performOTAInstallStreaming();
static void updateOTAProgress(int progress);
static void showOTAStatus(const String& status);
static void ota_settings_btn_cb(lv_event_t * e);
static void otaUpdateProgressCallback(size_t current, size_t total);
static void showOTAWarningPopup();
static void ota_warning_cancel_cb(lv_event_t * e);
static void ota_warning_continue_cb(lv_event_t * e);
static void createOTAProgressScreen();
static void updateOTAProgressModern(int progress);

// Wi-Fi settings page
static void createWiFiSettingsPage();
static void wifi_settings_back_btn_cb(lv_event_t * e);
static void wifi_settings_refresh_btn_cb(lv_event_t * e);
static void wifi_settings_network_btn_cb(lv_event_t * e);
static void wifi_settings_cancel_btn_cb(lv_event_t * e);
static void wifi_settings_connect_btn_cb(lv_event_t * e);
static void createWiFiConnectingScreen();
static void wifi_connecting_timer_cb(lv_timer_t *t);
static void hideWiFiConnectingScreen();

// Display & Brightness settings page
static void createBrightnessPage();
static void brightness_back_btn_cb(lv_event_t * e);
static void brightness_slider_cb(lv_event_t * e);

// Control Panel functions
static void createControlPanel();
static void showControlPanel();
static void hideControlPanel();
static void control_panel_brightness_cb(lv_event_t * e);
static void control_panel_menu_cb(lv_event_t * e);
static void control_panel_customization_cb(lv_event_t * e);
static void control_panel_alert_cb(lv_event_t * e);
static void control_panel_coin_info_cb(lv_event_t * e);
static void createAlertPopup();
static void alert_create_btn_cb(lv_event_t * e);
static void alert_back_btn_cb(lv_event_t * e);
static void updateAlertPriceDisplay();
static void buildAlertPriceString();
static void changeAlertDigit(bool is_clockwise);
static void nextAlertDigit();
static void initGlobalControlPanel();
static void control_panel_drag_event_cb(lv_event_t * e);
static void control_panel_anim_exec_cb(void *var, int32_t v);
static void control_panel_anim_ready_cb(lv_anim_t *a);

// Alert system functions
static void loadAlerts();
static void saveAlerts();
static void addAlert(float price);
static void removeAlert(int index);
static void checkAlertTriggers();
static void showAlertBellIcon();
static void hideAlertBellIcon();
static bool hasActiveAlerts();
static void refreshAlertBellIcon();
static void createAlertsPopup();
static void showAlertsPopup();
static void hideAlertsPopup();
static void alerts_popup_back_cb(lv_event_t * e);
static void alert_item_clicked_cb(lv_event_t * e);
static void alert_bell_clicked_cb(lv_event_t * e);
static void createAlertDeleteConfirmation(int alert_index);
static void alert_delete_confirm_cb(lv_event_t * e);
static void alert_delete_cancel_cb(lv_event_t * e);
static void flashAlertBorder(bool is_upward);
static void dismissAlertFlash(lv_event_t * e);

// Customization functions
static void createCustomizationScreen();
static void showCustomizationScreen();
static void hideCustomizationScreen();
static void customization_back_cb(lv_event_t * e);
static void customization_toggle_cb(lv_event_t * e);
static lv_obj_t* createIOSToggle(lv_obj_t *parent, const char *label_text, bool *state_var, int y_pos);
static void saveCustomizationSettings();
static void loadCustomizationSettings();

// Coin Info functions
static void showCoinInfoIcon();
static void hideCoinInfoIcon();
static void coin_info_clicked_cb(lv_event_t * e);
static void showCoinInfoPopup();
static void hideCoinInfoPopup();
static void fetchCoinStats(const String& symbol);
static bool getCachedCoinInfo(const String& symbol, String& cachedData);
static void cacheCoinInfo(const String& symbol, const String& data);
static void updateCoinInfoPopupLayout();

// Crypto loading logo functions
static void showCryptoLoadingLogo(int pairIndex);
static void hideCryptoLoadingLogo();
static void crypto_loading_fade_anim_cb(void *var, int32_t v);
static void crypto_loading_timer_cb(lv_timer_t *timer);

/* ===== Splash ===== */
static void showLogo() {
  // Create a black background screen
  lv_obj_t *logo_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(logo_screen, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(logo_screen, LV_OPA_COVER, 0);
  lv_obj_set_style_border_width(logo_screen, 0, 0);
  lv_obj_set_style_radius(logo_screen, 0, 0);
  lv_obj_set_style_pad_all(logo_screen, 0, 0);
  lv_obj_set_scrollbar_mode(logo_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(logo_screen, LV_OBJ_FLAG_SCROLLABLE);
  // Use exact display resolution to avoid 1px artifacts on edges
  lv_obj_set_size(logo_screen, lv_disp_get_hor_res(NULL), lv_disp_get_ver_res(NULL));
  lv_scr_load(logo_screen);
  
  lv_obj_t *img = lv_img_create(logo_screen);
  lv_img_set_src(img, &LumenLogo);
  // Don't set size - use the actual image size
  lv_obj_align(img, LV_ALIGN_CENTER, 0, 0); // Center alignment
  lv_timer_handler();
  delay(3000); // Show for 3 seconds
}

/* ===== Loading Screen ===== */
static void showLoadingScreen() {
  lv_obj_t *loading_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(loading_screen, COLOR_BLACK, 0);
  lv_scr_load(loading_screen);

  lv_obj_t *loading_label = lv_label_create(loading_screen);
  lv_label_set_text(loading_label, "Loading...");
  lv_obj_set_style_text_font(loading_label, &poppins_regular_32, 0);
  lv_obj_set_style_text_color(loading_label, COLOR_GREEN, 0);
  lv_obj_center(loading_label);

  for (int i = 0; i < 10; i++) {
    lv_timer_handler();
    delay(100);
  }
}
/* ===== Price Formatting (dynamic decimal places based on coin symbol) ===== */
static int getDecimalPlaces(int pairIndex) {
  if (pairIndex < 0 || pairIndex >= PAIR_COUNT) return 2;
  
  String symbol = pairs[pairIndex].display_name;
  symbol.toUpperCase();
  
  // Match common coins to their Binance decimal places
  if (symbol == "BTC" || symbol == "ETH" || symbol == "BNB" || symbol == "BCH" || 
      symbol == "LTC" || symbol == "AVAX" || symbol == "SOL" || symbol == "AAVE" || 
      symbol == "EGLD" || symbol == "ZEC" || symbol == "COMP" || symbol == "INJ") {
    return 2;  // High/medium value coins
  }
  else if (symbol == "MKR" || symbol == "YFI") {
    return 1;  // Very high value coins
  }
  else if (symbol == "LINK" || symbol == "DOT" || symbol == "UNI" || symbol == "ATOM" || 
           symbol == "ICP" || symbol == "FIL" || symbol == "APT" || symbol == "NEAR" || 
           symbol == "OP" || symbol == "LDO" || symbol == "RUNE" || symbol == "SNX" || 
           symbol == "AXS") {
    return 3;  // Mid-range coins $1-$50
  }
  else if (symbol == "ADA" || symbol == "XRP" || symbol == "SUI" || symbol == "MATIC" || 
           symbol == "ARB" || symbol == "STX" || symbol == "IMX" || symbol == "SAND" || 
           symbol == "MANA" || symbol == "SUSHI" || symbol == "CRV" || symbol == "EOS" || 
           symbol == "XTZ" || symbol == "THETA" || symbol == "FTM" || symbol == "FLOW" || 
           symbol == "ALGO") {
    return 4;  // Low value coins $0.10-$2
  }
  else if (symbol == "DOGE" || symbol == "HBAR" || symbol == "XLM" || symbol == "VET" || 
           symbol == "GRT") {
    return 5;  // Very low value coins $0.01-$0.50
  }
  else if (symbol == "SHIB" || symbol == "PEPE" || symbol == "FLOKI" || symbol == "BONK") {
    return 8;  // Micro-cap coins with very low prices
  }
  
  // Smart default based on current price if available
  if (pairs[pairIndex].last_price > 0) {
    float price = pairs[pairIndex].last_price;
    if (price >= 1000) return 2;        // $1000+  2 decimals
    else if (price >= 100) return 2;    // $100-$999  2 decimals  
    else if (price >= 10) return 3;     // $10-$99  3 decimals
    else if (price >= 1) return 4;      // $1-$9  4 decimals
    else if (price >= 0.01) return 5;   // $0.01-$0.99  5 decimals
    else return 8;                       // < $0.01  8 decimals
  }
  
  return 4;  // Safe default
}
static void formatPriceWithCommas(float price, char* buffer, size_t bufferSize, int pairIndex) {
  int decimals = getDecimalPlaces(pairIndex);
  
      int wholePart = (int)price;
  float fractionalPart = price - wholePart;
  
  // Build the fractional part string
  char fracStr[16] = "";
  if (decimals > 0) {
    int fracValue = (int)(fractionalPart * pow(10, decimals) + 0.5); // Round properly
    snprintf(fracStr, sizeof(fracStr), ".%0*d", decimals, fracValue);
  }
  
  // Add comma formatting based on price range
  if (wholePart >= 1000000) {
    // 1,000,000+ (e.g., 1,234,567)
    int millions = wholePart / 1000000;
    int thousands = (wholePart / 1000) % 1000;
    int remainder = wholePart % 1000;
    snprintf(buffer, bufferSize, "%d,%03d,%03d%s", millions, thousands, remainder, fracStr);
  }
  else if (wholePart >= 1000) {
    // 1,000 - 999,999 (e.g., 1,234 or 123,456)
      int thousands = wholePart / 1000;
      int remainder = wholePart % 1000;
    snprintf(buffer, bufferSize, "%d,%03d%s", thousands, remainder, fracStr);
  }
  else {
    // 0 - 999 (no commas)
    snprintf(buffer, bufferSize, "%d%s", wholePart, fracStr);
  }
}

static void getDefaultPriceText(int pairIndex, char* buffer, size_t bufferSize) {
  int decimals = getDecimalPlaces(pairIndex);
  snprintf(buffer, bufferSize, "0.%0*d", decimals, 0);
}
/* ===== Wi-Fi Signal ===== */
static void createWiFiSignal(lv_obj_t *parent) {
  if (!parent || !lv_obj_is_valid(parent)) {
    Serial.println("Error: Invalid parent for WiFi signal creation");
    return;
  }
  
  // BUG FIX: Only show WiFi symbol if connected
  bool is_connected = (WiFi.status() == WL_CONNECTED);
  
  if (!is_connected) {
    // Hide WiFi symbols if not connected
    if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
      lv_obj_add_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
    }
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      lv_obj_add_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
    }
    return; // Exit early if not connected
  }
  
  // Create background WiFi symbol (always 3 bars at 20% opacity)
  if (!wifi_signal_bg || !lv_obj_is_valid(wifi_signal_bg)) {
    wifi_signal_bg = lv_img_create(parent);
    lv_img_set_src(wifi_signal_bg, &Wifi3bar); // Always 3 bars
    lv_obj_set_style_opa(wifi_signal_bg, LV_OPA_20, 0); // 20% opacity
  } else if (lv_obj_get_parent(wifi_signal_bg) != parent) {
    lv_obj_set_parent(wifi_signal_bg, parent);
  }
  lv_obj_align(wifi_signal_bg, LV_ALIGN_TOP_RIGHT, -10, 5);
  lv_obj_clear_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
  
  // Ensure a persistent WiFi icon exists and is positioned (foreground - actual signal strength)
  static int lastWifiBars = -1;
  if (!wifi_signal || !lv_obj_is_valid(wifi_signal)) {
    wifi_signal = lv_img_create(parent);
    lastWifiBars = -1; // force initial set
  } else if (lv_obj_get_parent(wifi_signal) != parent) {
    lv_obj_set_parent(wifi_signal, parent);
  }
  lv_obj_align(wifi_signal, LV_ALIGN_TOP_RIGHT, -10, 5);
  
  bool isCryptoMain = false;
  if (swipe_container && lv_obj_is_valid(swipe_container) && parent == swipe_container) {
    isCryptoMain = true;
  } else if (parent == crypto_display_screen) {
    isCryptoMain = true;
  }
  
  if (isCryptoMain) {
    if (!show_wifi) {
      if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
        lv_obj_add_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
      }
      if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
        lv_obj_add_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
      }
    } else {
      if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
        lv_obj_clear_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
      }
      if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
        lv_obj_clear_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
      }
    }
  } else {
    if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
      lv_obj_clear_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
    }
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      lv_obj_clear_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
    }
  }
  // Update current RSSI image (show signal strength) only if changed
  int barsIdx = 0; // 0,1,2 represent 1,2,3 bars
  if (parent != ota_progress_screen) {
    int rssi = WiFi.RSSI();
    barsIdx = (rssi >= -60) ? 2 : (rssi >= -75 ? 1 : 0);
  }
  if (barsIdx != lastWifiBars) {
    const lv_img_dsc_t* bar = (barsIdx == 2) ? &Wifi3bar : (barsIdx == 1) ? &Wifi2bar : &Wifi1bar;
    lv_img_set_src(wifi_signal, bar);
    lastWifiBars = barsIdx;
  }
}

static void updateWiFiSignal() {
  lv_obj_t *current_screen = lv_scr_act();
  if (!current_screen || current_screen == ota_progress_screen) return;
  
  lv_obj_t *target_parent = current_screen;
  if (current_screen == crypto_display_screen && swipe_container && lv_obj_is_valid(swipe_container)) {
    target_parent = swipe_container;
  }
  
  // Ensure exists on current screen (or swipe container) and refresh bar
  createWiFiSignal(target_parent);
  if (WiFi.status() == WL_CONNECTED && wifi_signal && lv_obj_is_valid(wifi_signal)) {
    const lv_img_dsc_t* bar = wifiImgForRssi(WiFi.RSSI());
    if (bar) lv_img_set_src(wifi_signal, bar);
  }
}

static const lv_img_dsc_t* wifiImgForRssi(int rssi) {
  // Simple 3-bar mapping
  if (rssi >= -60) return &Wifi3bar;
  if (rssi >= -75) return &Wifi2bar;
  return &Wifi1bar;
}

static void ensureStatusIcons(lv_obj_t *parent) {
  if (!parent || !lv_obj_is_valid(parent)) return;
  // WiFi only - battery disabled
  if (parent == crypto_display_screen && swipe_container && lv_obj_is_valid(swipe_container)) {
    createWiFiSignal(swipe_container);
  } else {
    createWiFiSignal(parent);
  }
  if ((parent == crypto_display_screen || parent == swipe_container) && lv_scr_act() == crypto_display_screen) {
    if (show_coin_info) {
      showCoinInfoIcon();
    } else {
      hideCoinInfoIcon();
    }
  }
  // createBatteryLabel(parent); // DISABLED
}

/* ===== Wi-Fi UI Callbacks ===== */
static void refresh_btn_cb(lv_event_t * e) {
  int n = WiFi.scanNetworks();
  lv_obj_clean(wifi_list);

  if (n <= 0) {
    lv_obj_t *btn = lv_list_add_btn(wifi_list, NULL, "No networks found");
    lv_obj_set_style_bg_color(btn, COLOR_BLACK, 0);
    lv_obj_set_style_text_color(btn, COLOR_WHITE, 0);
    return;
  }

  int limit = (n > 6) ? 6 : n;
  for (int i = 0; i < limit; i++) {
    String ssid = WiFi.SSID(i);
    lv_obj_t *btn = lv_list_add_btn(wifi_list, NULL, ssid.c_str());
    lv_obj_set_style_bg_color(btn, COLOR_BLACK, 0);
    lv_obj_set_style_text_color(btn, COLOR_WHITE, 0);

    lv_obj_add_event_cb(btn, [](lv_event_t* ev) {
      int idx = (int)(intptr_t)lv_event_get_user_data(ev);
      if (idx < 0) return;
      String ssidSel = WiFi.SSID(idx);
      // If this is the currently connected SSID (or saved), show info popup instead
      String connected = WiFi.SSID();
      bool is_saved = wifi_is_network_saved(ssidSel);
      
      Serial.printf("DEBUG: Tapped SSID: '%s', Connected: '%s', Saved: %s\n", 
                    ssidSel.c_str(), connected.c_str(), is_saved ? "yes" : "no");
      
      if ((WiFi.status() == WL_CONNECTED && ssidSel == connected) || is_saved) {
        Serial.println("DEBUG: Showing WiFi info popup");
        show_wifi_info_popup(ssidSel);
        return;
      }
      Serial.println("DEBUG: Showing password popup");
      lv_label_set_text_fmt(popup_label, "SSID: %s", ssidSel.c_str());
      lv_textarea_set_text(password_ta, "");
      lv_obj_clear_flag(kb, LV_OBJ_FLAG_HIDDEN);
      lv_obj_clear_flag(popup, LV_OBJ_FLAG_HIDDEN);
      lv_obj_align(connecting_label, LV_ALIGN_BOTTOM_MID, 0, -5);
      selectedIndex = idx;
    }, LV_EVENT_CLICKED, (void*)(intptr_t)i);
  }
}

static void wifi_btn_cb(lv_event_t * e) {
  int idx = (int)(intptr_t)lv_event_get_user_data(e);
  if (idx < 0) return;

  String ssidSel = WiFi.SSID(idx);
  lv_label_set_text_fmt(popup_label, "SSID: %s", ssidSel.c_str());
  lv_textarea_set_text(password_ta, "");
  lv_obj_clear_flag(kb, LV_OBJ_FLAG_HIDDEN);
  lv_obj_clear_flag(popup, LV_OBJ_FLAG_HIDDEN);
  lv_obj_align(connecting_label, LV_ALIGN_BOTTOM_MID, 0, -5);
  selectedIndex = idx;
}

static void cancel_btn_cb(lv_event_t * e) {
  lv_obj_add_flag(popup, LV_OBJ_FLAG_HIDDEN);
  lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN);
  lv_textarea_set_text(password_ta, "");
  lv_obj_add_flag(connecting_label, LV_OBJ_FLAG_HIDDEN);
  connecting = false;
}

static void connect_btn_cb(lv_event_t * e) {
  if (connecting || selectedIndex < 0) return;

  String ssid = WiFi.SSID(selectedIndex);
  pendingPassword = lv_textarea_get_text(password_ta);

  WiFi.disconnect(true, false); // Fully disconnect but preserve credentials
  delay(150);

  lv_obj_clear_flag(connecting_label, LV_OBJ_FLAG_HIDDEN);
  WiFi.begin(ssid.c_str(), pendingPassword.c_str());
  connecting = true;
  connectStart = millis();
}

/* ===== Clock ===== */
static void updateClock() {
  if (!clock_label || !lv_obj_is_valid(clock_label)) return;
  time_t now = time(nullptr);
  struct tm *timeinfo = localtime(&now);
  if (timeinfo) {
    static char buf[6];
    strftime(buf, sizeof(buf), "%H:%M", timeinfo);
    lv_label_set_text(clock_label, buf);
  }
}

static void syncTimeWithAPI() {
  Serial.println("Getting location and timezone...");
  HTTPClient http;

  // 1) worldtimeapi.org
  if (http.begin("http://worldtimeapi.org/api/ip")) {
    int code = http.GET();
    Serial.printf("WorldTimeAPI response: %d\n", code);
    if (code == 200) {
      DynamicJsonDocument doc(4096);
      DeserializationError err = deserializeJson(doc, http.getStream());
      if (!err) {
        long unixtime = doc["unixtime"] | 0L;
        if (unixtime > 0) {
          struct timeval tv { (time_t)unixtime, 0 };
          settimeofday(&tv, NULL);
          Serial.println("System time set from WorldTimeAPI");
          http.end();
          return;
        }
      }
    }
    http.end();
  }

  // 2) fallback ip-api for offset + NTP
  Serial.println("Trying alternative time API...");
  if (http.begin("http://ip-api.com/json?fields=timezone,offset")) {
    int code = http.GET();
    if (code == 200) {
      DynamicJsonDocument doc(1024);
      if (deserializeJson(doc, http.getStream()) == DeserializationError::Ok) {
        int offset = doc["offset"] | 0; // seconds
        configTime(offset, 0, "pool.ntp.org", "time.nist.gov");
        Serial.println("Syncing with NTP...");
        for (int i = 0; i < 20; i++) {
          delay(1000);
          time_t now = time(nullptr);
          if (now > 1000000000) {
            Serial.println("NTP sync successful!");
            http.end();
            return;
          }
          Serial.print(".");
        }
      }
    }
    http.end();
  }

  // 3) Last resort: UTC
  Serial.println("Using fallback NTP (UTC)");
  configTime(0, 0, "pool.ntp.org");
}

/* ===== TF Selector ===== */
static void tf_fade_exec_cb(void *var, int32_t v) {
  lv_obj_t *obj = (lv_obj_t*)var;
  if (!obj || !lv_obj_is_valid(obj)) return;
  lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
  if (v == 0) {
    lv_obj_add_flag(obj, LV_OBJ_FLAG_HIDDEN);
    tf_menu_visible = false;
    tf_encoder_mode = false; // BUG FIX: Reset encoder mode when menu auto-fades
    tf_preview_index = tf_current_index; // BUG FIX: Reset preview to current selection
    Serial.println("[TF Menu] Auto-faded - encoder mode disabled");
  }
}

static void tf_hide_timer_cb(lv_timer_t *t) {
  if (!tf_menu_visible || !tf_menu || !lv_obj_is_valid(tf_menu)) return;
  lv_anim_t a;
  lv_anim_init(&a);
  lv_anim_set_var(&a, tf_menu);
  lv_anim_set_exec_cb(&a, tf_fade_exec_cb);
  lv_anim_set_values(&a, 255, 0);
  lv_anim_set_time(&a, 800);
  lv_anim_start(&a);
  lv_timer_del(t);
  tf_timer = nullptr;
}

static void reset_tf_timer() {
  if (!tf_menu_visible) return;
  if (tf_timer) {
    lv_timer_reset(tf_timer);
  } else {
    tf_timer = lv_timer_create(tf_hide_timer_cb, 5000, NULL);
  }
}

// Update TF menu highlights based on preview or current index
static void updateTFHighlights(int highlight_index, bool preview_mode) {
  for (int i = 0; i < tfCount; i++) {
    lv_obj_t *btn = lv_obj_get_child(tf_menu, i);
    if (btn && lv_obj_is_valid(btn)) {
      lv_obj_t *label = lv_obj_get_child(btn, 0);
      if (label && lv_obj_is_valid(label)) {
        if (preview_mode) {
          // In preview mode, highlight preview index with slightly dimmer green
          lv_obj_set_style_text_color(label, (i == highlight_index) ? COLOR_GREEN : COLOR_WHITE, 0);
          // Slightly dim the preview highlight to show it's not confirmed
          if (i == highlight_index) {
            lv_obj_set_style_opa(label, LV_OPA_80, 0);
          } else {
            lv_obj_set_style_opa(label, LV_OPA_COVER, 0);
          }
        } else {
          // Normal mode - full brightness for selected
          lv_obj_set_style_text_color(label, (i == highlight_index) ? COLOR_GREEN : COLOR_WHITE, 0);
          lv_obj_set_style_opa(label, LV_OPA_COVER, 0);
        }
      }
    }
  }
}

static void tf_option_cb(lv_event_t *e) {
  int index = (int)(intptr_t)lv_event_get_user_data(e);
  if (index < 0 || index >= tfCount) return;

  tf_current_index = index;
  tf_preview_index = index;  // Sync preview with current
  currentTFStr = tfOptions[index];
  tf_encoder_mode = false;  // Exit encoder mode

  // Save the timeframe setting immediately
  customPrefs.putInt("tf_index", tf_current_index);

  if (tf_label && lv_obj_is_valid(tf_label)) {
    lv_label_set_text(tf_label, currentTFStr);
  }

  // Update highlights
  updateTFHighlights(tf_current_index, false);

  // Hide menu after a delay to show the scale animation
  lv_timer_t *hide_timer = lv_timer_create([](lv_timer_t *t){
    if (tf_menu && lv_obj_is_valid(tf_menu)) {
      lv_obj_add_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
    }
    tf_menu_visible = false;
    if (tf_timer) {
      lv_timer_del(tf_timer);
      tf_timer = nullptr;
    }
    
    // Now start loading after animation is done
    fetchHistory(currentTFStr);
    startKlineWS(currentTFStr);
  }, 250, NULL); // 250ms delay to see full animation
  lv_timer_set_repeat_count(hide_timer, 1);
}
static void tf_main_btn_cb(lv_event_t *e) {
  if (!tf_menu || !lv_obj_is_valid(tf_menu)) return;
  if (lv_obj_has_flag(tf_menu, LV_OBJ_FLAG_HIDDEN)) {
    lv_obj_clear_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
    lv_obj_set_style_opa(tf_menu, 255, 0);
    tf_menu_visible = true;
    tf_preview_index = tf_current_index;  // Sync preview with current
    tf_encoder_mode = false;  // Touch mode, not encoder mode
    updateTFHighlights(tf_current_index, false);  // Update highlights
    reset_tf_timer();
  } else {
    lv_obj_add_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
    tf_menu_visible = false;
    tf_encoder_mode = false;
    if (tf_timer) { lv_timer_del(tf_timer); tf_timer = nullptr; }
  }
}
static void tf_menu_event_cb(lv_event_t *e) {
  lv_event_code_t code = lv_event_get_code(e);
  if (code == LV_EVENT_PRESSING || code == LV_EVENT_CLICKED) {
    reset_tf_timer();
  }
}
static void setupTFSelector(lv_obj_t *parent) {
  // find index of currentTFStr
  for (int i = 0; i < tfCount; i++) {
    if (strcmp(tfOptions[i], currentTFStr) == 0) {
      tf_current_index = i;
      break;
    }
  }

  // Main TF button
  tf_btn = lv_btn_create(parent);
  lv_obj_set_size(tf_btn, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
  lv_obj_set_style_bg_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_bg_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_bg_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUSED);
  lv_obj_set_style_bg_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
  lv_obj_set_style_bg_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_bg_color(tf_btn, COLOR_BLACK, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_bg_color(tf_btn, COLOR_BLACK, LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_bg_color(tf_btn, COLOR_BLACK, LV_PART_MAIN | LV_STATE_FOCUSED);
  lv_obj_set_style_bg_color(tf_btn, COLOR_BLACK, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
  lv_obj_set_style_bg_color(tf_btn, COLOR_BLACK, LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_border_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_border_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_border_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_FOCUSED);
  lv_obj_set_style_border_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
  lv_obj_set_style_border_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_border_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_border_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_border_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUSED);
  lv_obj_set_style_border_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
  lv_obj_set_style_border_opa(tf_btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_shadow_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_shadow_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_shadow_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_FOCUSED);
  lv_obj_set_style_shadow_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
  lv_obj_set_style_shadow_width(tf_btn, 0, LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_radius(tf_btn, BUTTON_RADIUS, 0);  // Consistent rounded corners
  lv_obj_set_style_pad_all(tf_btn, 8, 0);
  lv_obj_align(tf_btn, LV_ALIGN_TOP_MID, 0, 55);
  lv_obj_add_event_cb(tf_btn, tf_main_btn_cb, LV_EVENT_CLICKED, NULL);

  tf_label = lv_label_create(tf_btn);
  lv_label_set_text(tf_label, currentTFStr);
  lv_obj_set_style_text_font(tf_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(tf_label, COLOR_GREEN, 0);
  lv_obj_center(tf_label);

  // Horizontal TF menu
  tf_menu = lv_obj_create(parent);
  lv_obj_set_size(tf_menu, 600, 50);
  lv_obj_align(tf_menu, LV_ALIGN_TOP_MID, 0, 110);
  lv_obj_set_style_bg_opa(tf_menu, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(tf_menu, 0, 0);
  lv_obj_set_style_shadow_width(tf_menu, 0, 0);
  lv_obj_set_scrollbar_mode(tf_menu, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(tf_menu, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_set_style_pad_all(tf_menu, 0, 0);

  const int total_width = 600;
  const int button_spacing = total_width / tfCount;

  for (int i = 0; i < tfCount; i++) {
    lv_obj_t *btn = lv_btn_create(tf_menu);
    lv_obj_remove_style_all(btn);
    lv_obj_set_size(btn, button_spacing - 4, 40);
    lv_obj_set_pos(btn, i * button_spacing + 2, 5);
    lv_obj_set_style_pad_all(btn, 4, 0);
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(btn, 0, 0);
    lv_obj_set_style_shadow_width(btn, 0, 0);
    lv_obj_set_style_outline_width(btn, 0, 0);
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUSED);
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN | LV_STATE_PRESSED);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN | LV_STATE_FOCUSED);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_PRESSED);
    lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUSED);
    lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_FOCUS_KEY);
    lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_outline_width(btn, 0, LV_PART_MAIN | LV_STATE_PRESSED);
    
    lv_obj_add_event_cb(btn, tf_option_cb, LV_EVENT_CLICKED, (void*)(intptr_t)i);
    
    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, tfOptions[i]);
    lv_obj_set_style_text_font(label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(label, (i == tf_current_index) ? COLOR_GREEN : COLOR_WHITE, 0);
    lv_obj_center(label);
  }

  lv_obj_add_event_cb(tf_menu, tf_menu_event_cb, LV_EVENT_PRESSING, NULL);
  lv_obj_add_event_cb(tf_menu, tf_menu_event_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_add_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
}

/* ===== Rotary Quick Menu ===== */
static void ensureRotaryMenu() {
  // Recreate if previously deleted
  if (rotary_menu_container && !lv_obj_is_valid(rotary_menu_container)) {
    rotary_menu_container = nullptr;
  }

  if (rotary_menu_container) return;

  lv_obj_t *layer = lv_layer_top();
  if (!layer) return;

  rotary_menu_container = lv_obj_create(layer);
  if (!rotary_menu_container) return;

  lv_obj_set_style_bg_color(rotary_menu_container, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(rotary_menu_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_opa(rotary_menu_container, LV_OPA_TRANSP, 0);
  lv_coord_t disp_w = lv_disp_get_hor_res(NULL);
  lv_coord_t disp_h = lv_disp_get_ver_res(NULL);

  lv_obj_set_size(rotary_menu_container, disp_w, disp_h);
  lv_obj_align(rotary_menu_container, LV_ALIGN_CENTER, 0, 0);
  lv_obj_clear_flag(rotary_menu_container, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(rotary_menu_container, LV_OBJ_FLAG_HIDDEN);
  lv_obj_set_style_bg_opa(rotary_menu_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(rotary_menu_container, 0, 0);
  lv_obj_set_style_outline_width(rotary_menu_container, 0, 0);
  lv_obj_set_style_pad_all(rotary_menu_container, 0, 0);
  lv_obj_add_flag(rotary_menu_container, LV_OBJ_FLAG_CLICKABLE);

  // Create large dark gray background circle behind all white circles
  lv_obj_t *bg_circle = lv_obj_create(rotary_menu_container);
  if (bg_circle) {
    lv_coord_t bg_size = (disp_w < disp_h) ? disp_w : disp_h;
    bg_size = (lv_coord_t)(bg_size * 0.6325f);  // 55% * 1.15 = 63.25% (15% bigger)
    if (bg_size < 288) bg_size = 288;  // 250 * 1.15
    if (bg_size > 403) bg_size = 403;  // 350 * 1.15
    
    lv_obj_set_size(bg_circle, bg_size, bg_size);
    lv_obj_set_style_radius(bg_circle, LV_RADIUS_CIRCLE, 0);
    lv_obj_set_style_bg_color(bg_circle, lv_color_make(10, 10, 10), 0);  // Dark gray control panel color
    lv_obj_set_style_bg_opa(bg_circle, LV_OPA_COVER, 0);
    lv_obj_set_style_border_width(bg_circle, 0, 0);
    lv_obj_set_style_outline_width(bg_circle, 0, 0);
    lv_obj_set_style_shadow_width(bg_circle, 0, 0);
    lv_obj_clear_flag(bg_circle, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_align(bg_circle, LV_ALIGN_CENTER, 0, 0);
    // Store bg_circle for later use if needed
  }

  for (int i = 0; i < ROTARY_MENU_COUNT; i++) {
    lv_obj_t *circle = lv_obj_create(rotary_menu_container);
    if (!circle) continue;

    lv_obj_clear_flag(circle, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_radius(circle, LV_RADIUS_CIRCLE, 0);
    lv_obj_set_style_bg_color(circle, COLOR_WHITE, 0);
    lv_obj_set_style_bg_opa(circle, LV_OPA_COVER, 0);
    lv_obj_set_style_pad_all(circle, 0, 0);  // Remove padding to avoid positioning issues
    lv_obj_set_style_border_width(circle, 0, 0);
    lv_obj_set_style_outline_width(circle, 0, 0);
    lv_obj_set_style_shadow_width(circle, 0, 0);
    lv_obj_add_flag(circle, LV_OBJ_FLAG_OVERFLOW_VISIBLE);  // Allow label to render

    // Create label directly in circle - simpler approach for testing
    lv_obj_t *label = lv_label_create(circle);
    if (label) {
      lv_label_set_text(label, rotaryMenuOptions[i]);
      lv_obj_set_style_text_font(label, &poppins_medium_20, 0);
      lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
      lv_label_set_long_mode(label, LV_LABEL_LONG_CLIP);
      lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);
      lv_obj_clear_flag(label, LV_OBJ_FLAG_CLICKABLE);
      lv_obj_set_width(label, LV_SIZE_CONTENT);
      lv_obj_set_height(label, LV_SIZE_CONTENT);
      
      // CRITICAL: Set visibility properties explicitly
      lv_obj_set_style_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
      lv_obj_set_style_bg_opa(label, LV_OPA_TRANSP, 0);
      lv_obj_set_style_pad_all(label, 0, 0);
      lv_obj_set_style_border_width(label, 0, 0);
      
      // NO TRANSFORM - just center the label, let layout handle sizing
      lv_obj_center(label);
    }

    rotary_menu_circles[i] = circle;
    rotary_menu_labels[i] = label;  // Store label directly
  }

  updateRotaryMenuLayout();
  updateRotaryMenuHighlight();
}

static void updateRotaryMenuLayout() {
  if (!rotary_menu_container || !lv_obj_is_valid(rotary_menu_container)) return;

  lv_coord_t disp_w = lv_disp_get_hor_res(NULL);
  lv_coord_t disp_h = lv_disp_get_ver_res(NULL);
  if (disp_w <= 0 || disp_h <= 0) {
    disp_w = lv_obj_get_width(rotary_menu_container);
    disp_h = lv_obj_get_height(rotary_menu_container);
  }
  if (disp_w <= 0) disp_w = 600;
  if (disp_h <= 0) disp_h = 400;

  lv_obj_set_size(rotary_menu_container, disp_w, disp_h);
  lv_obj_align(rotary_menu_container, LV_ALIGN_CENTER, 0, 0);

  lv_coord_t cx = disp_w / 2;
  lv_coord_t cy = disp_h / 2;
  lv_coord_t min_dim = (disp_w < disp_h) ? disp_w : disp_h;
  if (min_dim <= 0) min_dim = 400;

  // Calculate background circle size (same as in ensureRotaryMenu) - 15% bigger
  lv_coord_t bg_size = (lv_coord_t)(min_dim * 0.6325f);  // 55% * 1.15 = 63.25%
  if (bg_size < 288) bg_size = 288;  // 250 * 1.15
  if (bg_size > 403) bg_size = 403;  // 350 * 1.15
  
  // Calculate radius for white circles - spread evenly inside gray circle with more spacing
  // Use 32% of background circle radius to increase spacing between circles
  lv_coord_t radius = (lv_coord_t)(bg_size * 0.32f);  // White circles at 32% of bg circle radius (increased from 25%)
  lv_coord_t circle_size = (lv_coord_t)(min_dim * 0.15f);
  if (circle_size < 70) circle_size = 70;
  if (circle_size > 120) circle_size = 120;

  const float kPi = 3.14159265f;
  const float base_angle = -kPi / 2.0f;  // Start at top (12 o'clock)
  const float step = (ROTARY_MENU_COUNT > 0) ? (2.0f * kPi / ROTARY_MENU_COUNT) : 0.0f;

  for (int i = 0; i < ROTARY_MENU_COUNT; i++) {
    lv_obj_t *circle = rotary_menu_circles[i];
    if (!circle || !lv_obj_is_valid(circle)) continue;

    float angle = base_angle + step * i;
    float cos_a = cosf(angle);
    float sin_a = sinf(angle);
    lv_coord_t x = (lv_coord_t)roundf(cx + radius * cos_a);
    lv_coord_t y = (lv_coord_t)roundf(cy + radius * sin_a);

    lv_obj_set_size(circle, circle_size, circle_size);
    lv_obj_set_pos(circle, x - circle_size / 2, y - circle_size / 2);

    // Get label directly (no container anymore for simplicity)
    lv_obj_t *label = rotary_menu_labels[i];
    if (!label || !lv_obj_is_valid(label)) continue;
    
    if (label && lv_obj_is_valid(label)) {
      // Calculate available space (circle size minus padding for margin)
      lv_coord_t padding = 16;  // Padding around text
      lv_coord_t available_space = circle_size - padding;
      
      // Get text to estimate dimensions
      const char* text = rotaryMenuOptions[i];
      int text_len = strlen(text);
      
      // For poppins_semibold_64: estimate character dimensions
      // Semibold 64px fonts are large - use realistic estimates based on actual font metrics
      lv_coord_t char_width_estimate = 44;  // Average character width at 64px semibold (conservative)
      lv_coord_t estimated_text_width = text_len * char_width_estimate;
      lv_coord_t estimated_text_height = 64;  // Font height at 64px
      
      // Calculate scale needed to fit text in available space
      // Consider both width and height, use the more restrictive one
      int32_t scale_width = 256;
      int32_t scale_height = 256;
      
      if (estimated_text_width > 0) {
        // Use 75% of available space for text to ensure comfortable fit with margin
        // Scale formula: (available_size * 256 * margin_percent) / estimated_size
        scale_width = ((available_space * 256) * 75 / 100) / estimated_text_width;
      }
      if (estimated_text_height > 0) {
        scale_height = ((available_space * 256) * 75 / 100) / estimated_text_height;
      }
      
      // Ensure calculated scales are reasonable
      if (scale_width > 500) scale_width = 256;  // Cap at reasonable maximum
      if (scale_height > 500) scale_height = 256;
      
      // Use the smaller scale to ensure text fits in both dimensions
      int32_t scale = (scale_width < scale_height) ? scale_width : scale_height;
      
      // Clamp scale: minimum 140 (55%) for good visibility, maximum 256 (100%)
      // Increased minimum to ensure text remains visible after transform
      if (scale < 140) scale = 140;  // Minimum 55% scale for visibility
      if (scale > 256) scale = 256;  // Maximum 100% scale
      
      // Safety check: ensure scale is valid
      if (scale <= 0) scale = 200;  // Default to ~78% if calculation failed
      
      // CRITICAL: Set text visibility FIRST - before any transforms
      lv_obj_set_style_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
      lv_obj_set_style_bg_opa(label, LV_OPA_TRANSP, 0);
      lv_obj_set_style_pad_all(label, 0, 0);
      lv_obj_set_style_border_width(label, 0, 0);
      lv_obj_set_style_outline_width(label, 0, 0);
      lv_obj_set_style_shadow_width(label, 0, 0);
      
      // Let label size to content naturally FIRST
      lv_obj_set_width(label, LV_SIZE_CONTENT);
      lv_obj_set_height(label, LV_SIZE_CONTENT);
      
      // Ensure overflow is visible
      lv_obj_add_flag(label, LV_OBJ_FLAG_OVERFLOW_VISIBLE);
      
      // Center the label in the circle first
      lv_obj_center(label);
      
      // SIMPLE APPROACH: Constrain label width to fit in circle, let text wrap/clip
      // This will make text fit without needing transform (which seems to break visibility)
      lv_obj_set_width(label, available_space);
      lv_obj_set_style_max_width(label, available_space, 0);
      lv_obj_set_height(label, LV_SIZE_CONTENT);
      
      // Center the label
      lv_obj_center(label);
      
      // Force layout update
      lv_obj_update_layout(label);
      
      // NO TRANSFORM - just ensure text is visible and fits
      // Text will clip to available space due to width constraint
      // Final center and layout
      lv_obj_center(label);
      lv_obj_update_layout(label);
      
      // CRITICAL: Re-apply all visibility settings after everything
      lv_obj_set_style_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_opa(label, LV_OPA_COVER, 0);
      lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
      lv_obj_set_style_bg_opa(label, LV_OPA_TRANSP, 0);
      
      // Force a refresh/invalidation to ensure rendering
      lv_obj_invalidate(label);
    }
  }
}

static void updateRotaryMenuHighlight() {
  for (int i = 0; i < ROTARY_MENU_COUNT; i++) {
    lv_obj_t *circle = rotary_menu_circles[i];
    if (!circle || !lv_obj_is_valid(circle)) continue;

    bool selected = (i == rotary_menu_index);
    lv_obj_set_style_bg_color(circle, selected ? COLOR_GREEN : COLOR_WHITE, 0);
    
    // Get label directly and set text color
    lv_obj_t *label = rotary_menu_labels[i];
    if (label && lv_obj_is_valid(label)) {
      lv_obj_set_style_text_color(label, COLOR_BLACK, 0);
    }
  }
}

static void reset_rotary_menu_timer() {
  if (!rotary_menu_active) return;

  if (rotary_menu_timer) {
    lv_timer_reset(rotary_menu_timer);
  } else {
    rotary_menu_timer = lv_timer_create(rotary_menu_timer_cb, ROTARY_MENU_TIMEOUT_MS, NULL);
  }
}

static void rotary_menu_set_opacity(lv_obj_t *obj, int32_t v) {
  if (!obj || !lv_obj_is_valid(obj)) return;
  if (v < 0) v = 0;
  if (v > 255) v = 255;
  lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
  lv_opa_t bg_opa = (lv_opa_t)((v * 180) / 255); // Dim background up to ~70%
  lv_obj_set_style_bg_opa(obj, bg_opa, 0);
}

static void showRotaryMenu() {
  ensureRotaryMenu();
  if (!rotary_menu_container || !lv_obj_is_valid(rotary_menu_container)) return;

  lv_anim_del(rotary_menu_container, NULL);
  lv_obj_move_foreground(rotary_menu_container);
  lv_obj_clear_flag(rotary_menu_container, LV_OBJ_FLAG_HIDDEN);
  
  // INSTANT SPAWN - no fade in animation
  rotary_menu_set_opacity(rotary_menu_container, 255);

  rotary_menu_active = true;
  // Layout is already calculated in ensureRotaryMenu() - no need to recalculate
  // updateRotaryMenuLayout(); // REMOVED - causes 1-2 second freeze
  updateRotaryMenuHighlight();
  reset_rotary_menu_timer();
}

static void hideRotaryMenu() {
  if (!rotary_menu_container || !lv_obj_is_valid(rotary_menu_container)) {
    rotary_menu_active = false;
    return;
  }

  if (rotary_menu_timer) {
    lv_timer_del(rotary_menu_timer);
    rotary_menu_timer = nullptr;
  }

  // Cancel any ongoing animations
  lv_anim_del(rotary_menu_container, NULL);

  rotary_menu_active = false;

  // INSTANT HIDE - no fade animation
  rotary_menu_set_opacity(rotary_menu_container, 0);
  lv_obj_add_flag(rotary_menu_container, LV_OBJ_FLAG_HIDDEN);
}

static void rotary_menu_timer_cb(lv_timer_t *t) {
  LV_UNUSED(t);
  hideRotaryMenu();
}

static void rotaryMenuStep(bool clockwise) {
  if (!rotary_menu_active) {
    showRotaryMenu();
  }
  if (!rotary_menu_active) return;

  int previous_index = rotary_menu_index;
  if (clockwise) {
    rotary_menu_index = (rotary_menu_index - 1 + ROTARY_MENU_COUNT) % ROTARY_MENU_COUNT;
  } else {
    rotary_menu_index = (rotary_menu_index + 1) % ROTARY_MENU_COUNT;
  }

  if (previous_index != rotary_menu_index) {
    Serial.printf("[Rotary Menu] Highlight -> %s (index %d, %s)\n",
                  rotaryMenuOptions[rotary_menu_index],
                  rotary_menu_index,
                  clockwise ? "CW" : "CCW");
  }

  updateRotaryMenuHighlight();
  reset_rotary_menu_timer();
}

static void openTFMenuFromRotary() {
  if (!tf_menu || !lv_obj_is_valid(tf_menu)) return;

  lv_obj_clear_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
  lv_obj_set_style_opa(tf_menu, 255, 0);
  tf_menu_visible = true;
  tf_preview_index = tf_current_index;
  tf_encoder_mode = true;
  updateTFHighlights(tf_current_index, false);
  reset_tf_timer();
  Serial.println("[Rotary Menu] TF menu opened via rotary - encoder control enabled");
}

static void activateRotaryMenuSelection() {
  if (rotary_menu_index < 0 || rotary_menu_index >= ROTARY_MENU_COUNT) return;

  const char *selected = rotaryMenuOptions[rotary_menu_index];
  Serial.printf("[Rotary Menu] Selected -> %s\n", selected);

  hideRotaryMenu();

  if (strcmp(selected, "MENU") == 0) {
    createHomepage();
  } else if (strcmp(selected, "TF") == 0) {
    openTFMenuFromRotary();
  } else if (strcmp(selected, "INFO") == 0) {
    showCoinInfoPopup();
  } else if (strcmp(selected, "EDIT") == 0) {
    showCustomizationScreen();
  } else if (strcmp(selected, "ALERT") == 0) {
    createAlertPopup();
  } else if (strcmp(selected, "COINS") == 0) {
    showCoinsPopup();
  }
}
/* ===== Swipe (Pairs) ===== */
static void swipe_anim_exec_cb(void *var, int32_t v) {
  if (!swipe_container || !lv_obj_is_valid(swipe_container)) return;
  lv_obj_set_x(swipe_container, v);
}

static void fadeInAfterDataLoad() {
  if (!swipe_container || !lv_obj_is_valid(swipe_container)) return;
  lv_anim_t fade_anim;
  lv_anim_init(&fade_anim);
  lv_anim_set_var(&fade_anim, swipe_container);
  lv_anim_set_exec_cb(&fade_anim, [](void *var, int32_t v) {
    lv_obj_t *obj = (lv_obj_t*)var;
    if (obj && lv_obj_is_valid(obj)) {
      lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
    }
  });
  lv_anim_set_values(&fade_anim, 0, 255);
  lv_anim_set_time(&fade_anim, 400);
  lv_anim_start(&fade_anim);
}
static void swipe_snap_complete_cb(lv_anim_t *a) {
  is_dragging = false;
  current_offset = 0;
  
  if (swipe_container && lv_obj_is_valid(swipe_container)) {
    lv_obj_set_x(swipe_container, 0);
  }
  
  if (pair_changed) {
    fetchHistory(currentTFStr);
    startKlineWS(currentTFStr);
    pair_changed = false;
    
    // Remove loading text when data starts loading
    if (loading_pair_label && lv_obj_is_valid(loading_pair_label)) {
      lv_anim_t loading_fade;
      lv_anim_init(&loading_fade);
      lv_anim_set_var(&loading_fade, loading_pair_label);
      lv_anim_set_exec_cb(&loading_fade, [](void *var, int32_t v) {
        lv_obj_t *obj = (lv_obj_t*)var;
        if (obj && lv_obj_is_valid(obj)) {
          lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
        }
      });
      lv_anim_set_values(&loading_fade, 255, 0);
      lv_anim_set_time(&loading_fade, 200);
      lv_anim_set_ready_cb(&loading_fade, [](lv_anim_t *a) {
        if (loading_pair_label && lv_obj_is_valid(loading_pair_label)) {
          lv_obj_del(loading_pair_label);
          loading_pair_label = nullptr;
        }
      });
      lv_anim_start(&loading_fade);
    }
    
    // Fade in swipe_container (clock, wifi, icons all fade with it automatically)
    if (swipe_container && lv_obj_is_valid(swipe_container)) {
      lv_anim_t fade_in;
      lv_anim_init(&fade_in);
      lv_anim_set_var(&fade_in, swipe_container);
      lv_anim_set_exec_cb(&fade_in, [](void *var, int32_t v) {
        lv_obj_t *obj = (lv_obj_t*)var;
        if (obj && lv_obj_is_valid(obj)) {
          lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
        }
      });
      lv_anim_set_values(&fade_in, 0, 255);
      lv_anim_set_time(&fade_in, 300);
      lv_anim_start(&fade_in);
    }
    
    if (show_coin_info) {
      showCoinInfoIcon();
    } else {
      hideCoinInfoIcon();
    }
    refreshAlertBellIcon();

    // Battery fade DISABLED
  } else {
    // Restore swipe_container opacity (everything inside restores automatically)
    if (swipe_container && lv_obj_is_valid(swipe_container)) {
      lv_obj_set_style_opa(swipe_container, 255, 0);
    }
    // Battery opacity restore DISABLED
  }
  refreshAlertBellIcon();
}

static void swipe_event_cb(lv_event_t *e) {
  lv_event_code_t code = lv_event_get_code(e);
  lv_indev_t *indev = lv_indev_get_act();
  if (!swipe_container || !lv_obj_is_valid(swipe_container) || !indev) return;

  if (code == LV_EVENT_PRESSED) {
    lv_point_t p; lv_indev_get_point(indev, &p);
    swipe_start_x = p.x;
    is_dragging = true;
    pair_changed = false;
    lv_anim_del(swipe_container, swipe_anim_exec_cb);
    candle_reveal_active = false; // pause re-draw until settled
  }
  else if (code == LV_EVENT_PRESSING && is_dragging) {
    lv_point_t p; lv_indev_get_point(indev, &p);
    int32_t drag = p.x - swipe_start_x;

    // Check if there's a previous/next selected pair
    bool has_previous = false;
    bool has_next = false;
    
    for (int i = current_pair - 1; i >= 0; i--) {
      if (pairs[i].is_selected) {
        has_previous = true;
        break;
      }
    }
    
    for (int i = current_pair + 1; i < PAIR_COUNT; i++) {
      if (pairs[i].is_selected) {
        has_next = true;
        break;
      }
    }
    
    // Prevent dragging right if no previous pair, or left if no next pair
    if ((!has_previous && drag > 0) || (!has_next && drag < 0)) {
      drag = 0;
    }
    current_offset = drag;

    if (swipe_container && lv_obj_is_valid(swipe_container)) {
      lv_obj_set_x(swipe_container, current_offset);
      int32_t abs_off = (current_offset < 0) ? -current_offset : current_offset;
      float ratio = (float)abs_off / (float)SWIPE_THRESHOLD;
      if (ratio > 1.0f) ratio = 1.0f;           // clamp
      lv_opa_t opacity = (lv_opa_t)(255 * (1.0f - ratio)); // 100%->0% linearly
      lv_obj_set_style_opa(swipe_container, opacity, 0);
      // Clock, wifi, icons all fade with container automatically
    }
  }
  else if (code == LV_EVENT_RELEASED && is_dragging) {
    bool should_change = false;
    int new_pair = current_pair;

    // Only allow swiping if multiple pairs are selected
    if (selected_pair_count > 1) {
      // Find next/previous selected pair
      if (current_offset > SWIPE_THRESHOLD) {
        // Swipe right - go to previous selected pair
        for (int i = current_pair - 1; i >= 0; i--) {
          if (pairs[i].is_selected) {
            new_pair = i;
            should_change = true;
            break;
          }
        }
      } else if (current_offset < -SWIPE_THRESHOLD) {
        // Swipe left - go to next selected pair
        for (int i = current_pair + 1; i < PAIR_COUNT; i++) {
          if (pairs[i].is_selected) {
            new_pair = i;
            should_change = true;
            break;
          }
        }
      }
    }

    if (should_change) {
      // Update current_pair first so dots highlight correctly
      current_pair = new_pair;
      pair_changed = true;
      
      // Note: Alerts are now universal, no need to reload per coin
      
      // Show loading logo for the new pair (this triggers dot update)
      showCryptoLoadingLogo(current_pair);

      // Hide pair_label during loading - only show after data loads
      if (pair_label && lv_obj_is_valid(pair_label)) {
        lv_obj_add_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
      }

      if (price_label && lv_obj_is_valid(price_label)) {
        static char buf[20];
        if (pairs[current_pair].last_price > 0.0f) {
          formatPriceWithCommas(pairs[current_pair].last_price, buf, sizeof(buf), current_pair);
          lv_label_set_text(price_label, buf);
        } else {
          static char default_buf[20];
          getDefaultPriceText(current_pair, default_buf, sizeof(default_buf));
          lv_label_set_text(price_label, default_buf);
        }
      }

      if (pairs[current_pair].candle_count > 0) {
        drawCandles();
      }

      lv_obj_invalidate(lv_scr_act());
      lv_timer_handler();

      if (pair_label && lv_obj_is_valid(pair_label)) lv_obj_invalidate(pair_label);
      if (price_label && lv_obj_is_valid(price_label)) lv_obj_invalidate(price_label);
      if (candle_canvas && lv_obj_is_valid(candle_canvas)) lv_obj_invalidate(candle_canvas);
      lv_timer_handler();

      // Set container to 0% opacity (clock, wifi, icons all fade with it automatically)
      if (swipe_container && lv_obj_is_valid(swipe_container)) {
        lv_obj_set_style_opa(swipe_container, 0, 0);
      }
    }

    lv_anim_t snap;
    lv_anim_init(&snap);
    lv_anim_set_var(&snap, swipe_container);
    lv_anim_set_exec_cb(&snap, swipe_anim_exec_cb);
    lv_anim_set_values(&snap, current_offset, 0);
    lv_anim_set_time(&snap, 150);
    lv_anim_set_ready_cb(&snap, swipe_snap_complete_cb);
    lv_anim_start(&snap);

    if (!should_change && swipe_container && lv_obj_is_valid(swipe_container)) {
      lv_obj_set_style_opa(swipe_container, 255, 0);
    }
  }
}

/* ===== Candle Canvas & Drawing (Animated Reveal of REAL Binance Candles) ===== */
static void setupCandles(lv_obj_t *parent) {
  candle_canvas = lv_canvas_create(parent);
  size_t want_bytes = (size_t)CANDLE_AREA_WIDTH * (size_t)CANDLE_AREA_HEIGHT * sizeof(lv_color_t);

  candle_buf = (lv_color_t*)heap_caps_malloc(want_bytes, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if(!candle_buf) candle_buf = (lv_color_t*)heap_caps_malloc(want_bytes, MALLOC_CAP_8BIT);
  if(!candle_buf) {
    Serial.println("Candle canvas allocation failed.");
    lv_obj_del(candle_canvas);
    candle_canvas = nullptr;
    return;
  }

  lv_canvas_set_buffer(candle_canvas, candle_buf, CANDLE_AREA_WIDTH, CANDLE_AREA_HEIGHT, LV_IMG_CF_TRUE_COLOR);
  lv_obj_align(candle_canvas, LV_ALIGN_BOTTOM_MID, 0, -10);
  lv_canvas_fill_bg(candle_canvas, COLOR_BLACK, LV_OPA_COVER);
  
  // Make canvas clickable and add event callbacks for candle inspection
  lv_obj_add_flag(candle_canvas, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_add_event_cb(candle_canvas, candle_inspection_event_cb, LV_EVENT_PRESSED, NULL);
  lv_obj_add_event_cb(candle_canvas, candle_inspection_event_cb, LV_EVENT_PRESSING, NULL);
  lv_obj_add_event_cb(candle_canvas, candle_inspection_event_cb, LV_EVENT_RELEASED, NULL);
  
  // Create popup container for displaying time, Open, High, Low, Close, Change, Volume
  candle_info_popup = lv_obj_create(parent);
  lv_obj_set_size(candle_info_popup, 238, 260);
  lv_obj_set_style_bg_color(candle_info_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_bg_opa(candle_info_popup, LV_OPA_COVER, 0);
  lv_obj_set_style_radius(candle_info_popup, 20, 0); // More rounded corners
  lv_obj_set_style_border_width(candle_info_popup, 0, 0);
  lv_obj_set_style_pad_all(candle_info_popup, 15, 0);
  lv_obj_add_flag(candle_info_popup, LV_OBJ_FLAG_HIDDEN); // Initially hidden
  
  // Create time label at top of popup
  candle_info_label = lv_label_create(candle_info_popup);
  lv_label_set_text(candle_info_label, "00:00\n\nOpen  0.00\nHigh  0.00\nLow  0.00\nClose  0.00\nChange  +0.00%\nVolume  0");
  lv_obj_set_style_text_color(candle_info_label, COLOR_GREEN, 0);
  lv_obj_set_style_text_font(candle_info_label, &poppins_light_20, 0);
  lv_obj_set_style_text_align(candle_info_label, LV_TEXT_ALIGN_LEFT, 0);
  lv_obj_align(candle_info_label, LV_ALIGN_TOP_LEFT, 10, 5); // Align to top-left to avoid scrolling
}
static void drawCandles() {
  if(!candle_canvas || !candle_buf || pairs[current_pair].candle_count == 0) return;

  lv_canvas_fill_bg(candle_canvas, COLOR_BLACK, LV_OPA_COVER);

  Candle* candles = pairs[current_pair].candles;
  int candleCount = pairs[current_pair].candle_count;

  float minP = candles[0].low, maxP = candles[0].high;
  for (int i = 1; i < candleCount; i++) {
    if (candles[i].low < minP) minP = candles[i].low;
    if (candles[i].high > maxP) maxP = candles[i].high;

    // Force redraw of canvas + container
    if (candle_canvas && lv_obj_is_valid(candle_canvas)) {
      lv_obj_invalidate(candle_canvas);
      lv_obj_invalidate(lv_obj_get_parent(candle_canvas));
    }
  }

  // Use full range over currently available candles (original logic)
  float range = (maxP - minP);
  if (range <= 0.0f) range = 1.0f;
  float scale = (float)CANDLE_AREA_HEIGHT / range;

  // Reveal logic draws a prefix of the total, else draw all available (capped at MAX_CANDLES)
  int toDraw = candle_reveal_active ? visible_candles : candleCount;
  if (toDraw > candleCount) toDraw = candleCount;
  if (toDraw > MAX_CANDLES) toDraw = MAX_CANDLES;
  if (toDraw <= 0) return;

  // Evenly distribute across width using fixed slots
  int slotW = CANDLE_AREA_WIDTH / MAX_CANDLES;
  // Debug log removed per request

  static lv_draw_line_dsc_t wick_dsc;
  static lv_draw_rect_dsc_t rect_dsc;
  static bool dsc_initialized = false;
  if (!dsc_initialized) {
    lv_draw_line_dsc_init(&wick_dsc);
    lv_draw_rect_dsc_init(&rect_dsc);
    wick_dsc.width = 2;
    rect_dsc.border_width = 0;
    dsc_initialized = true;
  }

  // Draw from the left, limited to the latest MAX_CANDLES if more are loaded
  int startIdx = (candleCount > MAX_CANDLES) ? (candleCount - MAX_CANDLES) : 0;
  int drawCount = (toDraw > MAX_CANDLES) ? MAX_CANDLES : toDraw;
  for (int i = 0; i < drawCount; i++) {
    int ci = startIdx + i;
    int x = i * slotW + slotW / 2;
    int yOpen  = CANDLE_AREA_HEIGHT - (int)((candles[ci].open  - minP) * scale);
    int yClose = CANDLE_AREA_HEIGHT - (int)((candles[ci].close - minP) * scale);
    int yHigh  = CANDLE_AREA_HEIGHT - (int)((candles[ci].high  - minP) * scale);
    int yLow   = CANDLE_AREA_HEIGHT - (int)((candles[ci].low   - minP) * scale);

    lv_color_t color = (candles[ci].close >= candles[ci].open) ? COLOR_GREEN : COLOR_RED;

    wick_dsc.color = color;
    lv_point_t pts[2] = { {x, yHigh}, {x, yLow} };
    lv_canvas_draw_line(candle_canvas, pts, 2, &wick_dsc);

    int top = (yOpen < yClose) ? yOpen : yClose;
    int bottom = (yOpen > yClose) ? yOpen : yClose;
    int bodyH = bottom - top;
    if (bodyH < 1) bodyH = 1;

    rect_dsc.bg_color = color;
    lv_canvas_draw_rect(candle_canvas, x - slotW/3, top, (slotW*2)/3, bodyH, &rect_dsc);
  }

  // Draw inspection line and update info if active
  if (candle_inspection_active && candle_touch_x >= 0 && candle_touch_x < CANDLE_AREA_WIDTH) {
    // Find closest candle to touch position
    int closestIdx = -1;
    int minDist = 999999;
    for (int i = 0; i < drawCount; i++) {
      int x = i * slotW + slotW / 2;
      int dist = abs(x - candle_touch_x);
      if (dist < minDist) {
        minDist = dist;
        closestIdx = i;
      }
    }
    
    if (closestIdx >= 0) {
      int snapped_x = closestIdx * slotW + slotW / 2;
      candle_selected_index = startIdx + closestIdx;
      
      // Determine the selected candle's color (red or green)
      Candle &selected = candles[candle_selected_index];
      lv_color_t candle_color = (selected.close >= selected.open) ? COLOR_GREEN : COLOR_RED;
      
      // Draw vertical white line at snapped position (60% taller = 240 pixels total)
      static lv_draw_line_dsc_t inspect_line_dsc;
      static bool inspect_dsc_initialized = false;
      if (!inspect_dsc_initialized) {
        lv_draw_line_dsc_init(&inspect_line_dsc);
        inspect_line_dsc.width = 1;
        inspect_line_dsc.color = COLOR_WHITE;
        inspect_dsc_initialized = true;
      }
      inspect_line_dsc.color = COLOR_WHITE;
      // Extend line 60% beyond canvas bounds (44 pixels on each side)
      lv_point_t line_pts[2] = { {snapped_x, -44}, {snapped_x, CANDLE_AREA_HEIGHT + 45} };
      lv_canvas_draw_line(candle_canvas, line_pts, 2, &inspect_line_dsc);
      
      // Update info label with Time, Open, High, Low, Close, Change, Volume (with newlines for popup)
      if (candle_info_label && lv_obj_is_valid(candle_info_label)) {
        static char info_buf[350];
        
        // Get decimal places for current pair to match liveprice display
        int decimalPlaces = getDecimalPlaces(current_pair);
        
        // Format timestamp to HH:MM:SS in UTC (Binance server time)
        char time_str[20] = "00:00:00";
        if (selected.open_time > 0) {
          // Binance timestamps are in milliseconds since Unix epoch
          unsigned long long epoch_seconds = selected.open_time / 1000;
          
          // Calculate UTC time components
          // Seconds within the day (0-86399)
          unsigned long long seconds_today = epoch_seconds % 86400ULL;
          
          // Hours (0-23)
          int hours = (int)(seconds_today / 3600ULL);
          // Minutes (0-59)
          int minutes = (int)((seconds_today % 3600ULL) / 60ULL);
          
          snprintf(time_str, sizeof(time_str), "%02d:%02d", hours, minutes);
        }
        
        // Check if this is the current (last) candle
        bool is_current_candle = (candle_selected_index == (candleCount - 1));
        float close_price = is_current_candle ? pairs[current_pair].last_price : selected.close;
        if (close_price <= 0.0f) close_price = selected.close; // fallback
        
        // Calculate percentage growth
        float percent_growth = 0.0f;
        if (selected.open > 0.0f) {
          percent_growth = ((close_price - selected.open) / selected.open) * 100.0f;
        }
        
        // Format volume (K, M, B)
        char vol_str[20];
        float vol = selected.volume;
        if (vol >= 1000000000.0f) {
          snprintf(vol_str, sizeof(vol_str), "%.2fB", vol / 1000000000.0f);
        } else if (vol >= 1000000.0f) {
          snprintf(vol_str, sizeof(vol_str), "%.2fM", vol / 1000000.0f);
        } else if (vol >= 1000.0f) {
          snprintf(vol_str, sizeof(vol_str), "%.2fK", vol / 1000.0f);
        } else {
          snprintf(vol_str, sizeof(vol_str), "%.0f", vol);
        }
        
        // Build format string with dynamic decimal places (start with time)
        char format_str[120];
        snprintf(format_str, sizeof(format_str), "%%s\n\nOpen  %%.%df\nHigh  %%.%df\nLow  %%.%df\nClose  %%.%df\nChange  %%s%%.2f%%%%\nVolume  %%s", 
                 decimalPlaces, decimalPlaces, decimalPlaces, decimalPlaces);
        
        // Format with newlines for cleaner popup display - show time first, then OHLCV data with matching decimal places
        snprintf(info_buf, sizeof(info_buf), format_str, 
                 time_str, selected.open, selected.high, selected.low, close_price, 
                 percent_growth >= 0 ? "+" : "", percent_growth, vol_str);
        lv_label_set_text(candle_info_label, info_buf);
        lv_obj_set_style_text_color(candle_info_label, candle_color, 0); // Match candle color (red or green)
      }
    }
  }

  // Ensure LVGL refreshes the canvas this frame
  if (candle_canvas && lv_obj_is_valid(candle_canvas)) {
    lv_obj_invalidate(candle_canvas);
    lv_obj_invalidate(lv_obj_get_parent(candle_canvas));
  }
}

static void revealCandleStep(lv_timer_t *t) {
  if (!candle_reveal_active) { 
    lv_timer_del(t); 
    candle_timer = nullptr;
    return; 
  }
  
  // Max-speed animation: reveal 4 candles per tick for faster fill
  visible_candles += 4;
  
  if (visible_candles > pairs[current_pair].candle_count) {
    visible_candles = pairs[current_pair].candle_count; // Don't exceed total
    candle_reveal_active = false;
    lv_timer_del(t);
    candle_timer = nullptr;
    Serial.println("Candle animation complete!");
    return;
  }
  drawCandles();
}

static void startCandleAnimation() {
  visible_candles = 0;
  candle_reveal_active = true;
  
  // Delete existing timer if it exists
  if (candle_timer) {
    lv_timer_del(candle_timer);
    candle_timer = nullptr;
  }
  
  // Create a faster timer (as fast as stable without starving LVGL)
  candle_timer = lv_timer_create(revealCandleStep, 60, NULL);
  
  // Debug: Print timer creation and timing
  Serial.printf("Candle animation started: %d candles, 2 per step (~2 seconds)\n", pairs[current_pair].candle_count);
}
/* ===== Candle Inspection Event Handler ===== */
static void candle_inspection_event_cb(lv_event_t *e) {
  lv_event_code_t code = lv_event_get_code(e);
  lv_indev_t *indev = lv_indev_get_act();
  if (!indev) return;

  lv_point_t point;
  lv_indev_get_point(indev, &point);

  // Get the target object (could be swipe_container or candle_canvas)
  lv_obj_t *target = lv_event_get_target(e);
  
  // Convert screen coordinates to canvas-relative coordinates for candle snapping
  int rel_x, rel_y;
  if (target == candle_canvas) {
    // If triggered from candle_canvas, use relative coordinates
  lv_point_t canvas_pos;
    canvas_pos.x = lv_obj_get_x(candle_canvas);
    canvas_pos.y = lv_obj_get_y(candle_canvas);
    rel_x = point.x - canvas_pos.x;
    rel_y = point.y - canvas_pos.y;
  } else if (target == swipe_container) {
    // If triggered from swipe_container, convert to candle canvas coordinates
    if (!candle_canvas || !lv_obj_is_valid(candle_canvas)) return;
    lv_point_t canvas_pos;
    canvas_pos.x = lv_obj_get_x(candle_canvas);
    canvas_pos.y = lv_obj_get_y(candle_canvas);
    rel_x = point.x - canvas_pos.x;
    rel_y = point.y - canvas_pos.y;
  } else {
    // Other object, try to use candle canvas coordinates
    if (!candle_canvas || !lv_obj_is_valid(candle_canvas)) return;
    lv_point_t canvas_pos;
    canvas_pos.x = lv_obj_get_x(candle_canvas);
    canvas_pos.y = lv_obj_get_y(candle_canvas);
    rel_x = point.x - canvas_pos.x;
    rel_y = point.y - canvas_pos.y;
  }
  
  // Store screen coordinates for popup positioning
  static int screen_touch_x = 0;

  if (code == LV_EVENT_PRESSED) {
    // Start tracking the touch
    candle_touch_start_time = millis();
    candle_touch_x = rel_x;
    candle_touch_y = rel_y;
    screen_touch_x = point.x; // Store screen x coordinate
    candle_inspection_active = false;
  }
  else if (code == LV_EVENT_PRESSING) {
    // Update touch position
    candle_touch_x = rel_x;
    candle_touch_y = rel_y;
    screen_touch_x = point.x; // Update screen x coordinate
    
    // Check if 0.5 seconds has passed
    if (!candle_inspection_active && (millis() - candle_touch_start_time) >= 500) {
      candle_inspection_active = true;
      Serial.println("Candle inspection activated!");
    }
    
    // If inspection is active, redraw to show the line
    if (candle_inspection_active) {
      drawCandles();
      
      // Show and position popup
      if (candle_info_popup && lv_obj_is_valid(candle_info_popup)) {
        // Position popup on left or right based on touch position
        // Get screen width
        int screen_width = amoled.width();
        float touch_percent = (float)screen_touch_x / screen_width;
        
        if (touch_percent <= 0.5f) {
          // Left side of screen (0-50%), show popup on right
          lv_obj_align(candle_info_popup, LV_ALIGN_CENTER, 140, -50);
        } else {
          // Right side of screen (51-100%), show popup on left
          lv_obj_align(candle_info_popup, LV_ALIGN_CENTER, -140, -50);
        }
        
        lv_obj_clear_flag(candle_info_popup, LV_OBJ_FLAG_HIDDEN);
      }
    }
  }
  else if (code == LV_EVENT_RELEASED) {
    // Hide the inspection line and info
    if (candle_inspection_active) {
      candle_inspection_active = false;
      candle_selected_index = -1;
      
      // Hide the popup
      if (candle_info_popup && lv_obj_is_valid(candle_info_popup)) {
        lv_obj_add_flag(candle_info_popup, LV_OBJ_FLAG_HIDDEN);
      }
      
      // Redraw without the line
      drawCandles();
    }
  }
}

/* ===== Coin Indicator Dots ===== */
static void createCoinDots(lv_obj_t *parent) {
  // Initialize all dots to nullptr
  for (int i = 0; i < PAIR_COUNT; i++) {
    coin_dots[i] = nullptr;
  }
  
  // Create container for dots at bottom center
  coin_dots_container = lv_obj_create(parent);
  lv_obj_set_size(coin_dots_container, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
  lv_obj_align(coin_dots_container, LV_ALIGN_BOTTOM_MID, 0, -10);
  lv_obj_set_style_bg_opa(coin_dots_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(coin_dots_container, 0, 0);
  lv_obj_set_style_pad_all(coin_dots_container, 5, 0);
  lv_obj_set_style_pad_column(coin_dots_container, 10, 0); // 10px spacing between dots
  lv_obj_set_flex_flow(coin_dots_container, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(coin_dots_container, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  lv_obj_add_flag(coin_dots_container, LV_OBJ_FLAG_HIDDEN); // Initially hidden
  
  // Create dots based on selected pair count
  for (int i = 0; i < selected_pair_count; i++) {
    coin_dots[i] = lv_obj_create(coin_dots_container);
    lv_obj_set_size(coin_dots[i], 8, 8);
    lv_obj_set_style_radius(coin_dots[i], LV_RADIUS_CIRCLE, 0);
    lv_obj_set_style_bg_color(coin_dots[i], COLOR_GRAY, 0);
    lv_obj_set_style_border_width(coin_dots[i], 0, 0);
    lv_obj_set_style_pad_all(coin_dots[i], 0, 0);
  }
  
  // Highlight current coin
  updateCoinDots();
}

static void updateCoinDots() {
  if (!coin_dots_container || !lv_obj_is_valid(coin_dots_container)) return;
  
  // Find which dot index corresponds to current_pair
  int current_dot_index = -1;
  int dot_index = 0;
  
  for (int i = 0; i < PAIR_COUNT; i++) {
    if (pairs[i].is_selected) {
      if (i == current_pair) {
        current_dot_index = dot_index;
        break;
      }
      dot_index++;
    }
  }
  
  // Update all dots: gray for inactive, green for current
  for (int i = 0; i < selected_pair_count; i++) {
    if (coin_dots[i] && lv_obj_is_valid(coin_dots[i])) {
      if (i == current_dot_index) {
        lv_obj_set_style_bg_color(coin_dots[i], COLOR_GREEN, 0);
      } else {
        lv_obj_set_style_bg_color(coin_dots[i], COLOR_GRAY, 0);
      }
    }
  }
}
static void showCoinDots() {
  if (!coin_dots_container || !lv_obj_is_valid(coin_dots_container)) return;
  
  // Don't show dots if only one coin is selected
  if (selected_pair_count <= 1) return;
  
  // Show the dots
  lv_obj_clear_flag(coin_dots_container, LV_OBJ_FLAG_HIDDEN);
  lv_obj_set_style_opa(coin_dots_container, LV_OPA_COVER, 0);
  
  // Update which dot is highlighted
  updateCoinDots();
  
  // Cancel any existing fade timer
  if (coin_dots_fade_timer) {
    lv_timer_del(coin_dots_fade_timer);
    coin_dots_fade_timer = nullptr;
  }
  
  // Start 5 second timer to fade out
  coin_dots_fade_timer = lv_timer_create(coin_dots_fade_timer_cb, 5000, NULL);
  lv_timer_set_repeat_count(coin_dots_fade_timer, 1);
}

static void coin_dots_fade_timer_cb(lv_timer_t *t) {
  if (!coin_dots_container || !lv_obj_is_valid(coin_dots_container)) {
    coin_dots_fade_timer = nullptr;
    return;
  }
  
  // Start fade out animation
  lv_anim_init(&coin_dots_fade_anim);
  lv_anim_set_var(&coin_dots_fade_anim, coin_dots_container);
  lv_anim_set_exec_cb(&coin_dots_fade_anim, coin_dots_fade_anim_cb);
  lv_anim_set_values(&coin_dots_fade_anim, LV_OPA_COVER, LV_OPA_TRANSP);
  lv_anim_set_time(&coin_dots_fade_anim, 500);
  lv_timer_handler();
  lv_anim_set_ready_cb(&coin_dots_fade_anim, [](lv_anim_t *a) {
    if (coin_dots_container && lv_obj_is_valid(coin_dots_container)) {
      lv_obj_add_flag(coin_dots_container, LV_OBJ_FLAG_HIDDEN);
    }
  });
  lv_anim_start(&coin_dots_fade_anim);
  
  coin_dots_fade_timer = nullptr;
}

static void coin_dots_fade_anim_cb(void *var, int32_t v) {
  lv_obj_t *obj = (lv_obj_t*)var;
  if (obj && lv_obj_is_valid(obj)) {
    lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
  }
}
/* ===== REST: Fetch History ===== */
static void fetchHistory(const char* tf) {
  HTTPClient http;
  String url = "https://api.binance.com/api/v3/klines?symbol=";
  url += pairs[current_pair].symbol;
  url += "&interval=";
  url += tf;
  url += "&limit=60";

  Serial.printf("Fetching data for %s, TF: %s\n", pairs[current_pair].symbol.c_str(), tf);

  if (http.begin(url)) {
    int httpCode = http.GET();
    lv_timer_handler();   // let LVGL update display
    if (httpCode == HTTP_CODE_OK) {
      // Increase buffer to handle 60 klines comfortably
      DynamicJsonDocument doc(32768);
      if (deserializeJson(doc, http.getStream()) == DeserializationError::Ok) {
        lv_timer_handler();
        pairs[current_pair].candle_count = 0;
        JsonArray array = doc.as<JsonArray>();
        Serial.printf("Klines received: %u\n", (unsigned)array.size());
        // Take the most recent MAX_CANDLES from the end of the array
        size_t total = array.size();
        size_t want = (total > (size_t)MAX_CANDLES) ? (size_t)MAX_CANDLES : total;
        size_t start = (total > want) ? (total - want) : 0;
        for (size_t idx = start; idx < total; idx++) {
          JsonArray k = array[idx].as<JsonArray>();
          if (!k.isNull()) {
            // Parse timestamp - Binance returns open_time as first element in milliseconds
            unsigned long long timestamp = 0;
            if (k[0].is<unsigned long long>()) {
              timestamp = k[0].as<unsigned long long>();
            } else if (k[0].is<double>()) {
              timestamp = (unsigned long long)k[0].as<double>();
            } else if (k[0].is<const char*>()) {
              // Parse as string if JSON library returns it as string
              timestamp = strtoull(k[0].as<const char*>(), NULL, 10);
            }
            
            // Debug: only print first and last candle timestamps
            if (idx == start || (idx == total - 1 && pairs[current_pair].candle_count <= 2)) {
              Serial.printf("Candle timestamp: %llu\n", timestamp);
            }
            
            pairs[current_pair].candles[pairs[current_pair].candle_count++] = {
              k[1].as<float>(),
              k[2].as<float>(),
              k[3].as<float>(),
              k[4].as<float>(),
              k[5].as<float>(),
              timestamp
            };
          }
        }
        Serial.printf("Data loaded: %d candles\n", pairs[current_pair].candle_count);

        // Animate reveal of candles
        startCandleAnimation();

        // NOTE: No container fade here on TF change.
        // (fadeInAfterDataLoad() is only used after pair swipe completes)
      } else {
        Serial.println("JSON parsing failed");
      }
    } else {
      Serial.printf("HTTP request failed: %d\n", httpCode);
    }
    http.end();
  } else {
    Serial.println("HTTP begin failed");
  }
}

/* ===== Fetch 24h Ticker (for daily % change) ===== */
static void fetch24hTicker(int pairIndex) {
  if (pairIndex < 0 || pairIndex >= active_pair_count) return;
  if (pairs[pairIndex].symbol.length() == 0) return;
  
  HTTPClient http;
  String url = "https://api.binance.com/api/v3/ticker/24hr?symbol=";
  url += pairs[pairIndex].symbol;
  
  Serial.printf("Fetching 24h ticker for %s\n", pairs[pairIndex].symbol.c_str());
  
  if (http.begin(url)) {
    int httpCode = http.GET();
    if (httpCode == HTTP_CODE_OK) {
      DynamicJsonDocument doc(2048);
      if (deserializeJson(doc, http.getStream()) == DeserializationError::Ok) {
        // Get 24h price change percentage and current price
        float priceChangePercent = doc["priceChangePercent"].as<float>();
        float lastPrice = doc["lastPrice"].as<float>();
        
        pairs[pairIndex].daily_change_percent = priceChangePercent;
        pairs[pairIndex].last_price = lastPrice;  // Update price from ticker
        pairs[pairIndex].last_ticker_update = millis();
        
        Serial.printf("%s: $%.2f, 24h: %.2f%%\n", pairs[pairIndex].symbol.c_str(), lastPrice, priceChangePercent);
      } else {
        Serial.println("24h ticker JSON parsing failed");
      }
    } else {
      Serial.printf("24h ticker HTTP failed: %d\n", httpCode);
    }
    http.end();
  }
}

/* ===== Fetch All 24h Tickers in One Batch Request ===== */
static void fetchAll24hTickers() {
  if (active_pair_count == 0) return;
  
  HTTPClient http;
  
  // Build symbols array for batch request: ["BTCUSDT","ETHUSDT",...]
  String symbols = "[";
  for (int i = 0; i < active_pair_count; i++) {
    if (pairs[i].symbol.length() > 0) {
      symbols += "\"" + pairs[i].symbol + "\"";
      if (i < active_pair_count - 1) symbols += ",";
    }
  }
  symbols += "]";
  
  // URL encode the symbols parameter
  symbols.replace(" ", "%20");
  symbols.replace("[", "%5B");
  symbols.replace("]", "%5D");
  symbols.replace("\"", "%22");
  symbols.replace(",", "%2C");
  
  String url = "https://api.binance.com/api/v3/ticker/24hr?symbols=" + symbols;
  
  Serial.printf("Fetching 24h ticker for %d coins in batch...\n", active_pair_count);
  
  if (http.begin(url)) {
    // Set timeout to avoid freezing if API is slow
    http.setTimeout(10000); // 10 second timeout
    
    int httpCode = http.GET();
    if (httpCode == HTTP_CODE_OK) {
      // Use larger document for batch response (up to 10 coins)
      DynamicJsonDocument doc(8192);
      
      DeserializationError error = deserializeJson(doc, http.getStream());
      if (error == DeserializationError::Ok) {
        JsonArray array = doc.as<JsonArray>();
        
        Serial.printf("Received data for %d coins\n", array.size());
        
        // Update each pair with matching symbol
        for (JsonObject ticker : array) {
          String symbol = ticker["symbol"].as<String>();
          float priceChangePercent = ticker["priceChangePercent"].as<float>();
          float lastPrice = ticker["lastPrice"].as<float>();
          
          // Find matching pair and update
          for (int i = 0; i < active_pair_count; i++) {
            if (pairs[i].symbol == symbol) {
              pairs[i].daily_change_percent = priceChangePercent;
              pairs[i].last_price = lastPrice;
              pairs[i].last_ticker_update = millis();
              Serial.printf("  %s: $%.2f, 24h: %.2f%%\n", symbol.c_str(), lastPrice, priceChangePercent);
              break;
            }
          }
        }
        
        Serial.println("Batch ticker update complete!");
      } else {
        Serial.printf("24h ticker JSON parsing failed: %s\n", error.c_str());
      }
    } else {
      Serial.printf("24h ticker HTTP failed: %d\n", httpCode);
    }
    http.end();
  } else {
    Serial.println("Failed to begin HTTP connection for batch ticker");
  }
}

/* ===== WebSocket: Realtime Klines ===== */
static void addCandle(float o, float h, float l, float c, float v, unsigned long long t, bool closed) {
  int& cnt = pairs[current_pair].candle_count;
  Candle* arr = pairs[current_pair].candles;

  // If we have no candles yet, seed the first one
  if (cnt <= 0) {
    arr[0] = {o,h,l,c,v,t};
    cnt = 1;
    drawCandles();
    return;
  }

  if (!closed) {
    // Update the in-progress (current) candle, do NOT append
    arr[cnt - 1] = {o,h,l,c,v,t};
  } else {
    // Candle closed: append a new candle; shift if we're at capacity
    if (cnt < MAX_CANDLES) {
      arr[cnt++] = {o,h,l,c,v,t};
    } else {
      memmove(&arr[0], &arr[1], (MAX_CANDLES - 1) * sizeof(Candle));
      arr[MAX_CANDLES - 1] = {o,h,l,c,v,t};
    }
  }
  // Always draw full set (capped) immediately
  drawCandles();
}

static void wsKlineEvent(WStype_t type, uint8_t * payload, size_t length) {
  if (type != WStype_TEXT) return;

  StaticJsonDocument<768> doc;
  if (deserializeJson(doc, payload, length) != DeserializationError::Ok) return;

  JsonObject k = doc["k"];
  if (k.isNull()) return;

  String symbol = k["s"].as<String>();
  for (int i = 0; i < PAIR_COUNT; i++) {
    if (symbol == pairs[i].symbol) {
      pairs[i].last_price = k["c"].as<float>();
      pairs[i].last_update = millis();

      if (i == current_pair) {
        // Parse timestamp with fallback - k["t"] is the open time in milliseconds
        unsigned long long timestamp = 0;
        if (k["t"].is<unsigned long long>()) {
          timestamp = k["t"].as<unsigned long long>();
        } else if (k["t"].is<double>()) {
          timestamp = (unsigned long long)k["t"].as<double>();
        } else if (k["t"].is<const char*>()) {
          // Parse as string if JSON library returns it as string
          timestamp = strtoull(k["t"].as<const char*>(), NULL, 10);
        }
        
        addCandle(k["o"].as<float>(), k["h"].as<float>(), k["l"].as<float>(), k["c"].as<float>(), k["v"].as<float>(), timestamp, k["x"].as<bool>());
      }
      break;
    }
  }
}

static void startKlineWS(const char* tf) {
  // Disconnect all first
  for (int i = 0; i < PAIR_COUNT; i++) pairs[i].ws_client.disconnect();

  // Start websocket for current pair
  String path = "/ws/";
  String symbol_lower = String(pairs[current_pair].symbol); symbol_lower.toLowerCase();
  path += symbol_lower;
  path += "@kline_";
  path += tf;

  pairs[current_pair].ws_client.beginSSL("stream.binance.com", 9443, path.c_str());
  pairs[current_pair].ws_client.onEvent(wsKlineEvent);
  pairs[current_pair].ws_client.setReconnectInterval(5000);
  
  // Also start websockets for all coins with active alerts (for background price tracking)
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (!coin_alerts[i].active) continue;
    
    // Find the pair index for this alert's coin
    for (int p = 0; p < active_pair_count; p++) {
      if (p == current_pair) continue; // Already started above
      if (pairs[p].symbol == coin_alerts[i].coin_symbol) {
        String alert_path = "/ws/";
        String alert_symbol_lower = String(pairs[p].symbol); alert_symbol_lower.toLowerCase();
        alert_path += alert_symbol_lower;
        alert_path += "@kline_";
        alert_path += tf;
        
        pairs[p].ws_client.beginSSL("stream.binance.com", 9443, alert_path.c_str());
        pairs[p].ws_client.onEvent(wsKlineEvent);
        pairs[p].ws_client.setReconnectInterval(5000);
        Serial.printf("[Alerts] Started background WS for %s (has active alerts)\n", pairs[p].symbol.c_str());
        break;
      }
    }
  }
}
static void setupHomepageFocus() {
  if (!homepage_screen || !lv_obj_is_valid(homepage_screen)) {
    Serial.println("[Homepage] ERROR: homepage_screen invalid");
    return;
  }
  
  // Ensure layout is updated before setting up focus
  lv_obj_update_layout(homepage_screen);

  encoderFocusBegin(homepage_screen);

  // Add buttons to encoder focus - ensure labels exist
  int added = 0;
  if (favorites_btn && lv_obj_is_valid(favorites_btn)) {
    lv_obj_t *label = lv_obj_get_child(favorites_btn, 0);
    if (label && lv_obj_is_valid(label)) {
      encoderFocusAdd(favorites_btn, label);
      added++;
      Serial.println("[Homepage] Added favorites_btn to encoder focus");
    }
  }
  if (utilities_btn && lv_obj_is_valid(utilities_btn)) {
    lv_obj_t *label = lv_obj_get_child(utilities_btn, 0);
    if (label && lv_obj_is_valid(label)) {
      encoderFocusAdd(utilities_btn, label);
      added++;
      Serial.println("[Homepage] Added utilities_btn to encoder focus");
    }
  }
  if (settings_btn && lv_obj_is_valid(settings_btn)) {
    lv_obj_t *label = lv_obj_get_child(settings_btn, 0);
    if (label && lv_obj_is_valid(label)) {
      encoderFocusAdd(settings_btn, label);
      added++;
      Serial.println("[Homepage] Added settings_btn to encoder focus");
    }
  }

  encoderFocusCommit(0);
  
  Serial.printf("[Homepage] Encoder focus setup: %d items added, %d in context, active: %d, top index: %d\n", 
                added, encoder_focus_ctx.count, encoder_focus_ctx.active, encoder_focus_ctx.index);
}

/* ===== Homepage ===== */
static void createHomepage() {
  homepage_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(homepage_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(homepage_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(homepage_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(homepage_screen);

  // Add swipe-down gesture detection to show control panel
  // Removed auto-show; drag is handled by top-edge grabber


  // Logo instead of title text
  lv_obj_t *logo = lv_img_create(homepage_screen);
  LV_IMG_DECLARE(LumenLogo);  // Declare the image
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Favorites button
  favorites_btn = lv_btn_create(homepage_screen);
  lv_obj_set_size(favorites_btn, 300, 60);
  lv_obj_align(favorites_btn, LV_ALIGN_CENTER, 0, -80);
  lv_obj_set_style_bg_color(favorites_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(favorites_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(favorites_btn, favorites_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *fav_label = lv_label_create(favorites_btn);
  lv_label_set_text(fav_label, "Get started");
  lv_obj_set_style_text_font(fav_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(fav_label, COLOR_BLACK, 0);
  lv_obj_center(fav_label);

  // Utilities button
  utilities_btn = lv_btn_create(homepage_screen);
  lv_obj_set_size(utilities_btn, 300, 60);
  lv_obj_align(utilities_btn, LV_ALIGN_CENTER, 0, -10);
  lv_obj_set_style_bg_color(utilities_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(utilities_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(utilities_btn, utilities_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *utilities_label = lv_label_create(utilities_btn);
  lv_label_set_text(utilities_label, "Utilities");
  lv_obj_set_style_text_font(utilities_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(utilities_label, COLOR_BLACK, 0);
  lv_obj_center(utilities_label);

  // Settings button
  settings_btn = lv_btn_create(homepage_screen);
  lv_obj_set_size(settings_btn, 300, 60);
  lv_obj_align(settings_btn, LV_ALIGN_CENTER, 0, 60);
  lv_obj_set_style_bg_color(settings_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(settings_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(settings_btn, settings_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *settings_label = lv_label_create(settings_btn);
  lv_label_set_text(settings_label, "Settings");
  lv_obj_set_style_text_font(settings_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(settings_label, COLOR_BLACK, 0);
  lv_obj_center(settings_label);
  
  // Force layout update to ensure button positions are calculated
  lv_obj_update_layout(homepage_screen);
  
  setupHomepageFocus();
  
  // Add WiFi and Battery status icons (always show, not just when WiFi connected)
  if (homepage_screen != ota_progress_screen) {
    ensureStatusIcons(homepage_screen);
  }

  showCoinInfoIcon();
}

static void favorites_btn_cb(lv_event_t * e) {
  // Smart navigation: go directly to where user needs to be
  if (favoriteCoinCount == 0) {
    // No favorites yet - take them directly to coin search to add some
    createCoinSearchPage();
  } else {
    // Has favorites - show them the favorites page
    createNewFavoritesPage();
  }
  // WiFi signal will automatically move to new screen (handled by createWiFiSignal internally)
}

static void utilities_btn_cb(lv_event_t * e) {
  createUtilitiesPage();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED && utilities_screen != ota_progress_screen) {
    ensureStatusIcons(utilities_screen);
  }
}

/* ===== Utilities Page ===== */
static bool utilities_page_initialized = false;

static void setupUtilitiesFocus() {
  if (!utilities_screen || !lv_obj_is_valid(utilities_screen)) return;

  encoderFocusBegin(utilities_screen);

  if (portfolio_btn && lv_obj_is_valid(portfolio_btn)) {
    lv_obj_t *label = lv_obj_get_child(portfolio_btn, 0);
    encoderFocusAdd(portfolio_btn, label);
  }
  if (fear_greed_btn && lv_obj_is_valid(fear_greed_btn)) {
    lv_obj_t *label = lv_obj_get_child(fear_greed_btn, 0);
    encoderFocusAdd(fear_greed_btn, label);
  }
  if (utilities_back_btn && lv_obj_is_valid(utilities_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(utilities_back_btn, 0);
    encoderFocusAdd(utilities_back_btn, label);
  }

  encoderFocusCommit(0);
}

static void createUtilitiesPage() {
  // Reuse existing screen if already initialized
  if (!utilities_page_initialized) {
    utilities_screen = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(utilities_screen, COLOR_BLACK, 0);
    lv_obj_set_scrollbar_mode(utilities_screen, LV_SCROLLBAR_MODE_OFF);
    lv_obj_clear_flag(utilities_screen, LV_OBJ_FLAG_SCROLLABLE);

    // Logo
    lv_obj_t *logo = lv_img_create(utilities_screen);
    LV_IMG_DECLARE(LumenLogo);
    lv_img_set_src(logo, &LumenLogo);
    lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
    lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

    // Title
    lv_obj_t *title_label = lv_label_create(utilities_screen);
    lv_label_set_text(title_label, "Utilities");
    lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
    lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

    // Portfolio button
    portfolio_btn = lv_btn_create(utilities_screen);
    lv_obj_set_size(portfolio_btn, 300, 60);
    lv_obj_align(portfolio_btn, LV_ALIGN_CENTER, 0, -80);
    lv_obj_set_style_bg_color(portfolio_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(portfolio_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(portfolio_btn, portfolio_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *portfolio_label = lv_label_create(portfolio_btn);
    lv_label_set_text(portfolio_label, "Portfolio");
    lv_obj_set_style_text_font(portfolio_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(portfolio_label, COLOR_BLACK, 0);
    lv_obj_center(portfolio_label);

    // Fear & Greed Index button
    fear_greed_btn = lv_btn_create(utilities_screen);
    lv_obj_set_size(fear_greed_btn, 300, 60);
    lv_obj_align(fear_greed_btn, LV_ALIGN_CENTER, 0, -10);
    lv_obj_set_style_bg_color(fear_greed_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(fear_greed_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(fear_greed_btn, fear_greed_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *fear_greed_label = lv_label_create(fear_greed_btn);
    lv_label_set_text(fear_greed_label, "Fear & Greed Index");
    lv_obj_set_style_text_font(fear_greed_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(fear_greed_label, COLOR_BLACK, 0);
    lv_obj_center(fear_greed_label);

    // Back button
    utilities_back_btn = lv_btn_create(utilities_screen);
    lv_obj_set_size(utilities_back_btn, 120, 50);
    lv_obj_align(utilities_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
    lv_obj_set_style_bg_color(utilities_back_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(utilities_back_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(utilities_back_btn, utilities_back_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *back_label = lv_label_create(utilities_back_btn);
    lv_label_set_text(back_label, "Back");
    lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
    lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
    lv_obj_center(back_label);
    
    utilities_page_initialized = true;
  }
  
  lv_scr_load(utilities_screen);

  setupUtilitiesFocus();

  showCoinInfoIcon();
}

static void utilities_back_btn_cb(lv_event_t * e) {
  lv_scr_load(homepage_screen);
  setupHomepageFocus();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(homepage_screen);
  }
}

/* ===== Fear & Greed Index Page ===== */
static bool fear_greed_page_initialized = false;

static String getFearGreedClassification(int value) {
  if (value >= 0 && value <= 24) return "Extreme Fear";
  else if (value >= 25 && value <= 49) return "Fear";
  else if (value >= 50 && value <= 74) return "Greed";
  else if (value >= 75 && value <= 100) return "Extreme Greed";
  return "Unknown";
}

static void fetchFearGreedData() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[FearGreed] WiFi not connected");
    fg_current_classification = "No WiFi Connection";
    return;
  }

  HTTPClient http;
  // Use Alternative.me API (reliable and free)
  String url = "https://api.alternative.me/fng/?limit=8";
  http.begin(url);
  http.setTimeout(15000);

  int httpCode = http.GET();
  Serial.printf("[FearGreed] HTTP Response Code: %d\n", httpCode);

  if (httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    Serial.printf("[FearGreed] Payload size: %d bytes\n", payload.length());
    Serial.printf("[FearGreed] Raw response (first 500 chars): %s\n", payload.substring(0, 500).c_str());

    DynamicJsonDocument doc(4096);
    DeserializationError error = deserializeJson(doc, payload);

    if (!error) {
      JsonArray data = doc["data"];

      if (data.size() > 0) {
        Serial.println("[FearGreed] === Alternative.me API Data ===");
        for (int i = 0; i < data.size() && i < 8; i++) {
          const char* valStr = data[i]["value"];
          const char* timestamp = data[i]["timestamp"];
          Serial.printf("[FearGreed] [%d] value='%s', timestamp=%s\n", i, valStr, timestamp);
        }
        Serial.println("[FearGreed] ====================");

        // Current value (most recent, index 0) - parse as STRING
        const char* currentValStr = data[0]["value"];
        fg_current_value = atoi(currentValStr);
        fg_current_classification = getFearGreedClassification(fg_current_value);
        Serial.printf("[FearGreed]  Current: %d - %s\n", fg_current_value, fg_current_classification.c_str());

        // Yesterday (index 1)
        if (data.size() > 1) {
          const char* yesterdayValStr = data[1]["value"];
          fg_yesterday_value = atoi(yesterdayValStr);
          fg_yesterday_classification = getFearGreedClassification(fg_yesterday_value);
          Serial.printf("[FearGreed]  Yesterday: %d - %s\n", fg_yesterday_value, fg_yesterday_classification.c_str());
        }

        // Last week (index 7 for 7 days ago)
        if (data.size() > 7) {
          const char* weekValStr = data[7]["value"];
          fg_last_week_value = atoi(weekValStr);
          fg_last_week_classification = getFearGreedClassification(fg_last_week_value);
          Serial.printf("[FearGreed]  Last Week: %d - %s\n", fg_last_week_value, fg_last_week_classification.c_str());
        }
      } else {
        Serial.println("[FearGreed] No data in response");
        fg_current_classification = "No Data";
      }
    } else {
      Serial.printf("[FearGreed] JSON Parse Error: %s\n", error.c_str());
      fg_current_classification = "Parse Error";
    }
  } else {
    Serial.printf("[FearGreed] HTTP Error: %d\n", httpCode);
    fg_current_classification = "API Error";
  }

  http.end();
}

// Removed - arcs are static and styled during creation

static void updateFearGreedGauge() {
  // Update triangle indicator position INSIDE the arc, pointing OUTWARD towards the current level
  if (fear_greed_triangle && lv_obj_is_valid(fear_greed_triangle)) {
    // FIRST: Make sure triangle is visible and on top
    lv_obj_move_foreground(fear_greed_triangle);
    lv_obj_clear_flag(fear_greed_triangle, LV_OBJ_FLAG_HIDDEN);
    
    if (fg_current_value >= 0 && fg_current_value <= 100) {
      // Convert value (0-100) to angle (0-180 degrees)
      // 0 = bottom-left (red, 180), 100 = bottom-right (green, 0)
      // LVGL: 0 = top, 90 = right, 180 = bottom, 270 = left
      // For bottom semi-circle: 0 = 180 (left), 100 = 0 (right)
      float angle_deg = 180.0f - (fg_current_value * 180.0f) / 100.0f;

      // Position triangle INSIDE the arc (at inner radius, pointing OUTWARD towards the arc)
      const int radius = 100;  // Inner radius of the arc
      float rad = (angle_deg * 3.14159f) / 180.0f;

      // Calculate position on the arc
      // For LVGL: 0 = top, so cos gives horizontal offset, sin gives vertical offset
      int x_offset = (int)(radius * cosf(rad));
      int y_offset = -(int)(radius * sinf(rad));  // Negative because y increases downward

      // Position triangle at the calculated point (center_y_offset = 50)
      lv_obj_align(fear_greed_triangle, LV_ALIGN_CENTER, x_offset, 50 + y_offset);

      // Rotate triangle to point OUTWARD towards the arc (towards the current level)
      // Triangle is drawn pointing right (0)
      // To point outward (in the direction of angle_deg), we rotate by angle_deg - 90
      // This makes it point perpendicular to the radius, outward towards the arc
      int rotation_angle = (int)angle_deg - 90;  // Point outward towards the arc
      lv_obj_set_style_transform_angle(fear_greed_triangle, rotation_angle * 10, 0);  // LVGL uses 0.1 degree units
      
      // Get label size for pivot point (center of label)
      lv_coord_t label_w = lv_obj_get_width(fear_greed_triangle);
      lv_coord_t label_h = lv_obj_get_height(fear_greed_triangle);
      if (label_w > 0 && label_h > 0) {
        lv_obj_set_style_transform_pivot_x(fear_greed_triangle, label_w / 2, 0);
        lv_obj_set_style_transform_pivot_y(fear_greed_triangle, label_h / 2, 0);
      }
      
      // Invalidate to ensure triangle is redrawn
      lv_obj_invalidate(fear_greed_triangle);
    } else {
      // If no valid value, position at center for debugging
      lv_obj_align(fear_greed_triangle, LV_ALIGN_CENTER, 0, 0);
      lv_obj_set_style_transform_angle(fear_greed_triangle, 0, 0);
      lv_obj_invalidate(fear_greed_triangle);
    }
  }
  
  // Update number color based on current fear level
  if (fear_greed_value_label && lv_obj_is_valid(fear_greed_value_label)) {
    lv_color_t number_color;
    if (fg_current_value >= 0 && fg_current_value <= 100) {
      // Determine which segment (0-6) the value falls into
      int segment = (fg_current_value * 7) / 101;  // 0-6 based on value 0-100
      if (segment > 6) segment = 6;
      
      // Get color from segment_colors array (same as arc colors)
      lv_color_t segment_colors[7] = {
        lv_color_make(246, 70, 93),    // 0. Red
        lv_color_make(246, 120, 93),   // 1. Red-Orange
        lv_color_make(246, 180, 93),   // 2. Orange
        lv_color_make(246, 235, 93),   // 3. Yellow-Orange
        lv_color_make(180, 220, 110),  // 4. Yellow-Green
        lv_color_make(100, 210, 120),  // 5. Light Green
        lv_color_make(14, 203, 129)     // 6. Green
      };
      number_color = segment_colors[segment];
    } else {
      number_color = COLOR_WHITE;  // Default white if invalid
    }
    lv_obj_set_style_text_color(fear_greed_value_label, number_color, 0);
  }
}

static void setupFearGreedFocus() {
  if (!fear_greed_screen || !lv_obj_is_valid(fear_greed_screen)) return;

  encoderFocusBegin(fear_greed_screen);

  if (fear_greed_back_btn && lv_obj_is_valid(fear_greed_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(fear_greed_back_btn, 0);
    encoderFocusAdd(fear_greed_back_btn, label);
  }

  encoderFocusCommit(0);
}

static void createFearGreedPage() {
  // Reuse existing screen if already initialized
  if (!fear_greed_page_initialized) {
    fear_greed_screen = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(fear_greed_screen, COLOR_BLACK, 0);
    lv_obj_set_scrollbar_mode(fear_greed_screen, LV_SCROLLBAR_MODE_OFF);
    lv_obj_clear_flag(fear_greed_screen, LV_OBJ_FLAG_SCROLLABLE);

    // Logo
    lv_obj_t *logo = lv_img_create(fear_greed_screen);
    LV_IMG_DECLARE(LumenLogo);
    lv_img_set_src(logo, &LumenLogo);
    lv_img_set_zoom(logo, 102);
    lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

    // Title
    lv_obj_t *title_label = lv_label_create(fear_greed_screen);
    lv_label_set_text(title_label, "Fear & Greed Index");
    lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
    lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

    // Create 7 LVGL arcs for clean rendering (like buttons)
    const int arc_size = 300;  // Diameter of the arc
    const int arc_thickness = 30;  // Thickness of each segment
    const int center_y_offset = 50;  // Moved down 50 pixels

    // Define 7 solid colors: Red on LEFT, Green on RIGHT
    lv_color_t segment_colors[7] = {
      lv_color_make(246, 70, 93),    // 0. Red (left)
      lv_color_make(246, 120, 93),   // 1. Red-Orange
      lv_color_make(246, 180, 93),   // 2. Orange
      lv_color_make(246, 235, 93),   // 3. Yellow-Orange
      lv_color_make(180, 220, 110),  // 4. Yellow-Green
      lv_color_make(100, 210, 120),  // 5. Light Green
      lv_color_make(14, 203, 129)    // 6. Green (right)
    };

    // Each segment covers 180/7 = ~25.7 degrees
    // CORRECTED: Red on LEFT, Green on RIGHT, flat edge on BOTTOM
    // LVGL: 0 = top, 90 = right, 180 = bottom, 270 = left
    // For bottom semi-circle: start at 180 (bottom-left/red), end at 0 (top-right/green)
    float degrees_per_segment = 180.0f / 7.0f;

    for (int seg = 0; seg < 7; seg++) {
      fear_greed_arcs[seg] = lv_arc_create(fear_greed_screen);
      lv_obj_set_size(fear_greed_arcs[seg], arc_size, arc_size);
      lv_obj_align(fear_greed_arcs[seg], LV_ALIGN_CENTER, 0, center_y_offset);

      // Bottom semi-circle: Red on LEFT, Green on RIGHT
      // LVGL: 0 = top, 90 = right, 180 = bottom, 270 = left
      // For bottom semi-circle: start at 180 (bottom-left/red), end at 0 (top-right/green)
      // Segment 0 = Red (left), Segment 6 = Green (right)
      // Calculate angles: 180 (left) to 0 (right), going counter-clockwise
      float start_angle = 180.0f - (seg + 1) * degrees_per_segment;  // Start from 180 (left/red)
      float end_angle = 180.0f - seg * degrees_per_segment;

      lv_arc_set_range(fear_greed_arcs[seg], 0, 360);
      // Flip vertically: use 360 - angles to flip upside down (flat edge on bottom)
      lv_arc_set_angles(fear_greed_arcs[seg], 360 - end_angle, 360 - start_angle);

      // Use INDICATOR part for the visible colored arc segments (like progress bars)
      lv_obj_set_style_arc_width(fear_greed_arcs[seg], arc_thickness, LV_PART_INDICATOR);
      lv_obj_set_style_arc_color(fear_greed_arcs[seg], segment_colors[seg], LV_PART_INDICATOR);
      lv_obj_set_style_arc_opa(fear_greed_arcs[seg], LV_OPA_COVER, LV_PART_INDICATOR);

      // Make MAIN part (background arc) transparent
      lv_obj_set_style_arc_width(fear_greed_arcs[seg], arc_thickness, LV_PART_MAIN);
      lv_obj_set_style_arc_opa(fear_greed_arcs[seg], LV_OPA_TRANSP, LV_PART_MAIN);
      lv_obj_set_style_bg_opa(fear_greed_arcs[seg], LV_OPA_TRANSP, LV_PART_MAIN);

      // Knob completely invisible
      lv_obj_set_style_bg_opa(fear_greed_arcs[seg], LV_OPA_TRANSP, LV_PART_KNOB);

      lv_obj_clear_flag(fear_greed_arcs[seg], LV_OBJ_FLAG_CLICKABLE);
    }

    // Create triangle indicator - using a simple label with ">" character
    // Create AFTER arcs so it appears on top (z-order)
    fear_greed_triangle = lv_label_create(fear_greed_screen);
    lv_label_set_text(fear_greed_triangle, ">");  // Simple right arrow
    lv_obj_set_style_text_color(fear_greed_triangle, COLOR_WHITE, 0);
    lv_obj_set_style_text_font(fear_greed_triangle, &poppins_medium_20, 0);
    lv_obj_clear_flag(fear_greed_triangle, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_clear_flag(fear_greed_triangle, LV_OBJ_FLAG_HIDDEN);  // Ensure it's not hidden
    lv_obj_set_style_bg_opa(fear_greed_triangle, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_opa(fear_greed_triangle, LV_OPA_TRANSP, 0);
    lv_obj_set_style_pad_all(fear_greed_triangle, 0, 0);
    
    // Start at center position (will be updated by updateFearGreedGauge)
    lv_obj_align(fear_greed_triangle, LV_ALIGN_CENTER, 0, 0);
    
    // Set pivot point for zoom and rotation (center of label)
    // We'll update this in updateFearGreedGauge once label size is known, but set initial values
    lv_obj_set_style_transform_pivot_x(fear_greed_triangle, 10, 0);  // Approximate center
    lv_obj_set_style_transform_pivot_y(fear_greed_triangle, 10, 0);
    
    // Scale up 15% using transform zoom (115 = 115% = 15% larger)
    lv_obj_set_style_transform_zoom(fear_greed_triangle, 115, 0);
    
    // Bring triangle to front (top of z-order) so it appears above arcs
    lv_obj_move_foreground(fear_greed_triangle);

    // Current value label (in the middle of gauge)
    fear_greed_value_label = lv_label_create(fear_greed_screen);
    lv_label_set_text(fear_greed_value_label, "0");
    lv_obj_set_style_text_font(fear_greed_value_label, &poppins_semibold_64, 0);
    lv_obj_set_style_text_color(fear_greed_value_label, COLOR_WHITE, 0);
    lv_obj_align(fear_greed_value_label, LV_ALIGN_CENTER, 0, 5);

    // Classification text (below gauge)
    fear_greed_text_label = lv_label_create(fear_greed_screen);
    lv_label_set_text(fear_greed_text_label, "Loading...");
    lv_obj_set_style_text_font(fear_greed_text_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(fear_greed_text_label, COLOR_WHITE, 0);
    lv_obj_align(fear_greed_text_label, LV_ALIGN_CENTER, 0, 80);

    // Yesterday stats
    fear_greed_yesterday_label = lv_label_create(fear_greed_screen);
    lv_label_set_text(fear_greed_yesterday_label, "Yesterday: --");
    lv_obj_set_style_text_font(fear_greed_yesterday_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(fear_greed_yesterday_label, COLOR_GRAY, 0);
    lv_obj_align(fear_greed_yesterday_label, LV_ALIGN_CENTER, 0, 110);

    // Last week stats
    fear_greed_week_label = lv_label_create(fear_greed_screen);
    lv_label_set_text(fear_greed_week_label, "Last Week: --");
    lv_obj_set_style_text_font(fear_greed_week_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(fear_greed_week_label, COLOR_GRAY, 0);
    lv_obj_align(fear_greed_week_label, LV_ALIGN_CENTER, 0, 135);

    // Back button
    fear_greed_back_btn = lv_btn_create(fear_greed_screen);
    lv_obj_set_size(fear_greed_back_btn, 120, 50);
    lv_obj_align(fear_greed_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
    lv_obj_set_style_bg_color(fear_greed_back_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(fear_greed_back_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(fear_greed_back_btn, fear_greed_back_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *back_label = lv_label_create(fear_greed_back_btn);
    lv_label_set_text(back_label, "Back");
    lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
    lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
    lv_obj_center(back_label);
    
    fear_greed_page_initialized = true;
  }
  
  lv_scr_load(fear_greed_screen);

  // Fetch data and update display
  fetchFearGreedData();
  updateFearGreedGauge();
  
  // Update labels with fetched data
  if (fear_greed_value_label && lv_obj_is_valid(fear_greed_value_label)) {
    char buf[16];
    snprintf(buf, sizeof(buf), "%d", fg_current_value);
    lv_label_set_text(fear_greed_value_label, buf);
    
    // Color the number based on current fear level (match the segment color)
    lv_color_t number_color;
    if (fg_current_value >= 0 && fg_current_value <= 100) {
      // Determine which segment (0-6) the value falls into
      int segment = (fg_current_value * 7) / 101;  // 0-6 based on value 0-100
      if (segment > 6) segment = 6;
      
      // Get color from segment_colors array
      lv_color_t segment_colors[7] = {
        lv_color_make(246, 70, 93),    // 0. Red
        lv_color_make(246, 120, 93),   // 1. Red-Orange
        lv_color_make(246, 180, 93),   // 2. Orange
        lv_color_make(246, 235, 93),   // 3. Yellow-Orange
        lv_color_make(180, 220, 110),  // 4. Yellow-Green
        lv_color_make(100, 210, 120),  // 5. Light Green
        lv_color_make(14, 203, 129)     // 6. Green
      };
      number_color = segment_colors[segment];
    } else {
      number_color = COLOR_WHITE;  // Default white if invalid
    }
    lv_obj_set_style_text_color(fear_greed_value_label, number_color, 0);
  }
  
  if (fear_greed_text_label && lv_obj_is_valid(fear_greed_text_label)) {
    lv_label_set_text(fear_greed_text_label, fg_current_classification.c_str());
  }
  
  if (fear_greed_yesterday_label && lv_obj_is_valid(fear_greed_yesterday_label)) {
    char buf[64];
    snprintf(buf, sizeof(buf), "Yesterday: %d (%s)", fg_yesterday_value, fg_yesterday_classification.c_str());
    lv_label_set_text(fear_greed_yesterday_label, buf);
  }
  
  if (fear_greed_week_label && lv_obj_is_valid(fear_greed_week_label)) {
    char buf[64];
    snprintf(buf, sizeof(buf), "Last Week: %d (%s)", fg_last_week_value, fg_last_week_classification.c_str());
    lv_label_set_text(fear_greed_week_label, buf);
  }

  setupFearGreedFocus();

  if (WiFi.status() == WL_CONNECTED) {
    ensureStatusIcons(fear_greed_screen);
  }

  showCoinInfoIcon();
}

static void fear_greed_btn_cb(lv_event_t * e) {
  createFearGreedPage();
}

static void fear_greed_back_btn_cb(lv_event_t * e) {
  lv_scr_load(utilities_screen);
  setupUtilitiesFocus();
  if (WiFi.status() == WL_CONNECTED) {
    ensureStatusIcons(utilities_screen);
  }
}

static void settings_btn_cb(lv_event_t * e) {
  createSettingsPage();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED && settings_screen != ota_progress_screen) {
    ensureStatusIcons(settings_screen);
  }
}

/* ===== Crypto Logo Helper ===== */
// Removed - coin icons no longer used
static void addCryptoLogo(lv_obj_t *btn, int pairIndex) {
  // Function disabled - coin logos removed from project
}

/* ===== Coin Search & Favorites System ===== */

// Load favorite coins from Preferences
static void loadFavoriteCoins() {
  favoriteCoinCount = coinPrefs.getInt("coinCount", 0);
  if (favoriteCoinCount > MAX_FAVORITE_COINS) favoriteCoinCount = MAX_FAVORITE_COINS;
  
  for (int i = 0; i < favoriteCoinCount; i++) {
    String key = "coin" + String(i);
    favoriteCoinSymbols[i] = coinPrefs.getString(key.c_str(), "");
  }
  Serial.printf("Loaded %d favorite coins from storage\n", favoriteCoinCount);
}

// Save favorite coins to Preferences
static void saveFavoriteCoins() {
  coinPrefs.putInt("coinCount", favoriteCoinCount);
  for (int i = 0; i < favoriteCoinCount; i++) {
    String key = "coin" + String(i);
    coinPrefs.putString(key.c_str(), favoriteCoinSymbols[i]);
  }
  Serial.printf("Saved %d favorite coins to storage\n", favoriteCoinCount);
}

/* ===== Portfolio Data ===== */
static String sanitizeBaseCoin(const String& symbol) {
  if (symbol.endsWith("USDT")) {
    return symbol.substring(0, symbol.length() - 4);
  }
  return symbol;
}

static bool isCoinInPortfolio(const String& symbol) {
  for (int i = 0; i < portfolioCoinCount; i++) {
    if (portfolioCoins[i].symbol == symbol) {
      return true;
    }
  }
  return false;
}
static void loadPortfolioCoins() {
  portfolioCoinCount = portfolioPrefs.getInt("count", 0);
  if (portfolioCoinCount < 0) portfolioCoinCount = 0;
  if (portfolioCoinCount > MAX_PORTFOLIO_COINS) {
    portfolioCoinCount = MAX_PORTFOLIO_COINS;
  }

  for (int i = 0; i < portfolioCoinCount; i++) {
    String symKey = "sym" + String(i);
    String amtKey = "amt" + String(i);
    String symbol = portfolioPrefs.getString(symKey.c_str(), "");
    float amount = portfolioPrefs.getFloat(amtKey.c_str(), 0.0f);

    if (symbol.length() == 0) {
      portfolioCoinCount = i;
      break;
    }

    portfolioCoins[i].symbol = symbol;
    portfolioCoins[i].baseCoin = sanitizeBaseCoin(symbol);
    portfolioCoins[i].amount = amount;
    portfolioCoins[i].last_price = 0.0f;
    portfolioCoins[i].last_price_update = 0;
  }

  Serial.printf("Loaded %d portfolio coins from storage\n", portfolioCoinCount);
  updatePortfolioTotal();
}

static void savePortfolioCoins() {
  portfolioPrefs.putInt("count", portfolioCoinCount);
  for (int i = 0; i < portfolioCoinCount; i++) {
    String symKey = "sym" + String(i);
    String amtKey = "amt" + String(i);
    portfolioPrefs.putString(symKey.c_str(), portfolioCoins[i].symbol);
    portfolioPrefs.putFloat(amtKey.c_str(), portfolioCoins[i].amount);
  }

  for (int i = portfolioCoinCount; i < MAX_PORTFOLIO_COINS; i++) {
    String symKey = "sym" + String(i);
    String amtKey = "amt" + String(i);
    portfolioPrefs.remove(symKey.c_str());
    portfolioPrefs.remove(amtKey.c_str());
  }

  Serial.printf("Saved %d portfolio coins to storage\n", portfolioCoinCount);
}
static void formatUsdWithCommas(double value, char* buffer, size_t bufferSize) {
  bool isNegative = value < 0.0;
  double absValue = isNegative ? -value : value;
  unsigned long long wholePart = static_cast<unsigned long long>(absValue);
  double fraction = absValue - wholePart;
  int cents = static_cast<int>(round(fraction * 100.0));
  if (cents >= 100) {
    wholePart += 1;
    cents = 0;
  }

  char wholeStr[32];
  int idx = sizeof(wholeStr) - 1;
  wholeStr[idx] = '\0';
  int digitCount = 0;
  if (wholePart == 0) {
    wholeStr[--idx] = '0';
  } else {
    while (wholePart > 0 && idx > 0) {
      if (digitCount == 3) {
        wholeStr[--idx] = ',';
        digitCount = 0;
      }
      wholeStr[--idx] = '0' + (wholePart % 10);
      wholePart /= 10;
      digitCount++;
    }
  }

  snprintf(buffer, bufferSize, "%s%s.%02d",
           isNegative ? "-" : "",
           &wholeStr[idx],
           cents);
}

static void updatePortfolioTotal() {
  double total = 0.0;
  for (int i = 0; i < portfolioCoinCount; i++) {
    total += static_cast<double>(portfolioCoins[i].amount) * static_cast<double>(portfolioCoins[i].last_price);
  }
  portfolio_total_value = static_cast<float>(total);

  if (portfolio_total_label && lv_obj_is_valid(portfolio_total_label)) {
    char buf[48];
    formatUsdWithCommas(total, buf, sizeof(buf));
    char display[60];
    snprintf(display, sizeof(display), "$%s", buf);
    lv_label_set_text(portfolio_total_label, display);

    double previous = portfolio_last_total_displayed;
    portfolio_last_total_displayed = portfolio_total_value;
    const double threshold = 0.01;

    if (portfolio_total_revert_timer) {
      lv_timer_del(portfolio_total_revert_timer);
      portfolio_total_revert_timer = nullptr;
    }

    if (fabs(total - previous) >= threshold) {
      lv_anim_del(portfolio_total_label, NULL);

      lv_color_t target_color = (total > previous) ? COLOR_GREEN : COLOR_RED;
      lv_obj_set_style_text_color(portfolio_total_label, target_color, 0);
      lv_obj_set_style_opa(portfolio_total_label, 200, 0);

      lv_anim_t fade_in;
      lv_anim_init(&fade_in);
      lv_anim_set_var(&fade_in, portfolio_total_label);
      lv_anim_set_values(&fade_in, 200, 255);
      lv_anim_set_time(&fade_in, 200);
      lv_anim_set_exec_cb(&fade_in, [](void *var, int32_t v) {
        lv_obj_set_style_opa((lv_obj_t*)var, (lv_opa_t)v, 0);
      });
      lv_anim_start(&fade_in);

      portfolio_total_revert_timer = lv_timer_create([](lv_timer_t *timer) {
        if (portfolio_total_label && lv_obj_is_valid(portfolio_total_label)) {
          lv_obj_set_style_text_color(portfolio_total_label, COLOR_WHITE, 0);

          lv_anim_t fade_back;
          lv_anim_init(&fade_back);
          lv_anim_set_var(&fade_back, portfolio_total_label);
          lv_anim_set_values(&fade_back, 200, 255);
          lv_anim_set_time(&fade_back, 200);
          lv_anim_set_exec_cb(&fade_back, [](void *var, int32_t v) {
            lv_obj_set_style_opa((lv_obj_t*)var, (lv_opa_t)v, 0);
          });
          lv_anim_start(&fade_back);
        }
        lv_timer_del(timer);
        portfolio_total_revert_timer = nullptr;
      }, 2000, NULL);
      lv_timer_set_repeat_count(portfolio_total_revert_timer, 1);
    } else {
      lv_obj_set_style_text_color(portfolio_total_label, COLOR_WHITE, 0);
      lv_obj_set_style_opa(portfolio_total_label, 255, 0);
    }
  } else {
    portfolio_last_total_displayed = portfolio_total_value;
  }
}

static bool fetchPortfolioPrice(int index, bool force) {
  if (index < 0 || index >= portfolioCoinCount) return false;
  if (portfolioCoins[index].symbol.length() == 0) return false;
  if (!force && portfolioCoins[index].last_price_update != 0 &&
      millis() - portfolioCoins[index].last_price_update < PORTFOLIO_PRICE_REFRESH_MS) {
    return true;
  }
  if (WiFi.status() != WL_CONNECTED) {
    return false;
  }

  HTTPClient http;
  String url = "https://api.binance.com/api/v3/ticker/price?symbol=" + portfolioCoins[index].symbol;
  if (!http.begin(url)) {
    Serial.printf("[Portfolio] Failed to begin HTTP for %s\n", portfolioCoins[index].symbol.c_str());
    return false;
  }

  bool success = false;
  int httpCode = http.GET();
  if (httpCode == HTTP_CODE_OK) {
    DynamicJsonDocument doc(256);
    DeserializationError err = deserializeJson(doc, http.getStream());
    if (!err) {
      float price = doc["price"].as<float>();
      if (price > 0.0f) {
        portfolioCoins[index].last_price = price;
        portfolioCoins[index].last_price_update = millis();
        success = true;
      }
    } else {
      Serial.printf("[Portfolio] JSON parse failed for %s: %s\n",
                    portfolioCoins[index].symbol.c_str(), err.c_str());
    }
  } else {
    Serial.printf("[Portfolio] HTTP error %d for %s\n", httpCode, portfolioCoins[index].symbol.c_str());
  }
  http.end();

  return success;
}

static void ensurePortfolioPrices(bool force) {
  if (portfolioCoinCount == 0) return;
  if (WiFi.status() != WL_CONNECTED) return;

  if (force) {
    for (int i = 0; i < portfolioCoinCount; i++) {
      fetchPortfolioPrice(i, true);
    }
  } else {
    if (portfolio_next_price_index >= portfolioCoinCount) {
      portfolio_next_price_index = 0;
    }

    int start_index = portfolio_next_price_index;
    bool fetched = false;

    do {
      if (fetchPortfolioPrice(portfolio_next_price_index, false)) {
        fetched = true;
        portfolio_next_price_index = (portfolio_next_price_index + 1) % portfolioCoinCount;
        break;
      }
      portfolio_next_price_index = (portfolio_next_price_index + 1) % portfolioCoinCount;
    } while (portfolio_next_price_index != start_index);

    if (!fetched) {
      portfolio_next_price_index = (portfolio_next_price_index + 1) % portfolioCoinCount;
    }
  }

  updatePortfolioTotal();
  last_portfolio_price_check = millis();
}
static void addCoinToPortfolio(const String& symbol, const String& baseCoin) {
  if (symbol.length() == 0) return;
  if (isCoinInPortfolio(symbol)) {
    Serial.printf("[Portfolio] %s already added\n", symbol.c_str());
    return;
  }
  if (portfolioCoinCount >= MAX_PORTFOLIO_COINS) {
    Serial.println("[Portfolio] Maximum coins reached");
    return;
  }

  PortfolioCoin &coin = portfolioCoins[portfolioCoinCount];
  coin.symbol = symbol;
  coin.baseCoin = baseCoin;
  if (coin.baseCoin.length() == 0) {
    coin.baseCoin = sanitizeBaseCoin(symbol);
  }
  coin.amount = 0.0f;
  coin.last_price = 0.0f;
  coin.last_price_update = 0;

  portfolioCoinCount++;
  if (portfolio_next_price_index >= portfolioCoinCount) {
    portfolio_next_price_index = 0;
  }
  savePortfolioCoins();
  fetchPortfolioPrice(portfolioCoinCount - 1, true);
  last_portfolio_price_check = millis();
  updatePortfolioTotal();
}

static void removePortfolioCoin(int index) {
  if (index < 0 || index >= portfolioCoinCount) return;

  for (int i = index; i < portfolioCoinCount - 1; i++) {
    portfolioCoins[i] = portfolioCoins[i + 1];
  }
  portfolioCoinCount--;
  if (portfolioCoinCount < 0) portfolioCoinCount = 0;
  if (portfolio_next_price_index >= portfolioCoinCount) {
    portfolio_next_price_index = 0;
  }

  savePortfolioCoins();
  updatePortfolioTotal();
}

static void updatePortfolioEmptyState() {
  if (!portfolio_list || !lv_obj_is_valid(portfolio_list)) return;

  if (portfolio_empty_label && !lv_obj_is_valid(portfolio_empty_label)) {
    portfolio_empty_label = nullptr;
  }

  if (portfolioCoinCount == 0) {
    if (!portfolio_empty_label) {
      portfolio_empty_label = lv_label_create(portfolio_list);
      lv_label_set_text(portfolio_empty_label, "No coins added yet.\nUse Manage Portfolio to add some.");
      lv_obj_set_style_text_font(portfolio_empty_label, &poppins_medium_20, 0);
      lv_obj_set_style_text_color(portfolio_empty_label, COLOR_WHITE, 0);
      lv_obj_set_style_text_align(portfolio_empty_label, LV_TEXT_ALIGN_CENTER, 0);
      lv_obj_align(portfolio_empty_label, LV_ALIGN_CENTER, 0, 0);
    }
    lv_obj_clear_flag(portfolio_empty_label, LV_OBJ_FLAG_HIDDEN);
  } else if (portfolio_empty_label) {
    lv_obj_add_flag(portfolio_empty_label, LV_OBJ_FLAG_HIDDEN);
  }
}

static void refreshPortfolioList() {
  if (!portfolio_list || !lv_obj_is_valid(portfolio_list)) return;

  lv_obj_clean(portfolio_list);
  portfolio_empty_label = nullptr;

  if (portfolioCoinCount == 0) {
    updatePortfolioEmptyState();
    return;
  }

  updatePortfolioEmptyState();

  const int button_width = 360;
  const int button_height = 60;
  const int v_spacing = 12;
  const int start_x = (400 - button_width) / 2;
  const int start_y = 10;

  for (int i = 0; i < portfolioCoinCount; i++) {
    lv_obj_t *btn = lv_btn_create(portfolio_list);
    lv_obj_set_size(btn, button_width, button_height);
    int y = start_y + (i * (button_height + v_spacing));
    lv_obj_set_pos(btn, start_x, y);
    lv_obj_set_style_bg_color(btn, lv_color_make(10, 10, 10), 0);
    lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
    lv_obj_set_style_shadow_width(btn, 0, 0);
    lv_obj_set_style_border_width(btn, 0, 0);
    lv_obj_set_user_data(btn, (void*)(intptr_t)i);

    lv_obj_add_event_cb(btn, [](lv_event_t *e) {
      lv_obj_t *obj = lv_event_get_target(e);
      int idx = (int)(intptr_t)lv_obj_get_user_data(obj);
      if (idx >= 0 && idx < portfolioCoinCount) {
        showPortfolioCoinPopup(idx);
      }
    }, LV_EVENT_CLICKED, NULL);

    String baseCoin = portfolioCoins[i].baseCoin;
    if (baseCoin.endsWith("USDT")) {
      baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
    }

    lv_obj_t *name_label = lv_label_create(btn);
    lv_label_set_text(name_label, baseCoin.c_str());
    lv_obj_set_style_text_font(name_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(name_label, COLOR_WHITE, 0);
    lv_obj_align(name_label, LV_ALIGN_LEFT_MID, 15, 0);

    String amountStr = String(portfolioCoins[i].amount, 4);
    amountStr.trim();
    if (amountStr.indexOf('.') >= 0) {
      while (amountStr.endsWith("0")) amountStr.remove(amountStr.length() - 1);
      if (amountStr.endsWith(".")) amountStr.remove(amountStr.length() - 1);
    }
    if (amountStr.length() == 0) amountStr = "0";

    lv_obj_t *amount_label = lv_label_create(btn);
    lv_label_set_text(amount_label, amountStr.c_str());
    lv_obj_set_style_text_font(amount_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(amount_label, COLOR_WHITE, 0);
    lv_obj_set_style_text_align(amount_label, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_align(amount_label, LV_ALIGN_CENTER, 0, 0);

    double value = static_cast<double>(portfolioCoins[i].amount) * static_cast<double>(portfolioCoins[i].last_price);
    char value_buf[48];
    formatUsdWithCommas(value, value_buf, sizeof(value_buf));
    char value_display[56];
    snprintf(value_display, sizeof(value_display), "$%s", value_buf);

    lv_obj_t *value_label = lv_label_create(btn);
    lv_label_set_text(value_label, value_display);
    lv_obj_set_style_text_font(value_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(value_label, COLOR_WHITE, 0);
    lv_obj_set_style_text_align(value_label, LV_TEXT_ALIGN_RIGHT, 0);
    lv_label_set_long_mode(value_label, LV_LABEL_LONG_CLIP);
    lv_obj_align(value_label, LV_ALIGN_RIGHT_MID, -15, 0);
  }

  // Spacer to allow scrolling bottom items toward screen center
  lv_obj_t *bottom_spacer = lv_obj_create(portfolio_list);
  lv_obj_set_size(bottom_spacer, button_width, 160);
  lv_obj_set_style_bg_opa(bottom_spacer, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(bottom_spacer, 0, 0);
  lv_obj_clear_flag(bottom_spacer, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(bottom_spacer, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_set_pos(bottom_spacer, start_x, start_y + (portfolioCoinCount * (button_height + v_spacing)));
}

static void updatePortfolioPopupContent() {
  if (portfolio_selected_index < 0 || portfolio_selected_index >= portfolioCoinCount) return;
  if (!portfolio_popup || !lv_obj_is_valid(portfolio_popup)) return;

  if (portfolio_popup_title && lv_obj_is_valid(portfolio_popup_title)) {
    String baseCoin = portfolioCoins[portfolio_selected_index].baseCoin;
    if (baseCoin.endsWith("USDT")) {
      baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
    }
    lv_label_set_text(portfolio_popup_title, baseCoin.c_str());
  }

  if (portfolio_popup_amount && lv_obj_is_valid(portfolio_popup_amount)) {
    String amountStr = String(portfolioCoins[portfolio_selected_index].amount, 4);
    amountStr.trim();
    if (amountStr.indexOf('.') >= 0) {
      while (amountStr.endsWith("0")) amountStr.remove(amountStr.length() - 1);
      if (amountStr.endsWith(".")) amountStr.remove(amountStr.length() - 1);
    }
    if (amountStr.length() == 0) amountStr = "0";
    lv_label_set_text(portfolio_popup_amount, amountStr.c_str());
  }

  if (portfolio_amount_ta && lv_obj_is_valid(portfolio_amount_ta)) {
    if (portfolio_amount_input_started) {
      const char *txt = lv_textarea_get_text(portfolio_amount_ta);
      if (!txt || txt[0] == '\0') {
        lv_textarea_set_text(portfolio_amount_ta, "");
        lv_textarea_set_cursor_pos(portfolio_amount_ta, 0);
      }
    } else {
      lv_textarea_set_text(portfolio_amount_ta, "");
      lv_textarea_set_cursor_pos(portfolio_amount_ta, 0);
    }
  }
}
static void hidePortfolioAmountKeyboard(bool save_value) {
  if (portfolio_amount_kb && lv_obj_is_valid(portfolio_amount_kb)) {
    lv_obj_del(portfolio_amount_kb);
  }
  portfolio_amount_kb = nullptr;
  bool input_started = portfolio_amount_input_started;

  if (save_value && portfolio_amount_ta && lv_obj_is_valid(portfolio_amount_ta) &&
      portfolio_selected_index >= 0 && portfolio_selected_index < portfolioCoinCount) {
    if (input_started) {
      const char *txt = lv_textarea_get_text(portfolio_amount_ta);
      float new_amount = String(txt).toFloat();
      portfolioCoins[portfolio_selected_index].amount = new_amount;
      savePortfolioCoins();
      updatePortfolioTotal();
      refreshPortfolioList();
    }
  }

  if (portfolio_amount_ta && lv_obj_is_valid(portfolio_amount_ta)) {
    lv_obj_del(portfolio_amount_ta);
  }
  portfolio_amount_ta = nullptr;
  portfolio_amount_input_started = false;
  if (portfolio_popup && lv_obj_is_valid(portfolio_popup)) {
    lv_obj_align(portfolio_popup, LV_ALIGN_CENTER, 0, 0);
  }
  updatePortfolioPopupContent();
}

static void showPortfolioAmountKeyboard() {
  if (portfolio_selected_index < 0 || portfolio_selected_index >= portfolioCoinCount) return;
  if (!portfolio_popup || !lv_obj_is_valid(portfolio_popup)) return;

  if (portfolio_amount_ta && lv_obj_is_valid(portfolio_amount_ta)) {
    lv_obj_del(portfolio_amount_ta);
    portfolio_amount_ta = nullptr;
  }

  portfolio_amount_input_started = false;

  portfolio_amount_ta = lv_textarea_create(portfolio_popup);
  lv_obj_set_size(portfolio_amount_ta, 1, 1);
  lv_textarea_set_one_line(portfolio_amount_ta, true);
  lv_textarea_set_max_length(portfolio_amount_ta, 16);
  lv_obj_set_style_bg_opa(portfolio_amount_ta, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(portfolio_amount_ta, 0, 0);
  lv_obj_add_flag(portfolio_amount_ta, LV_OBJ_FLAG_HIDDEN);

  lv_obj_add_event_cb(portfolio_amount_ta, [](lv_event_t *e) {
    if (!portfolio_popup_amount || !lv_obj_is_valid(portfolio_popup_amount)) return;
    lv_obj_t *ta = lv_event_get_target(e);
    const char *txt = lv_textarea_get_text(ta);
    if (!portfolio_amount_input_started) {
      if (!txt || txt[0] == '\0') {
        return;
      }
      portfolio_amount_input_started = true;
    }
    if (!txt || txt[0] == '\0') {
      lv_label_set_text(portfolio_popup_amount, "0");
    } else {
      lv_label_set_text(portfolio_popup_amount, txt);
    }
  }, LV_EVENT_VALUE_CHANGED, NULL);
  lv_textarea_set_text(portfolio_amount_ta, "");

  portfolio_amount_kb = lv_keyboard_create(lv_layer_top());
  lv_keyboard_set_mode(portfolio_amount_kb, LV_KEYBOARD_MODE_NUMBER);
  lv_keyboard_set_textarea(portfolio_amount_kb, portfolio_amount_ta);
  lv_obj_align(portfolio_amount_kb, LV_ALIGN_BOTTOM_MID, 0, 0);
  if (portfolio_popup && lv_obj_is_valid(portfolio_popup)) {
    lv_obj_align(portfolio_popup, LV_ALIGN_CENTER, 0, -90);
  }
  lv_obj_add_event_cb(portfolio_amount_kb, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_READY) {
      hidePortfolioAmountKeyboard(true);
#ifdef LV_EVENT_APPLY
    } else if (code == LV_EVENT_APPLY) {
      hidePortfolioAmountKeyboard(true);
#endif
    } else if (code == LV_EVENT_CANCEL) {
      hidePortfolioAmountKeyboard(false);
    }
  }, LV_EVENT_ALL, NULL);

  updatePortfolioPopupContent();
}

static void hidePortfolioPopup() {
  hidePortfolioAmountKeyboard(false);

  if (portfolio_popup_overlay && lv_obj_is_valid(portfolio_popup_overlay)) {
    lv_obj_del(portfolio_popup_overlay);
  }

  portfolio_popup_overlay = nullptr;
  portfolio_popup = nullptr;
  portfolio_popup_title = nullptr;
  portfolio_popup_amount = nullptr;
  portfolio_amount_btn = nullptr;
  portfolio_remove_btn = nullptr;
  portfolio_selected_index = -1;
}

static void showPortfolioCoinPopup(int index) {
  if (index < 0 || index >= portfolioCoinCount) return;

  hidePortfolioPopup();
  portfolio_selected_index = index;
  portfolio_amount_input_started = false;

  portfolio_popup_overlay = lv_obj_create(lv_layer_top());
  lv_obj_set_size(portfolio_popup_overlay, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_bg_color(portfolio_popup_overlay, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(portfolio_popup_overlay, 128, 0);
  lv_obj_set_style_border_width(portfolio_popup_overlay, 0, 0);
  lv_obj_set_style_radius(portfolio_popup_overlay, 0, 0);
  lv_obj_clear_flag(portfolio_popup_overlay, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_add_event_cb(portfolio_popup_overlay, [](lv_event_t *e) {
    if (lv_event_get_target(e) == portfolio_popup_overlay) {
      if (portfolio_amount_kb && lv_obj_is_valid(portfolio_amount_kb)) {
        hidePortfolioAmountKeyboard(false);
      } else {
        hidePortfolioPopup();
      }
    }
  }, LV_EVENT_CLICKED, NULL);

  portfolio_popup = lv_obj_create(portfolio_popup_overlay);
  lv_obj_set_size(portfolio_popup, 420, 180);
  lv_obj_align(portfolio_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(portfolio_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_radius(portfolio_popup, 15, 0);
  lv_obj_set_style_border_width(portfolio_popup, 0, 0);
  lv_obj_set_style_shadow_width(portfolio_popup, 0, 0);
  lv_obj_clear_flag(portfolio_popup, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_add_event_cb(portfolio_popup, [](lv_event_t *e) {
    lv_event_stop_bubbling(e);
  }, LV_EVENT_CLICKED, NULL);

  portfolio_popup_title = lv_label_create(portfolio_popup);
  lv_obj_set_style_text_font(portfolio_popup_title, &poppins_light_20, 0);
  lv_obj_set_style_text_color(portfolio_popup_title, COLOR_WHITE, 0);
  lv_obj_align(portfolio_popup_title, LV_ALIGN_TOP_MID, 0, 5);

  portfolio_popup_amount = lv_label_create(portfolio_popup);
  lv_obj_set_style_text_font(portfolio_popup_amount, &poppins_semibold_32, 0);
  lv_obj_set_style_text_color(portfolio_popup_amount, COLOR_WHITE, 0);
  lv_obj_align(portfolio_popup_amount, LV_ALIGN_CENTER, 0, -20);

  portfolio_amount_btn = lv_btn_create(portfolio_popup);
  lv_obj_set_size(portfolio_amount_btn, 180, 45);
  lv_obj_align(portfolio_amount_btn, LV_ALIGN_BOTTOM_LEFT, 20, -5);
  lv_obj_set_style_bg_color(portfolio_amount_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(portfolio_amount_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(portfolio_amount_btn, 0, 0);
  lv_obj_set_style_shadow_width(portfolio_amount_btn, 0, 0);
  lv_obj_add_event_cb(portfolio_amount_btn, portfolio_amount_btn_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *amount_label = lv_label_create(portfolio_amount_btn);
  lv_label_set_text(amount_label, "Edit amount");
  lv_obj_set_style_text_color(amount_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(amount_label, &poppins_medium_20, 0);
  lv_obj_center(amount_label);

  portfolio_remove_btn = lv_btn_create(portfolio_popup);
  lv_obj_set_size(portfolio_remove_btn, 153, 45);
  lv_obj_align(portfolio_remove_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -5);
  lv_obj_set_style_bg_color(portfolio_remove_btn, COLOR_RED, 0);
  lv_obj_set_style_radius(portfolio_remove_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(portfolio_remove_btn, 0, 0);
  lv_obj_set_style_shadow_width(portfolio_remove_btn, 0, 0);
  lv_obj_add_event_cb(portfolio_remove_btn, portfolio_remove_btn_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *remove_label = lv_label_create(portfolio_remove_btn);
  lv_label_set_text(remove_label, "Remove");
  lv_obj_set_style_text_color(remove_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(remove_label, &poppins_medium_20, 0);
  lv_obj_center(remove_label);

  updatePortfolioPopupContent();
}

static void portfolio_amount_btn_cb(lv_event_t * e) {
  (void)e;
  showPortfolioAmountKeyboard();
}

static void portfolio_remove_btn_cb(lv_event_t * e) {
  (void)e;
  if (portfolio_selected_index >= 0 && portfolio_selected_index < portfolioCoinCount) {
    int idx = portfolio_selected_index;
    hidePortfolioPopup();
    removePortfolioCoin(idx);
    refreshPortfolioList();
    updatePortfolioEmptyState();
  }
}

static void portfolio_btn_cb(lv_event_t * e) {
  (void)e;
  createPortfolioPage();
}
static void portfolio_manage_btn_cb(lv_event_t * e) {
  (void)e;
  createPortfolioManagePage();
}
static void portfolio_back_btn_cb(lv_event_t * e) {
  (void)e;
  if (utilities_screen && lv_obj_is_valid(utilities_screen)) {
    lv_scr_load(utilities_screen);
    setupUtilitiesFocus();
    if (WiFi.status() == WL_CONNECTED) {
      ensureStatusIcons(utilities_screen);
    }
  } else {
    createUtilitiesPage();
  }
}
static void createPortfolioPage() {
  hidePortfolioPopup();

  if (portfolio_screen && lv_obj_is_valid(portfolio_screen)) {
    lv_obj_del(portfolio_screen);
  }

  portfolio_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(portfolio_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(portfolio_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(portfolio_screen, LV_OBJ_FLAG_SCROLLABLE);

  portfolio_list = nullptr;
  portfolio_total_label = nullptr;
  portfolio_manage_btn = nullptr;
  portfolio_back_btn = nullptr;
  portfolio_empty_label = nullptr;
  portfolio_popup_overlay = nullptr;
  portfolio_popup = nullptr;
  portfolio_popup_title = nullptr;
  portfolio_popup_amount = nullptr;
  portfolio_amount_btn = nullptr;
  portfolio_remove_btn = nullptr;
  portfolio_amount_ta = nullptr;
  portfolio_amount_kb = nullptr;

  lv_scr_load(portfolio_screen);

  encoderFocusBegin(portfolio_screen);

  lv_obj_t *logo = lv_img_create(portfolio_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  lv_obj_t *title_label = lv_label_create(portfolio_screen);
  lv_label_set_text(title_label, "Portfolio");
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

  portfolio_total_label = lv_label_create(portfolio_screen);
  lv_obj_set_style_text_font(portfolio_total_label, &poppins_semibold_64, 0);
  lv_obj_set_style_text_color(portfolio_total_label, COLOR_WHITE, 0);
  lv_obj_align(portfolio_total_label, LV_ALIGN_TOP_MID, 0, 100);
  lv_label_set_text(portfolio_total_label, "$0.00");
  portfolio_last_total_displayed = portfolio_total_value;

  portfolio_list = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_list, 400, 330);
  lv_obj_align(portfolio_list, LV_ALIGN_CENTER, 0, 110);
  lv_obj_set_style_bg_color(portfolio_list, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_list, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(portfolio_list, 0, 0);
  lv_obj_set_style_outline_width(portfolio_list, 0, 0);
  lv_obj_set_style_shadow_width(portfolio_list, 0, 0);
  lv_obj_set_style_radius(portfolio_list, 0, 0);
  lv_obj_set_style_pad_all(portfolio_list, 0, 0);
  lv_obj_set_style_pad_bottom(portfolio_list, 220, 0);
  lv_obj_set_style_pad_top(portfolio_list, 0, 0);
  lv_obj_set_scrollbar_mode(portfolio_list, LV_SCROLLBAR_MODE_OFF);
  lv_obj_set_scroll_dir(portfolio_list, LV_DIR_VER);
  lv_obj_add_event_cb(portfolio_list, [](lv_event_t *e) {
    lv_obj_t *list = lv_event_get_target(e);
    lv_coord_t y = lv_obj_get_scroll_y(list);
    lv_coord_t min = lv_obj_get_scroll_top(list);
    if (y < min) {
      lv_obj_scroll_to_y(list, min, LV_ANIM_OFF);
    } else if (y > PORTFOLIO_SCROLL_MAX) {
      lv_obj_scroll_to_y(list, PORTFOLIO_SCROLL_MAX, LV_ANIM_OFF);
    }
  }, LV_EVENT_SCROLL, NULL);

  portfolio_manage_btn = lv_btn_create(portfolio_screen);
  lv_obj_set_size(portfolio_manage_btn, 220, 50);
  lv_obj_align(portfolio_manage_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -20);
  lv_obj_set_style_bg_color(portfolio_manage_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(portfolio_manage_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(portfolio_manage_btn, portfolio_manage_btn_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *manage_label = lv_label_create(portfolio_manage_btn);
  lv_label_set_text(manage_label, "Manage Portfolio");
  lv_obj_set_style_text_color(manage_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(manage_label, &poppins_medium_20, 0);
  lv_obj_center(manage_label);

  portfolio_back_btn = lv_btn_create(portfolio_screen);
  lv_obj_set_size(portfolio_back_btn, 120, 50);
  lv_obj_align(portfolio_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(portfolio_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(portfolio_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(portfolio_back_btn, portfolio_back_btn_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *back_label = lv_label_create(portfolio_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_center(back_label);

  encoderFocusAdd(portfolio_manage_btn, manage_label);
  encoderFocusAdd(portfolio_back_btn, back_label);
  encoderFocusCommit(0);
  
  // Fade effect at bottom (match Favorites page 100% -> 0% stack)
  lv_obj_t *portfolio_fade_layer1 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer1, 400, 25);
  lv_obj_align(portfolio_fade_layer1, LV_ALIGN_BOTTOM_MID, 0, -125);
  lv_obj_set_style_bg_color(portfolio_fade_layer1, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer1, LV_OPA_10, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer1, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer1, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer1, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer1, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_t *portfolio_fade_layer2 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer2, 400, 25);
  lv_obj_align(portfolio_fade_layer2, LV_ALIGN_BOTTOM_MID, 0, -100);
  lv_obj_set_style_bg_color(portfolio_fade_layer2, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer2, LV_OPA_20, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer2, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer2, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer2, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer2, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_t *portfolio_fade_layer3 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer3, 400, 25);
  lv_obj_align(portfolio_fade_layer3, LV_ALIGN_BOTTOM_MID, 0, -75);
  lv_obj_set_style_bg_color(portfolio_fade_layer3, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer3, LV_OPA_30, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer3, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer3, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer3, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer3, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_t *portfolio_fade_layer4 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer4, 400, 25);
  lv_obj_align(portfolio_fade_layer4, LV_ALIGN_BOTTOM_MID, 0, -50);
  lv_obj_set_style_bg_color(portfolio_fade_layer4, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer4, LV_OPA_50, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer4, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer4, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer4, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer4, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_t *portfolio_fade_layer5 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer5, 400, 25);
  lv_obj_align(portfolio_fade_layer5, LV_ALIGN_BOTTOM_MID, 0, -25);
  lv_obj_set_style_bg_color(portfolio_fade_layer5, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer5, LV_OPA_70, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer5, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer5, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer5, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer5, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_t *portfolio_fade_layer6 = lv_obj_create(portfolio_screen);
  lv_obj_set_size(portfolio_fade_layer6, 400, 25);
  lv_obj_align(portfolio_fade_layer6, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_obj_set_style_bg_color(portfolio_fade_layer6, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(portfolio_fade_layer6, LV_OPA_COVER, 0);
  lv_obj_set_style_border_width(portfolio_fade_layer6, 0, 0);
  lv_obj_set_style_radius(portfolio_fade_layer6, 0, 0);
  lv_obj_clear_flag(portfolio_fade_layer6, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(portfolio_fade_layer6, LV_OBJ_FLAG_SCROLLABLE);

  lv_obj_move_foreground(portfolio_fade_layer1);
  lv_obj_move_foreground(portfolio_fade_layer2);
  lv_obj_move_foreground(portfolio_fade_layer3);
  lv_obj_move_foreground(portfolio_fade_layer4);
  lv_obj_move_foreground(portfolio_fade_layer5);
  lv_obj_move_foreground(portfolio_fade_layer6);

  lv_obj_move_foreground(portfolio_back_btn);
  lv_obj_move_foreground(portfolio_manage_btn);
  if (portfolio_total_label && lv_obj_is_valid(portfolio_total_label)) {
    lv_obj_move_foreground(portfolio_total_label);
  }

  updatePortfolioTotal();
  refreshPortfolioList();
  portfolio_next_price_index = 0;
  ensurePortfolioPrices(false);

  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(portfolio_screen);
  }

  showCoinInfoIcon();
}

static void portfolio_manage_back_btn_cb(lv_event_t * e) {
  (void)e;
  createPortfolioPage();
}
static void createPortfolioManagePage() {
  hidePortfolioPopup();

  if (portfolio_manage_screen && lv_obj_is_valid(portfolio_manage_screen)) {
    lv_obj_del(portfolio_manage_screen);
  }

  portfolio_manage_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(portfolio_manage_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(portfolio_manage_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(portfolio_manage_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(portfolio_manage_screen);

  encoderFocusBegin(portfolio_manage_screen);

  lv_obj_t *logo = lv_img_create(portfolio_manage_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  lv_obj_t *title_label = lv_label_create(portfolio_manage_screen);
  lv_label_set_text(title_label, "Manage Portfolio");
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

  portfolio_search_bar = lv_textarea_create(portfolio_manage_screen);
  lv_obj_set_size(portfolio_search_bar, 300, 50);
  lv_obj_align(portfolio_search_bar, LV_ALIGN_TOP_MID, 0, 110);
  lv_textarea_set_placeholder_text(portfolio_search_bar, "Search coins...");
  lv_textarea_set_one_line(portfolio_search_bar, true);
  lv_textarea_set_max_length(portfolio_search_bar, 20);
  lv_textarea_set_text(portfolio_search_bar, "");
  lv_obj_set_style_bg_color(portfolio_search_bar, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_text_color(portfolio_search_bar, COLOR_WHITE, 0);
  lv_obj_set_style_border_color(portfolio_search_bar, COLOR_WHITE, 0);
  lv_obj_set_style_border_width(portfolio_search_bar, 1, 0);
  lv_obj_set_style_radius(portfolio_search_bar, 15, 0);

  static lv_style_t portfolio_cursor_style;
  static bool portfolio_cursor_style_initialized = false;
  if (!portfolio_cursor_style_initialized) {
    lv_style_init(&portfolio_cursor_style);
    lv_style_set_border_color(&portfolio_cursor_style, COLOR_WHITE);
    lv_style_set_bg_color(&portfolio_cursor_style, COLOR_WHITE);
    portfolio_cursor_style_initialized = true;
  }
  lv_obj_add_style(portfolio_search_bar, &portfolio_cursor_style, LV_PART_CURSOR);

  lv_obj_add_event_cb(portfolio_search_bar, [](lv_event_t *e) {
    portfolio_search_query = lv_textarea_get_text(portfolio_search_bar);
    refreshPortfolioManageList();
  }, LV_EVENT_VALUE_CHANGED, NULL);

  lv_obj_add_event_cb(portfolio_search_bar, [](lv_event_t *e) {
    if (portfolio_search_kb && lv_obj_is_valid(portfolio_search_kb)) {
      lv_keyboard_set_textarea(portfolio_search_kb, portfolio_search_bar);
      lv_obj_clear_flag(portfolio_search_kb, LV_OBJ_FLAG_HIDDEN);
    }
    lv_textarea_set_placeholder_text(portfolio_search_bar, "");
  }, LV_EVENT_FOCUSED, NULL);

  portfolio_search_list = lv_obj_create(portfolio_manage_screen);
  lv_obj_set_size(portfolio_search_list, 400, 220);
  lv_obj_align(portfolio_search_list, LV_ALIGN_CENTER, 0, 40);
  lv_obj_set_style_bg_color(portfolio_search_list, COLOR_BLACK, 0);
  lv_obj_set_style_border_width(portfolio_search_list, 0, 0);
  lv_obj_set_style_radius(portfolio_search_list, 10, 0);
  lv_obj_set_scrollbar_mode(portfolio_search_list, LV_SCROLLBAR_MODE_OFF);
  lv_obj_set_scroll_dir(portfolio_search_list, LV_DIR_VER);

  lv_obj_add_event_cb(portfolio_search_list, [](lv_event_t *e) {
    portfolio_search_list_scrolling = true;
  }, LV_EVENT_SCROLL_BEGIN, NULL);

  lv_obj_add_event_cb(portfolio_search_list, [](lv_event_t *e) {
    portfolio_search_list_scrolling = false;
  }, LV_EVENT_SCROLL_END, NULL);

  portfolio_manage_back_btn = lv_btn_create(portfolio_manage_screen);
  lv_obj_set_size(portfolio_manage_back_btn, 120, 50);
  lv_obj_align(portfolio_manage_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(portfolio_manage_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(portfolio_manage_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(portfolio_manage_back_btn, portfolio_manage_back_btn_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t *pm_back_label = lv_label_create(portfolio_manage_back_btn);
  lv_label_set_text(pm_back_label, "Back");
  lv_obj_set_style_text_color(pm_back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(pm_back_label, &poppins_medium_20, 0);
  lv_obj_center(pm_back_label);

  encoderFocusAdd(portfolio_manage_back_btn, pm_back_label);
  encoderFocusCommit(0);

  portfolio_search_kb = lv_keyboard_create(portfolio_manage_screen);
  lv_obj_align(portfolio_search_kb, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_keyboard_set_mode(portfolio_search_kb, LV_KEYBOARD_MODE_TEXT_UPPER);
  lv_keyboard_set_textarea(portfolio_search_kb, portfolio_search_bar);
  lv_obj_add_flag(portfolio_search_kb, LV_OBJ_FLAG_HIDDEN);

  lv_obj_add_event_cb(portfolio_search_kb, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_READY || code == LV_EVENT_CANCEL) {
      if (portfolio_search_kb && lv_obj_is_valid(portfolio_search_kb)) {
        lv_obj_add_flag(portfolio_search_kb, LV_OBJ_FLAG_HIDDEN);
      }
      if (portfolio_search_bar && lv_obj_is_valid(portfolio_search_bar) &&
          lv_textarea_get_text(portfolio_search_bar)[0] == '\0') {
        lv_textarea_set_placeholder_text(portfolio_search_bar, "Search coins...");
      }
    }
  }, LV_EVENT_ALL, NULL);

  lv_obj_add_event_cb(portfolio_manage_screen, [](lv_event_t *e) {
    if (lv_event_get_target(e) != portfolio_manage_screen) return;
    if (portfolio_search_kb && lv_obj_is_valid(portfolio_search_kb) &&
        !lv_obj_has_flag(portfolio_search_kb, LV_OBJ_FLAG_HIDDEN)) {
      lv_obj_add_flag(portfolio_search_kb, LV_OBJ_FLAG_HIDDEN);
      if (portfolio_search_bar && lv_obj_is_valid(portfolio_search_bar) &&
          lv_textarea_get_text(portfolio_search_bar)[0] == '\0') {
        lv_textarea_set_placeholder_text(portfolio_search_bar, "Search coins...");
      }
    }
  }, LV_EVENT_CLICKED, NULL);

  portfolio_search_query = "";
  portfolio_search_list_scrolling = false;
  portfolioSearchResultCount = 0;
  refreshPortfolioManageList();

  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(portfolio_manage_screen);
  }

  showCoinInfoIcon();
}

static bool fetchBinanceCoinsForPortfolio(const String& query) {
  portfolioSearchResultCount = 0;
  if (query.length() == 0) return false;

  static const char* availableCoins[] = {
    "BTC","ETH","XRP","ADA","SOL","DOGE","MATIC","DOT","LTC","BCH",
    "LINK","ATOM","XLM","ETC","FIL","ICP","NEAR","HBAR","VET","FTM",
    "TRX","EGLD","AAVE","AVAX","AXS","SAND","MANA","UNI","SUSHI","COMP",
    "GALA","APE","CRV","SNX","FLOW","ALGO","RUNE","MKR","YFI","OP",
    "LDO","IMX","ARB","STX","INJ","APT","RNDR","PEPE","SHIB","FLOKI",
    "BONK","GRT","ZEC","SEI","JUP","TIA","PYTH","SUI","XMR","DYDX"
  };

  const int coinCount = sizeof(availableCoins) / sizeof(availableCoins[0]);
  String queryUpper = query;
  queryUpper.toUpperCase();

  for (int i = 0; i < coinCount && portfolioSearchResultCount < MAX_SEARCH_RESULTS; i++) {
    String baseCoin = availableCoins[i];
    if (baseCoin.startsWith(queryUpper)) {
      String symbol = baseCoin + "USDT";
      portfolioSearchResults[portfolioSearchResultCount].symbol = symbol;
      portfolioSearchResults[portfolioSearchResultCount].baseCoin = baseCoin;
      portfolioSearchResults[portfolioSearchResultCount].isFavorite = isCoinInPortfolio(symbol);
      portfolioSearchResultCount++;
    }
  }

  Serial.printf("[Portfolio] Found %d matches for '%s'\n", portfolioSearchResultCount, queryUpper.c_str());
  return portfolioSearchResultCount > 0;
}

static void refreshPortfolioManageList() {
  if (!portfolio_search_list || !lv_obj_is_valid(portfolio_search_list)) return;


  lv_obj_clean(portfolio_search_list);

  if (portfolio_search_query.length() == 0) {
    lv_obj_t *instruction = lv_label_create(portfolio_search_list);
    lv_label_set_text(instruction, "Search for coins to add");
    lv_obj_set_style_text_color(instruction, COLOR_WHITE, 0);
    lv_obj_set_style_text_font(instruction, &poppins_light_20, 0);
    lv_obj_align(instruction, LV_ALIGN_CENTER, 0, 0);
    portfolioSearchResultCount = 0;
    return;
  }

  bool success = fetchBinanceCoinsForPortfolio(portfolio_search_query);
  if (!success || portfolioSearchResultCount == 0) {
    lv_obj_t *no_results = lv_label_create(portfolio_search_list);
    lv_label_set_text(no_results, "No coins found");
    lv_obj_set_style_text_color(no_results, COLOR_WHITE, 0);
    lv_obj_set_style_text_font(no_results, &poppins_light_20, 0);
    lv_obj_align(no_results, LV_ALIGN_CENTER, 0, 0);
    return;
  }

  const int button_width = 100;
  const int button_height = 50;
  const int button_spacing = 10;
  const int max_cols = 3;

  for (int i = 0; i < portfolioSearchResultCount; i++) {
    bool is_added = portfolioSearchResults[i].isFavorite;
    lv_obj_t *btn = lv_btn_create(portfolio_search_list);
    lv_obj_set_size(btn, button_width, button_height);

    int col = i % max_cols;
    int row = i / max_cols;
    int x = 20 + col * (button_width + button_spacing);
    int y = row * (button_height + button_spacing);
    lv_obj_set_pos(btn, x, y);

    lv_obj_set_style_bg_color(btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
    lv_obj_set_user_data(btn, (void*)(intptr_t)i);

    lv_obj_add_event_cb(btn, [](lv_event_t *e) {
      if (portfolio_search_list_scrolling) return;

      lv_obj_t *btn = lv_event_get_target(e);
      int idx = (int)(intptr_t)lv_obj_get_user_data(btn);
      if (idx < 0 || idx >= portfolioSearchResultCount) return;

      if (!portfolioSearchResults[idx].isFavorite) {
        if (portfolioCoinCount >= MAX_PORTFOLIO_COINS) {
          Serial.println("[Portfolio] Reached portfolio storage limit");
          return;
        }

        addCoinToPortfolio(portfolioSearchResults[idx].symbol, portfolioSearchResults[idx].baseCoin);
        portfolioSearchResults[idx].isFavorite = true;
        lv_obj_set_style_bg_color(btn, COLOR_WHITE, 0);
        lv_obj_t *label = lv_obj_get_child(btn, 0);
        if (label && lv_obj_is_valid(label)) {
          lv_obj_set_style_text_color(label, COLOR_GREEN, 0);
        }
        refreshPortfolioList();
      }
    }, LV_EVENT_CLICKED, NULL);

    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, portfolioSearchResults[i].baseCoin.c_str());
    lv_obj_set_style_text_color(label, is_added ? COLOR_GREEN : COLOR_BLACK, 0);
    lv_obj_set_style_text_font(label, &poppins_medium_20, 0);
    lv_obj_center(label);
  }
}

// Check if a coin is favorited
static bool isCoinFavorited(const String& symbol) {
  for (int i = 0; i < favoriteCoinCount; i++) {
    if (favoriteCoinSymbols[i] == symbol) {
      return true;
    }
  }
  return false;
}

// Toggle favorite status of a coin
static void toggleCoinFavorite(const String& symbol, const String& baseCoin) {
  bool found = false;
  int foundIndex = -1;
  
  // Check if already favorited
  for (int i = 0; i < favoriteCoinCount; i++) {
    if (favoriteCoinSymbols[i] == symbol) {
      found = true;
      foundIndex = i;
      break;
    }
  }
  
  if (found) {
    // Remove from favorites
    for (int i = foundIndex; i < favoriteCoinCount - 1; i++) {
      favoriteCoinSymbols[i] = favoriteCoinSymbols[i + 1];
    }
    favoriteCoinCount--;
    Serial.printf("Removed %s from favorites\n", symbol.c_str());
  } else {
    // Add to favorites
    if (favoriteCoinCount < MAX_FAVORITE_COINS) {
      favoriteCoinSymbols[favoriteCoinCount] = symbol;
      favoriteCoinCount++;
      Serial.printf("Added %s to favorites\n", symbol.c_str());
    }
  }
  
  saveFavoriteCoins();
}
// Comprehensive list of 400+ popular cryptocurrencies (instant search, no API needed)
// Covers 99.9%+ of coins users search for - all stored in flash memory (~5KB)
static const char* ALL_POPULAR_COINS[] = {
  // Top 100 by Market Cap
  "BTC", "ETH", "USDT", "BNB", "SOL", "XRP", "USDC", "ADA", "DOGE", "TRX",
  "AVAX", "SHIB", "TON", "DOT", "LINK", "MATIC", "BCH", "LTC", "UNI", "ICP",
  "NEAR", "APT", "STX", "MNT", "IMX", "ARB", "OP", "FIL", "HBAR", "VET",
  "INJ", "ATOM", "MKR", "RUNE", "LDO", "GRT", "AAVE", "RENDER", "FTM", "ALGO",
  "SAND", "MANA", "AXS", "THETA", "FLOW", "EOS", "XTZ", "EGLD", "KAVA", "ZEC",
  "ROSE", "CFX", "GALA", "CHZ", "ENJ", "BAT", "ZIL", "ANKR", "SKL", "1INCH",
  "WAVES", "DASH", "NEO", "IOTA", "ZEN", "QTUM", "ONT", "ICX", "LSK", "STEEM",
  "OMG", "ZRX", "REP", "GNO", "STORJ", "MLN", "ANT", "FUN", "NEXO", "HOT",
  "CELR", "IOTX", "ONE", "FTT", "WOO", "BLZ", "CTSI", "VITE", "ERN", "XVS",
  "PAXG", "WBTC", "TUSD", "DAI", "BUSD", "FRAX", "LUSD", "GUSD", "USDP", "QNT",
  
  // DeFi Tokens (100+)
  "SUSHI", "CRV", "SNX", "COMP", "YFI", "BAL", "UMA", "BAND", "REN", "KNC",
  "LRC", "PERP", "DYDX", "GMX", "JOE", "CAKE", "ALPHA", "BNT", "BADGER", "CVX",
  "ALCX", "SPELL", "OHM", "BTRFLY", "KLIMA", "AURORA", "JPEG", "LOOKS", "X2Y2", "DODO",
  "SRM", "RAY", "ORCA", "FIDA", "OXY", "SBR", "PORT", "STEP", "COPE", "MNGO",
  "FOR", "DEXE", "AUTO", "ALPACA", "BIFI", "BUNNY", "EPS", "LINA", "SFP", "TWT",
  "WING", "HARD", "SXP", "BETA", "BURGER", "SPARTA", "VAI", "TKO", "UNFI", "DF",
  "REEF", "COTI", "CTXC", "Troy", "VITE", "ONG", "PERL", "DOCK", "WAN", "NULS",
  "IRIS", "ARPA", "TCT", "WRX", "LTO", "MBL", "CELO", "STMX", "POND", "DEGO",
  "VGX", "RAD", "POLS", "TRU", "EASY", "AUDIO", "BADGER", "FIS", "OM", "POND",
  "KEEP", "NKN", "SC", "LSK", "STPT", "SUSD", "UTK", "GHST", "ORN", "PROM",
  
  // Layer 2 & Scaling
  "MINA", "METIS", "BOBA", "ZK", "STRK", "SCROLL", "LINEA", "BASE", "BLAST", "MODE",
  "ZORA", "POLY", "CELO", "KAVA", "EVMOS", "OSMO", "JUNO", "SCRT", "AKASH", "CMDX",
  
  // Meme Coins (100+)
  "PEPE", "WIF", "FLOKI", "BONK", "BABYDOGE", "ELON", "SAMO", "WOJAK", "LADYS", "TURBO",
  "SPONGE", "WALL", "SMOG", "MYRO", "WEN", "BOME", "SLERF", "NAP", "MONG", "DUKO",
  "BOBO", "BITCOIN", "PEPE2", "CHAD", "COPIUM", "HOPIUM", "MAGA", "TREMP", "TOSHI", "BRETT",
  "ANDY", "MOCHI", "HIGHER", "DEGEN", "BODEN", "GIGA", "MOG", "PONKE", "POPCAT", "MEW",
  "HOBBES", "GROK", "SPURDO", "APED", "", "SMOLE", "RETARD", "GUMMY", "BILLY", "MUMU",
  
  // Gaming & Metaverse (80+)
  "IMX", "BLUR", "MAGIC", "VOXEL", "ILV", "TLM", "SLP", "ALICE", "PYR", "GHST",
  "WILD", "TOWER", "NAKA", "UFO", "SHILL", "DPET", "THG", "ETERNAL", "REVO", "WARS",
  "EMPIRE", "KART", "LEAGUE", "SUPERB", "GUILD", "YGG", "MARS4", "DERC", "DOSE", "AFA",
  "GAM3", "GAMER", "GUNZ", "HERO", "JEWEL", "KOK", "LABS", "MINT", "MOBOX", "MVI",
  "MVL", "NFTB", "NFTY", "PMON", "POLC", "PROS", "RACEFI", "REVV", "SKILL", "ULTRA",
  "APE", "BLUR", "LOOKS", "X2Y2", "SUDO", "NFTX", "RARIBLE", "SUPER", "DEGO", "MEME",
  "STARL", "UFO", "NFTL", "VEMP", "WARS", "XWG", "ZOO", "DPET", "GMEE", "MOOV",
  
  // AI & Machine Learning
  "FET", "AGIX", "OCEAN", "NMR", "CTSI", "RNDR", "GRT", "AIOZ", "AITT", "CGPT",
  "ALI", "PHB", "DATA", "VIDT", "LTO", "TRAC", "DIA", "API3", "TRB", "BIOT",
  "GPT", "AGI", "MATRIX", "DBC", "EFFECT", "COTI", "TFUEL", "VRA", "TLOS", "AZERO",
  
  // NFT & Digital Art
  "BLUR", "LOOKS", "X2Y2", "SUDO", "NFTX", "RARI", "SUPER", "DEGO", "GHST", "WHALE",
  "MASK", "MEME", "STARL", "UFO", "NFTL", "VEMP", "XWG", "ZOO", "DPET", "GMEE",
  
  // Infrastructure & Oracles
  "BAND", "API3", "TRB", "DIA", "UMA", "NEST", "DOS", "ORAI", "FLUX", "ERGO",
  
  // Privacy Coins
  "SCRT", "ROSE", "DUSK", "ARRR", "BEAM", "FIRO", "XVG", "PART", "NAV", "PIVX",
  
  // Storage & Cloud
  "AR", "STORJ", "BTT", "SC", "SAFE", "BLUZELLE", "OPACITY", "STACK", "AETH", "MFT",
  
  // Social & Content
  "CHZ", "AUDIO", "MASK", "RALLY", "WHALE", "ALEX", "RARE", "HIGH", "ADS", "XCAD",
  "HUNT", "MITH", "KEY", "COS", "VIB", "POWR", "MDT", "FTM", "STEEM", "HIVE",
  
  // Real World Assets
  "ONDO", "PENDLE", "MPL", "TRU", "CFG", "PROPS", "RIO", "POLYX", "NXRA", "LCX",
  
  // DePIN (Decentralized Infrastructure)
  "HNT", "MOBILE", "IOT", "IOTX", "DIMO", "HONEY", "WIFI", "GEODNET", "ARKM", "ORAI",
  
  // Newer Trending Coins (2024-2025)
  "SUI", "SEI", "TIA", "WLD", "PYTH", "JUP", "JTO", "STRK", "MEME", "ORDI",
  "SATS", "RAT", "PIXEL", "PORTAL", "AEVO", "DYM", "ALT", "XAI", "MANTA", "ACE",
  "NFP", "AI", "AUCTION", "BAKE", "COMBO", "CREAM", "CTK", "CVP", "ELF", "FORTH",
  
  // Additional Popular Tokens  
  "XLM", "KLAY", "CRO", "RPL", "LPT", "ENS", "GMT", "ID", "VELO", "HOOK",
  "MAGIC", "RDNT", "GRAIL", "USDD", "DOMI", "AGLD", "LQTY", "HIGH", "VOXEL", "ILV"
};
static const int ALL_COINS_COUNT = sizeof(ALL_POPULAR_COINS) / sizeof(ALL_POPULAR_COINS[0]);

// Instant coin search through local list (400+ coins, zero network delay)
static bool fetchBinanceCoins(const String& query) {
  searchResultCount = 0;
  
  if (query.length() == 0) return false;
  
  String queryUpper = query;
  queryUpper.toUpperCase();
  
  Serial.printf("Searching %d coins for: '%s'\n", ALL_COINS_COUNT, query.c_str());
  
  // Search through the comprehensive static list (instant - no network)
  for (int i = 0; i < ALL_COINS_COUNT && searchResultCount < MAX_SEARCH_RESULTS; i++) {
    String baseCoin = String(ALL_POPULAR_COINS[i]);
    
    if (baseCoin.startsWith(queryUpper)) {
      String symbol = baseCoin + "USDT";
      
      searchResults[searchResultCount].symbol = symbol;
      searchResults[searchResultCount].baseCoin = baseCoin;
      searchResults[searchResultCount].isFavorite = isCoinFavorited(symbol);
      searchResultCount++;
    }
  }
  
  Serial.printf("Found %d matches (instant search)\n", searchResultCount);
  return searchResultCount > 0;
}

// Filter search results (no longer needed - API does the filtering)
static int filterSearchResults(const String& query, CoinSearchInfo* results, int maxResults) {
  // Legacy function - filtering now done by API
  return 0;
}

// Forward declarations for UI functions
static void createSearchFavoritesSelectionPage();
static void createCoinSearchPage();
static void createNewFavoritesPage();
static void refreshCoinSearchList();
static void refreshNewFavoritesList();

/* ===== Favorites Page (Legacy - Redirects to New System) ===== */
// Old favorites page - redirects to new dynamic system
static void createFavoritesPage() {
  createNewFavoritesPage();
}

static void favorite_pair_cb(lv_event_t * e) {
  // Legacy function - no longer used with dynamic system
}

static void back_btn_cb(lv_event_t * e) {
  lv_scr_load(homepage_screen);
  setupHomepageFocus();
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(homepage_screen);
  }
}

static void updateSelectedPairs() {
  // Legacy function - selected pairs now managed dynamically
  selected_pair_count = active_pair_count;
  current_pair = 0;
}
/* ===== Search/Favorites Selection Page ===== */
static void createSearchFavoritesSelectionPage() {
  search_favorites_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(search_favorites_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(search_favorites_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(search_favorites_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(search_favorites_screen);

  // Logo at top
  lv_obj_t *logo = lv_img_create(search_favorites_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Favorites button (green with black text) - now on top (matching homepage)
  favorites_btn_screen = lv_btn_create(search_favorites_screen);
  lv_obj_set_size(favorites_btn_screen, 300, 60);
  lv_obj_align(favorites_btn_screen, LV_ALIGN_CENTER, 0, -40);
  lv_obj_set_style_bg_color(favorites_btn_screen, COLOR_WHITE, 0);
  lv_obj_set_style_radius(favorites_btn_screen, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(favorites_btn_screen, [](lv_event_t *e) {
    createNewFavoritesPage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *favorites_label = lv_label_create(favorites_btn_screen);
  lv_label_set_text(favorites_label, "Favorites");
  lv_obj_set_style_text_color(favorites_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(favorites_label, &poppins_medium_20, 0);
  lv_obj_center(favorites_label);

  // Search button (white with black text) - now on bottom (matching homepage)
  search_btn_screen = lv_btn_create(search_favorites_screen);
  lv_obj_set_size(search_btn_screen, 300, 60);
  lv_obj_align(search_btn_screen, LV_ALIGN_CENTER, 0, 40);
  lv_obj_set_style_bg_color(search_btn_screen, COLOR_WHITE, 0);
  lv_obj_set_style_radius(search_btn_screen, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(search_btn_screen, [](lv_event_t *e) {
    // Don't fetch coins here - wait until user starts typing
    createCoinSearchPage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *search_label = lv_label_create(search_btn_screen);
  lv_label_set_text(search_label, "Favorites");
  lv_obj_set_style_text_color(search_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(search_label, &poppins_medium_20, 0);
  lv_obj_center(search_label);

  // Back button
  search_favorites_back_btn = lv_btn_create(search_favorites_screen);
  lv_obj_set_size(search_favorites_back_btn, 120, 50);
  lv_obj_align(search_favorites_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(search_favorites_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(search_favorites_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(search_favorites_back_btn, [](lv_event_t *e) {
    createHomepage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(search_favorites_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_center(back_label);
  
  // Move WiFi signal to this screen
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(search_favorites_screen);
  }

  showCoinInfoIcon();
}

/* ===== Coin Search Page ===== */
static void refreshCoinSearchList() {
  if (!coin_search_list || !lv_obj_is_valid(coin_search_list)) return;
  
  lv_obj_clean(coin_search_list);
  
  // Reset encoder focus when list is refreshed
  if (coin_search_screen && lv_obj_is_valid(coin_search_screen) && 
      lv_scr_act() == coin_search_screen) {
    encoderFocusBegin(coin_search_screen);
    // Add back button to focus
    if (coin_search_back_btn && lv_obj_is_valid(coin_search_back_btn)) {
      lv_obj_t *back_label = lv_obj_get_child(coin_search_back_btn, 0);
      if (back_label && lv_obj_is_valid(back_label)) {
        encoderFocusAdd(coin_search_back_btn, back_label);
      }
    }
  }
  
  // If user hasn't typed anything yet, show instruction
  if (coin_search_query.length() == 0) {
    lv_obj_t *instruction = lv_label_create(coin_search_list);
    lv_label_set_text(instruction, "Search for your favorite coins");
    lv_obj_set_style_text_color(instruction, COLOR_BLACK, 0);
    lv_obj_set_style_text_font(instruction, &poppins_light_20, 0);
    lv_obj_align(instruction, LV_ALIGN_CENTER, 0, 0);
    searchResultCount = 0; // Reset results
    // Commit focus with just back button
    if (coin_search_screen && lv_obj_is_valid(coin_search_screen) && 
        lv_scr_act() == coin_search_screen) {
      encoderFocusCommit(0);
    }
    return;
  }
  
  // Search local coin list (instant - no network needed)
  bool success = fetchBinanceCoins(coin_search_query);
  
  if (!success || searchResultCount == 0) {
    lv_obj_t *no_results = lv_label_create(coin_search_list);
    lv_label_set_text(no_results, "No coins found");
    lv_obj_set_style_text_color(no_results, COLOR_WHITE, 0);
    lv_obj_set_style_text_font(no_results, &poppins_light_20, 0);
    lv_obj_align(no_results, LV_ALIGN_CENTER, 0, 0);
    // Commit focus with just back button
    if (coin_search_screen && lv_obj_is_valid(coin_search_screen) && 
        lv_scr_act() == coin_search_screen) {
      encoderFocusCommit(0);
    }
    return;
  }
  
  // Display search results
  Serial.printf("Showing %d results for query: '%s'\n", searchResultCount, coin_search_query.c_str());
  const int button_width = 100;  // 50% less width (was 200)
  const int button_height = 50;
  const int button_spacing = 10;
  
  for (int i = 0; i < searchResultCount; i++) {
    bool is_favorited = searchResults[i].isFavorite;
    
    lv_obj_t *btn = lv_btn_create(coin_search_list);
    lv_obj_set_size(btn, button_width, button_height);
    
    int x = (370 - button_width) / 2;  // Center in container (was 85)
    int y = i * (button_height + button_spacing);
    lv_obj_set_pos(btn, x, y);
    
    lv_obj_set_style_bg_color(btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
    
    // Store coin info in user data
    lv_obj_set_user_data(btn, (void*)(intptr_t)i);
    
    lv_obj_add_event_cb(btn, [](lv_event_t *e) {
      if (coin_search_list_scrolling) return;
      
      lv_obj_t *btn = lv_event_get_target(e);
      int idx = (int)(intptr_t)lv_obj_get_user_data(btn);
      
      if (idx >= 0 && idx < searchResultCount) {
        // Check if at max favorites limit
        if (!searchResults[idx].isFavorite && favoriteCoinCount >= MAX_FAVORITE_COINS) {
          // Hide counter temporarily
          if (coin_search_counter_label && lv_obj_is_valid(coin_search_counter_label)) {
            lv_obj_add_flag(coin_search_counter_label, LV_OBJ_FLAG_HIDDEN);
          }
          
          // Show error in same position as counter (LV_ALIGN_TOP_MID, 0, 60)
          lv_obj_t *max_label = lv_label_create(coin_search_screen);
          lv_label_set_text_fmt(max_label, "Maximum %d favorites reached", MAX_FAVORITE_COINS);
          lv_obj_set_style_text_color(max_label, COLOR_RED, 0);
          lv_obj_set_style_text_font(max_label, &poppins_light_20, 0);
          lv_obj_align(max_label, LV_ALIGN_TOP_MID, 0, 60); // Same position as counter
          
          // Timer to delete error and restore counter after 3 seconds
          lv_timer_t *restore_timer = lv_timer_create([](lv_timer_t *t) {
            lv_obj_t *error_label = (lv_obj_t *)t->user_data;
            if (error_label && lv_obj_is_valid(error_label)) {
              lv_obj_del(error_label);
            }
            // Restore counter visibility
            if (coin_search_counter_label && lv_obj_is_valid(coin_search_counter_label)) {
              lv_obj_clear_flag(coin_search_counter_label, LV_OBJ_FLAG_HIDDEN);
            }
            lv_timer_del(t);
          }, 3000, max_label);
          lv_timer_set_repeat_count(restore_timer, 1);
          
          return;
        }
        
        // Toggle favorite
        toggleCoinFavorite(searchResults[idx].symbol, searchResults[idx].baseCoin);
        
        // Update button color and result
        searchResults[idx].isFavorite = isCoinFavorited(searchResults[idx].symbol);
        lv_obj_set_style_bg_color(btn, COLOR_WHITE, 0);
        lv_obj_t *label = lv_obj_get_child(btn, 0);
        if (label && lv_obj_is_valid(label)) {
          lv_obj_set_style_text_color(label, searchResults[idx].isFavorite ? COLOR_GREEN : COLOR_BLACK, 0);
        }
        
        // Update favorites counter
        if (coin_search_counter_label && lv_obj_is_valid(coin_search_counter_label)) {
          lv_label_set_text_fmt(coin_search_counter_label, "%d/%d", favoriteCoinCount, MAX_FAVORITE_COINS);
        }
      }
    }, LV_EVENT_CLICKED, NULL);
    
    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, searchResults[i].baseCoin.c_str());
    lv_obj_set_style_text_color(label, is_favorited ? COLOR_GREEN : COLOR_BLACK, 0);
    lv_obj_set_style_text_font(label, &poppins_medium_20, 0);
    lv_obj_center(label);
    
    // Do NOT add coin buttons to encoder focus - user can only navigate to back button
  }
  
  // Commit encoder focus with only back button
  if (coin_search_screen && lv_obj_is_valid(coin_search_screen) && 
      lv_scr_act() == coin_search_screen) {
    encoderFocusCommit(0);
  }
}
static void createCoinSearchPage() {
  coin_search_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(coin_search_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(coin_search_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(coin_search_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(coin_search_screen);

  // Logo at top
  lv_obj_t *logo = lv_img_create(coin_search_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Favorites counter (X/10) - positioned below logo
  coin_search_counter_label = lv_label_create(coin_search_screen);
  lv_label_set_text_fmt(coin_search_counter_label, "%d/%d", favoriteCoinCount, MAX_FAVORITE_COINS);
  lv_obj_set_style_text_color(coin_search_counter_label, lv_color_make(150, 150, 150), 0); // Gray color
  lv_obj_set_style_text_font(coin_search_counter_label, &poppins_light_20, 0);
  lv_obj_align(coin_search_counter_label, LV_ALIGN_TOP_MID, 0, 60);

  // Search bar
  coin_search_bar = lv_textarea_create(coin_search_screen);
  lv_obj_set_size(coin_search_bar, 300, 50);
  lv_obj_align(coin_search_bar, LV_ALIGN_TOP_MID, 0, 90);
  lv_textarea_set_placeholder_text(coin_search_bar, "Search coins...");
  lv_textarea_set_one_line(coin_search_bar, true);
  lv_textarea_set_text(coin_search_bar, "");
  coin_search_query = "";
  
  // Style the search bar with dark gray background, white text, no border
  lv_obj_set_style_bg_color(coin_search_bar, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_text_color(coin_search_bar, COLOR_WHITE, 0);
  lv_obj_set_style_text_color(coin_search_bar, COLOR_WHITE, LV_PART_TEXTAREA_PLACEHOLDER);
  lv_obj_set_style_border_width(coin_search_bar, 0, 0); // No border
  lv_obj_set_style_radius(coin_search_bar, BUTTON_RADIUS, 0); // Same rounded corners as buttons
  
  // Style the cursor (caret) to be white
  static lv_style_t cursor_style;
  lv_style_init(&cursor_style);
  lv_style_set_border_color(&cursor_style, COLOR_WHITE);
  lv_style_set_bg_color(&cursor_style, COLOR_WHITE);
  lv_obj_add_style(coin_search_bar, &cursor_style, LV_PART_CURSOR);
  
  // Add event handler for text changes (live search)
  lv_obj_add_event_cb(coin_search_bar, [](lv_event_t *e) {
    coin_search_query = lv_textarea_get_text(coin_search_bar);
    refreshCoinSearchList();
  }, LV_EVENT_VALUE_CHANGED, NULL);
  
  // Focus event to show keyboard and hide buttons
  lv_obj_add_event_cb(coin_search_bar, [](lv_event_t *e) {
    if (coin_search_kb && lv_obj_is_valid(coin_search_kb)) {
      lv_keyboard_set_textarea(coin_search_kb, coin_search_bar);
      lv_obj_clear_flag(coin_search_kb, LV_OBJ_FLAG_HIDDEN);
    }
    // Hide back button when keyboard is shown
    if (coin_search_back_btn && lv_obj_is_valid(coin_search_back_btn)) {
      lv_obj_add_flag(coin_search_back_btn, LV_OBJ_FLAG_HIDDEN);
    }
    // Clear placeholder text when focused
    if (coin_search_bar && lv_obj_is_valid(coin_search_bar)) {
      lv_textarea_set_placeholder_text(coin_search_bar, "");
    }
  }, LV_EVENT_FOCUSED, NULL);

  // Scrollable list for search results
  coin_search_list = lv_obj_create(coin_search_screen);
  lv_obj_set_size(coin_search_list, 400, 220);
  lv_obj_align(coin_search_list, LV_ALIGN_CENTER, 0, 20);
  lv_obj_set_style_bg_color(coin_search_list, COLOR_BLACK, 0);
  lv_obj_set_style_border_width(coin_search_list, 0, 0);
  lv_obj_set_style_radius(coin_search_list, 10, 0);
  lv_obj_set_scrollbar_mode(coin_search_list, LV_SCROLLBAR_MODE_OFF);
  lv_obj_set_scroll_dir(coin_search_list, LV_DIR_VER);
  
  // Scroll event handlers
  lv_obj_add_event_cb(coin_search_list, [](lv_event_t *e) {
    coin_search_list_scrolling = true;
  }, LV_EVENT_SCROLL_BEGIN, NULL);
  
  lv_obj_add_event_cb(coin_search_list, [](lv_event_t *e) {
    coin_search_list_scrolling = false;
  }, LV_EVENT_SCROLL_END, NULL);

  // Back button (create before keyboard so keyboard is on top)
  coin_search_back_btn = lv_btn_create(coin_search_screen);
  lv_obj_set_size(coin_search_back_btn, 120, 50);
  lv_obj_align(coin_search_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(coin_search_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(coin_search_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(coin_search_back_btn, [](lv_event_t *e) {
    // Go back to favorites page (which will show "Favorites" or "Continue" based on count)
    createNewFavoritesPage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(coin_search_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_center(back_label);

  // Keyboard (full width like WiFi keyboard)
  coin_search_kb = lv_keyboard_create(coin_search_screen);
  lv_obj_align(coin_search_kb, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_keyboard_set_mode(coin_search_kb, LV_KEYBOARD_MODE_TEXT_UPPER); // Start with uppercase
  lv_keyboard_set_textarea(coin_search_kb, coin_search_bar);
  lv_obj_add_flag(coin_search_kb, LV_OBJ_FLAG_HIDDEN);
  
  // Hide keyboard and show back button when ready event is triggered
  lv_obj_add_event_cb(coin_search_kb, [](lv_event_t *e) {
    if (coin_search_kb && lv_obj_is_valid(coin_search_kb)) {
      lv_obj_add_flag(coin_search_kb, LV_OBJ_FLAG_HIDDEN);
    }
    if (coin_search_back_btn && lv_obj_is_valid(coin_search_back_btn)) {
      lv_obj_clear_flag(coin_search_back_btn, LV_OBJ_FLAG_HIDDEN);
    }
    // Restore placeholder text when keyboard closes
    if (coin_search_bar && lv_obj_is_valid(coin_search_bar)) {
      lv_textarea_set_placeholder_text(coin_search_bar, "Search coins...");
    }
  }, LV_EVENT_READY, NULL);
  
  // Hide keyboard when clicking outside of it
  lv_obj_add_event_cb(coin_search_screen, [](lv_event_t *e) {
    lv_obj_t *target = lv_event_get_target(e);
    // If clicked object is not the keyboard or search bar, hide keyboard
    if (target != coin_search_kb && target != coin_search_bar && 
        coin_search_kb && lv_obj_is_valid(coin_search_kb)) {
      if (!lv_obj_has_flag(coin_search_kb, LV_OBJ_FLAG_HIDDEN)) {
        lv_obj_add_flag(coin_search_kb, LV_OBJ_FLAG_HIDDEN);
        if (coin_search_back_btn && lv_obj_is_valid(coin_search_back_btn)) {
          lv_obj_clear_flag(coin_search_back_btn, LV_OBJ_FLAG_HIDDEN);
        }
        // Restore placeholder text when keyboard closes
        if (coin_search_bar && lv_obj_is_valid(coin_search_bar)) {
          lv_textarea_set_placeholder_text(coin_search_bar, "Search coins...");
        }
      }
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Move WiFi signal to this screen
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(coin_search_screen);
  }
  
  // Initial display (encoder focus is set up in refreshCoinSearchList)
  refreshCoinSearchList();

  showCoinInfoIcon();
}
/* ===== Crypto Loading Screen ===== */
static void createCryptoLoadingScreen() {
  crypto_loading_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(crypto_loading_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(crypto_loading_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(crypto_loading_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(crypto_loading_screen);

  // Remove WiFi symbol while on loading screen
  if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
    lv_obj_del(wifi_signal);
    wifi_signal = nullptr;
  }

  // Logo
  crypto_loading_logo = lv_img_create(crypto_loading_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(crypto_loading_logo, &LumenLogo);
  lv_img_set_zoom(crypto_loading_logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(crypto_loading_logo, LV_ALIGN_TOP_MID, 0, 100);

  // Progress label
  crypto_loading_label = lv_label_create(crypto_loading_screen);
  lv_label_set_text(crypto_loading_label, "Loading... 0%");
  lv_obj_set_style_text_font(crypto_loading_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(crypto_loading_label, COLOR_WHITE, 0);
  lv_obj_align(crypto_loading_label, LV_ALIGN_CENTER, 0, 0);

  // Progress bar
  crypto_loading_bar = lv_bar_create(crypto_loading_screen);
  lv_obj_set_size(crypto_loading_bar, 400, 30);
  lv_obj_align(crypto_loading_bar, LV_ALIGN_CENTER, 0, 50);
  lv_obj_set_style_bg_color(crypto_loading_bar, lv_color_make(40, 40, 40), 0);
  lv_obj_set_style_bg_opa(crypto_loading_bar, LV_OPA_COVER, 0);
  lv_obj_set_style_bg_color(crypto_loading_bar, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_set_style_radius(crypto_loading_bar, 15, 0);
  lv_obj_set_style_radius(crypto_loading_bar, 15, LV_PART_INDICATOR);
  lv_bar_set_range(crypto_loading_bar, 0, 100);
  lv_bar_set_value(crypto_loading_bar, 0, LV_ANIM_OFF);
  
  lv_timer_handler();
}

static void updateCryptoLoadingProgress(int progress, const char* status) {
  crypto_loading_progress = progress;
  
  if (crypto_loading_bar && lv_obj_is_valid(crypto_loading_bar)) {
    lv_bar_set_value(crypto_loading_bar, progress, LV_ANIM_ON);
  }
  
  if (crypto_loading_label && lv_obj_is_valid(crypto_loading_label)) {
    lv_label_set_text_fmt(crypto_loading_label, "%s %d%%", status, progress);
  }
  
  lv_timer_handler();
}

/**
 * @brief Background timer that loads cryptocurrency data after screen is visible
 * @param timer LVGL timer object (automatically deleted after execution)
 * @details This one-shot timer populates the pairs array with favorite coins,
 *          establishes WebSocket connections, fetches historical data, and 
 *          initiates price updates. Runs after crypto loading screen is displayed
 *          to ensure smooth UI transitions.
 * @note - Disconnects old WebSocket connections first
 *       - Populates pairs array from favoriteCoinSymbols
 *       - Calls fetchHistory() which BLOCKS for 1-2 seconds
 *       - Starts live price updates via WebSocket
 * @see fetchHistory(), startKlineWS(), updateSelectedPairs()
 */
static void cryptoLoadingStepTimer(lv_timer_t *timer) {
  // This timer handles the actual data loading work
  // It's called once early to start loading data in background
  
  // Step 1: Disconnect old connections
  for (int i = 0; i < PAIR_COUNT; i++) {
    if (pairs[i].symbol.length() > 0) {
      pairs[i].ws_client.disconnect();
    }
  }
  
  // Step 2: Populate pairs array
  active_pair_count = 0;
  for (int i = 0; i < favoriteCoinCount && i < PAIR_COUNT; i++) {
    String symbol = favoriteCoinSymbols[i];
    String baseCoin = symbol;
    if (baseCoin.endsWith("USDT")) {
      baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
    }
    
    pairs[i].symbol = symbol;
    pairs[i].display_name = baseCoin;
    pairs[i].last_price = 0.0f;
    pairs[i].last_update = 0;
    pairs[i].daily_change_percent = 0.0f;  // Initialize daily % change
    pairs[i].last_ticker_update = 0;  // Initialize ticker update time
    pairs[i].candle_count = 0;
    pairs[i].is_selected = true;
    active_pair_count++;
  }
  
  // Clear remaining slots
  for (int i = active_pair_count; i < PAIR_COUNT; i++) {
    pairs[i].symbol = "";
    pairs[i].display_name = "";
    pairs[i].is_selected = false;
  }
  
  // Prepare for display
  selected_pair_count = active_pair_count;
  current_pair = 0;
  
  // Let UI update before heavy operations
  lv_timer_handler();
  
  // Start WebSocket (mostly non-blocking)
  startKlineWS(currentTFStr);
  
  // Fetch history (WILL BLOCK for 1-2 seconds)
  // Progress bar timer will pause during this but resume after
  fetchHistory(currentTFStr);
  
  // Force UI update after blocking call
  lv_timer_handler();
  
  // Delete step timer
  if (crypto_loading_step_timer) {
    lv_timer_del(crypto_loading_step_timer);
    crypto_loading_step_timer = nullptr;
  }
}
/* ===== New Favorites Page ===== */
static void refreshNewFavoritesList() {
  if (!new_favorites_list || !lv_obj_is_valid(new_favorites_list)) return;
  
  lv_obj_clean(new_favorites_list);
  
  if (favoriteCoinCount == 0) {
    lv_obj_t *no_favorites = lv_label_create(new_favorites_list);
    lv_label_set_text(no_favorites, "No coins added yet.\nUse Favorites to add some.");
    lv_obj_set_style_text_color(no_favorites, COLOR_WHITE, 0);
    lv_obj_set_style_text_font(no_favorites, &poppins_medium_20, 0);  // Same font as title
    lv_obj_set_style_text_align(no_favorites, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_align(no_favorites, LV_ALIGN_CENTER, 0, 0);
    return;
  }
  
  // Vertical list layout - SCALED UP: wider buttons and larger fonts
  // List is 20% wider for better spacing
  const int list_width = 600;    // Full width (600px)
  const int button_width = 580;  // 20% wider than 500px (500 * 1.2 = 600, but use 580 for margins)
  const int button_height = 70;  // Increased from 60 to 70 - taller buttons
  const int v_spacing = 12;      // Spacing between buttons
  const int start_x = (list_width - button_width) / 2;  // Center horizontally
  const int start_y = 10;
  
  for (int i = 0; i < favoriteCoinCount; i++) {
    lv_obj_t *btn = lv_btn_create(new_favorites_list);
    lv_obj_set_size(btn, button_width, button_height);
    
    // Vertical positioning
    int y = start_y + (i * (button_height + v_spacing));
    lv_obj_set_pos(btn, start_x, y);
    
    // Control panel gray color with more rounded corners
    lv_obj_set_style_bg_color(btn, lv_color_make(10, 10, 10), 0);
    lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);  // Consistent rounded corners
    lv_obj_set_style_shadow_width(btn, 0, 0);  // Remove shadow/white line effect
    lv_obj_set_style_border_width(btn, 0, 0);  // Remove border
    
    // Store index in user data for click handler
    lv_obj_set_user_data(btn, (void*)(intptr_t)i);
    
    // Add drag-and-drop event handlers for reordering
    lv_obj_add_event_cb(btn, [](lv_event_t *e) {
      lv_event_code_t code = lv_event_get_code(e);
      lv_obj_t *btn = lv_event_get_target(e);
      int idx = (int)(intptr_t)lv_obj_get_user_data(btn);
      
      if (code == LV_EVENT_LONG_PRESSED) {
        // Start drag operation
        favorites_dragging = true;
        drag_source_index = idx;
        
        // Disable list scrolling during drag
        if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
          lv_obj_clear_flag(new_favorites_list, LV_OBJ_FLAG_SCROLLABLE);
        }
        
        // Save the button's current position (this is where it should stay initially)
        drag_start_y = lv_obj_get_y(btn);
        
        // Get initial touch position to track offset from button
        lv_indev_t *indev = lv_indev_get_act();
        if (indev) {
          lv_point_t point;
          lv_indev_get_point(indev, &point);
          // Account for list scroll when getting touch position
          int32_t scroll_y = 0;
          if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
            scroll_y = lv_obj_get_scroll_y(new_favorites_list);
          }
          drag_current_y = point.y + scroll_y;
        }
        
        Serial.printf("[Favorites] Long press detected - drag started for index %d at y=%d\n", idx, drag_start_y);
        
        // Visual feedback: make button slightly transparent and move to top layer
        lv_obj_set_style_opa(btn, LV_OPA_70, 0);
        lv_obj_move_foreground(btn);
      }
      else if (code == LV_EVENT_PRESSING && favorites_dragging && drag_source_index == idx) {
        // Update drag position - move button by the delta from initial touch
        lv_indev_t *indev = lv_indev_get_act();
        if (indev) {
          lv_point_t point;
          lv_indev_get_point(indev, &point);
          
          // Account for list scroll position
          int32_t scroll_y = 0;
          if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
            scroll_y = lv_obj_get_scroll_y(new_favorites_list);
          }
          
          // Calculate the delta from where we started
          int32_t current_touch_y = point.y + scroll_y;
          int32_t delta_y = current_touch_y - drag_current_y;
          
          // Move button by the delta (keeps button under finger)
          int32_t new_y = drag_start_y + delta_y;
          lv_obj_set_y(btn, new_y);
        }
      }
      else if (code == LV_EVENT_RELEASED && favorites_dragging && drag_source_index == idx) {
        // End drag - calculate drop position
        Serial.printf("[Favorites] Drag ended for index %d\n", drag_source_index);
        
        // Restore button opacity
        lv_obj_set_style_opa(btn, LV_OPA_COVER, 0);
        
        // Calculate which position this should be dropped at
        const int button_height = 70;
        const int v_spacing = 12;
        const int item_height = button_height + v_spacing;
        const int start_y = 10;
        
        int drop_index = (lv_obj_get_y(btn) - start_y + item_height / 2) / item_height;
        
        // Clamp to valid range
        if (drop_index < 0) drop_index = 0;
        if (drop_index >= favoriteCoinCount) drop_index = favoriteCoinCount - 1;
        
        Serial.printf("[Favorites] Drop calculated at index %d (from %d)\n", drop_index, drag_source_index);
        
        // Reorder the favorites array
        if (drop_index != drag_source_index) {
          String movedCoin = favoriteCoinSymbols[drag_source_index];
          
          // Shift items to make room
          if (drop_index < drag_source_index) {
            // Moving up
            for (int j = drag_source_index; j > drop_index; j--) {
              favoriteCoinSymbols[j] = favoriteCoinSymbols[j - 1];
            }
          } else {
            // Moving down
            for (int j = drag_source_index; j < drop_index; j++) {
              favoriteCoinSymbols[j] = favoriteCoinSymbols[j + 1];
            }
          }
          
          favoriteCoinSymbols[drop_index] = movedCoin;
          
          // Save to NVS
          saveFavoriteCoins();
          
          // Update pairs array order to match new favorites order
          updateSelectedPairs();
          
          // Refresh the list
          refreshNewFavoritesList();
          
          Serial.printf("[Favorites] Reordered: moved %s from %d to %d\n", 
                       movedCoin.c_str(), drag_source_index, drop_index);
        } else {
          // Dropped at same position - just refresh to restore layout
          refreshNewFavoritesList();
        }
        
        // Re-enable list scrolling
        if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
          lv_obj_add_flag(new_favorites_list, LV_OBJ_FLAG_SCROLLABLE);
        }
        
        // Reset drag state
        favorites_dragging = false;
        drag_source_index = -1;
      }
      else if (code == LV_EVENT_CLICKED && !favorites_dragging) {
        // Only handle click if we're not dragging
      
      if (idx >= 0 && idx < favoriteCoinCount) {
        coin_to_unfavorite = favoriteCoinSymbols[idx];
        
        // Save current scroll position before showing popup
        if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
          saved_favorites_scroll_y = lv_obj_get_scroll_y(new_favorites_list);
        }
        
        // Create unfavorite confirmation popup
        if (!unfavorite_popup || !lv_obj_is_valid(unfavorite_popup)) {
          unfavorite_popup = lv_obj_create(new_favorites_screen);
          lv_obj_set_size(unfavorite_popup, 420, 180); // Wider and taller
          lv_obj_align(unfavorite_popup, LV_ALIGN_CENTER, 0, -10);
          lv_obj_set_style_bg_color(unfavorite_popup, lv_color_make(10, 10, 10), 0); // Match control panel dark gray
          lv_obj_set_style_radius(unfavorite_popup, 15, 0);
          lv_obj_set_style_border_width(unfavorite_popup, 0, 0); // Remove white outline
          lv_obj_clear_flag(unfavorite_popup, LV_OBJ_FLAG_SCROLLABLE);
          
          unfavorite_popup_label = lv_label_create(unfavorite_popup);
          lv_obj_align(unfavorite_popup_label, LV_ALIGN_TOP_MID, 0, 20); // 15px more down (was 5, now 20)
          lv_obj_set_style_text_font(unfavorite_popup_label, &poppins_light_20, 0);
          lv_obj_set_style_text_color(unfavorite_popup_label, COLOR_WHITE, 0);
          lv_obj_set_style_text_align(unfavorite_popup_label, LV_TEXT_ALIGN_CENTER, 0);
          
          // No button (white, left) - 15% smaller width
          unfavorite_no_btn = lv_btn_create(unfavorite_popup);
          lv_obj_set_size(unfavorite_no_btn, 153, 45); // 15% smaller (was 180)
          lv_obj_align(unfavorite_no_btn, LV_ALIGN_BOTTOM_LEFT, 20, -5);
          lv_obj_set_style_bg_color(unfavorite_no_btn, COLOR_WHITE, 0);
          lv_obj_set_style_radius(unfavorite_no_btn, BUTTON_RADIUS, 0);
          lv_obj_add_event_cb(unfavorite_no_btn, [](lv_event_t *e) {
            // Just close popup and restore scroll position
            if (unfavorite_popup && lv_obj_is_valid(unfavorite_popup)) {
              lv_obj_del(unfavorite_popup);
              unfavorite_popup = nullptr;
            }
            coin_to_unfavorite = "";  // Clear the pending removal
            
            // Restore the saved scroll position to prevent auto-scroll to bottom
            if (new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
              lv_obj_scroll_to_y(new_favorites_list, saved_favorites_scroll_y, LV_ANIM_OFF);
            }
  }, LV_EVENT_CLICKED, NULL);

          lv_obj_t *no_label = lv_label_create(unfavorite_no_btn);
          lv_label_set_text(no_label, "No");
          lv_obj_set_style_text_color(no_label, COLOR_BLACK, 0);
          lv_obj_set_style_text_font(no_label, &poppins_medium_20, 0);
          lv_obj_center(no_label);
          
          // Yes button (red, right) - 15% smaller width
          unfavorite_yes_btn = lv_btn_create(unfavorite_popup);
          lv_obj_set_size(unfavorite_yes_btn, 153, 45); // 15% smaller (was 180)
          lv_obj_align(unfavorite_yes_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -5);
          lv_obj_set_style_bg_color(unfavorite_yes_btn, COLOR_RED, 0);
          lv_obj_set_style_radius(unfavorite_yes_btn, BUTTON_RADIUS, 0);
          lv_obj_add_event_cb(unfavorite_yes_btn, [](lv_event_t *e) {
            // Remove the coin from favorites
            if (coin_to_unfavorite.length() > 0) {
              toggleCoinFavorite(coin_to_unfavorite, "");
              coin_to_unfavorite = "";
              
              // Close popup
              if (unfavorite_popup && lv_obj_is_valid(unfavorite_popup)) {
                lv_obj_del(unfavorite_popup);
                unfavorite_popup = nullptr;
              }
              
              // Just refresh the list - DON'T recreate page to avoid price reload
              refreshNewFavoritesList();
              
              // Update counter manually - counter_bg is 3rd child, label is inside it
              lv_obj_t *counter_bg = lv_obj_get_child(new_favorites_screen, 2);
              if (counter_bg && lv_obj_is_valid(counter_bg)) {
                if (favoriteCoinCount == 0) {
                  lv_obj_add_flag(counter_bg, LV_OBJ_FLAG_HIDDEN);
                } else {
                  // Get the label inside the counter background
                  lv_obj_t *counter_label = lv_obj_get_child(counter_bg, 0);
                  if (counter_label && lv_obj_is_valid(counter_label)) {
                    lv_label_set_text_fmt(counter_label, "%d/%d", favoriteCoinCount, MAX_FAVORITE_COINS);
                  }
                }
              }
            }
          }, LV_EVENT_CLICKED, NULL);
          
          lv_obj_t *yes_label = lv_label_create(unfavorite_yes_btn);
          lv_label_set_text(yes_label, "Yes");
          lv_obj_set_style_text_color(yes_label, COLOR_BLACK, 0);
          lv_obj_set_style_text_font(yes_label, &poppins_medium_20, 0);
          lv_obj_center(yes_label);
        }
        
        // Update popup label with coin name (one row now that popup is wider)
        if (unfavorite_popup_label && lv_obj_is_valid(unfavorite_popup_label)) {
          String baseCoin = coin_to_unfavorite;
          if (baseCoin.endsWith("USDT")) {
            baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
          }
          lv_label_set_text_fmt(unfavorite_popup_label, "Remove %s from favorites?", baseCoin.c_str());
        }
        
        // Show popup
        lv_obj_clear_flag(unfavorite_popup, LV_OBJ_FLAG_HIDDEN);
      }
      }
    }, LV_EVENT_ALL, NULL);  // Register for all events to handle drag-and-drop
    
    // Extract base coin name (remove USDT suffix)
    String baseCoin = favoriteCoinSymbols[i];
    if (baseCoin.endsWith("USDT")) {
      baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
    }
    
    // Find the pair index to get price data
    int pairIdx = -1;
    for (int p = 0; p < active_pair_count; p++) {
      if (pairs[p].symbol == favoriteCoinSymbols[i]) {
        pairIdx = p;
        break;
      }
    }
    
    // Coin name (left-aligned) - Layout: coinname left, price middle, % right
    lv_obj_t *name_label = lv_label_create(btn);
    lv_label_set_text(name_label, baseCoin.c_str());
    lv_obj_set_style_text_font(name_label, &poppins_medium_20, 0);
    lv_obj_align(name_label, LV_ALIGN_LEFT_MID, 25, 0);  // Left-aligned
    
    // Price and daily % layout: Price (center), % (right) - color based on daily change
    if (pairIdx >= 0 && pairs[pairIdx].last_price > 0.0f) {
      // Get formatted price
      char price_buf[30];
      formatPriceWithCommas(pairs[pairIdx].last_price, price_buf, sizeof(price_buf), pairIdx);
      
      // Get daily % change
      float daily_change_percent = pairs[pairIdx].daily_change_percent;
      
      // Color based on daily change (green for positive, red for negative, white for zero)
      lv_color_t text_color = COLOR_WHITE;  // Default when no change data
      if (daily_change_percent > 0.0f) {
        text_color = COLOR_GREEN;
      } else if (daily_change_percent < 0.0f) {
        text_color = COLOR_RED;
      }
      
      // Price (center) - Middle position
      char price_text[40];
      snprintf(price_text, sizeof(price_text), "$%s", price_buf);
      
      lv_obj_t *price_label = lv_label_create(btn);
      lv_label_set_text(price_label, price_text);
      lv_obj_set_style_text_font(price_label, &poppins_medium_20, 0);
      lv_obj_align(price_label, LV_ALIGN_CENTER, 0, 0);  // Centered (middle)
      lv_obj_set_style_text_color(price_label, text_color, 0);
      
      // Daily % (right) - Right-aligned
      if (daily_change_percent != 0.0f) {
        char percent_text[20];
        char sign = (daily_change_percent > 0) ? '+' : '-';
        snprintf(percent_text, sizeof(percent_text), "%c%.2f%%", sign, fabs(daily_change_percent));
        
        lv_obj_t *percent_label = lv_label_create(btn);
        lv_label_set_text(percent_label, percent_text);
        lv_obj_set_style_text_font(percent_label, &poppins_medium_20, 0);
        lv_obj_align(percent_label, LV_ALIGN_RIGHT_MID, -25, 0);  // Right-aligned
        lv_obj_set_style_text_color(percent_label, text_color, 0);
      }
      
      // Coin name color
      lv_obj_set_style_text_color(name_label, text_color, 0);
    } else {
      // No price data - show "Loading price.." in red
      lv_obj_t *loading_label = lv_label_create(btn);
      lv_label_set_text(loading_label, "Loading price..");
      lv_obj_set_style_text_font(loading_label, &poppins_medium_20, 0);
      lv_obj_align(loading_label, LV_ALIGN_CENTER, 0, 0);  // Centered (middle)
      lv_obj_set_style_text_color(loading_label, COLOR_RED, 0);
      
      // Coin name in white
      lv_obj_set_style_text_color(name_label, COLOR_WHITE, 0);
    }
  }
}
static void createNewFavoritesPage() {
  new_favorites_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(new_favorites_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(new_favorites_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(new_favorites_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(new_favorites_screen);
  
  // Ensure pairs array is populated with favorite coins (needed for price/% display)
  if (active_pair_count == 0 && favoriteCoinCount > 0) {
    for (int i = 0; i < favoriteCoinCount && i < PAIR_COUNT; i++) {
      String symbol = favoriteCoinSymbols[i];
      String baseCoin = symbol;
      if (baseCoin.endsWith("USDT")) {
        baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
      }
      
      pairs[i].symbol = symbol;
      pairs[i].display_name = baseCoin;
      pairs[i].last_price = 0.0f;
      pairs[i].last_update = 0;
      pairs[i].daily_change_percent = 0.0f;
      pairs[i].last_ticker_update = 0;
      pairs[i].candle_count = 0;
      pairs[i].is_selected = true;
      active_pair_count++;
    }
  }
  
  // DON'T fetch ticker data here - it blocks the UI for 30+ seconds!
  // Instead, the background timer in loop() will fetch data every 60s
  // Display will show with cached data (if available) or without prices initially

  // Logo at top
  lv_obj_t *logo = lv_img_create(new_favorites_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Title - always show (matching Settings page font)
  lv_obj_t *title_label = lv_label_create(new_favorites_screen);
  lv_label_set_text(title_label, "Favorites");
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);  // Same as Settings
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);
  
  // Favorites counter (X/9) with dark background for better readability
  // Create background container
  lv_obj_t *counter_bg = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(counter_bg, 80, 30);
  lv_obj_align(counter_bg, LV_ALIGN_TOP_MID, 0, 95);
  lv_obj_set_style_bg_color(counter_bg, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(counter_bg, 180, 0); // Semi-transparent dark background
  lv_obj_set_style_radius(counter_bg, 15, 0);
  lv_obj_set_style_border_width(counter_bg, 0, 0);
  lv_obj_clear_flag(counter_bg, LV_OBJ_FLAG_SCROLLABLE);
  
  // Create counter label on top of background
  lv_obj_t *counter_label = lv_label_create(counter_bg);
  lv_label_set_text_fmt(counter_label, "%d/%d", favoriteCoinCount, MAX_FAVORITE_COINS);
  lv_obj_set_style_text_color(counter_label, lv_color_make(200, 200, 200), 0); // Lighter gray for better contrast
  lv_obj_set_style_text_font(counter_label, &poppins_light_20, 0);
  lv_obj_center(counter_label);
  
  // Hide counter if no favorites
  if (favoriteCoinCount == 0) {
    lv_obj_add_flag(counter_bg, LV_OBJ_FLAG_HIDDEN);
  }

  // Scrollable list for favorites - 20% wider (600px full width, buttons will be wider too)
  new_favorites_list = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(new_favorites_list, 600, 330);  // Full width (600px screen)
  lv_obj_align(new_favorites_list, LV_ALIGN_CENTER, 0, 55);  // Moved down 25 pixels (was 30, now 55)
  lv_obj_set_style_bg_color(new_favorites_list, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(new_favorites_list, LV_OPA_TRANSP, 0); // Make background transparent
  lv_obj_set_style_border_width(new_favorites_list, 0, 0);
  lv_obj_set_style_border_opa(new_favorites_list, LV_OPA_TRANSP, 0); // Ensure border is transparent
  lv_obj_set_style_outline_width(new_favorites_list, 0, 0); // Remove outline
  lv_obj_set_style_shadow_width(new_favorites_list, 0, 0); // Remove any shadow
  lv_obj_set_style_radius(new_favorites_list, 0, 0);
  lv_obj_set_style_pad_all(new_favorites_list, 0, 0); // Remove all padding to prevent white dots
  lv_obj_set_style_pad_bottom(new_favorites_list, 120, 0); // Add bottom padding for better scrolling
  lv_obj_set_style_pad_top(new_favorites_list, 0, 0); // No top padding to prevent covering counter
  lv_obj_set_scrollbar_mode(new_favorites_list, LV_SCROLLBAR_MODE_OFF);
  lv_obj_set_scroll_dir(new_favorites_list, LV_DIR_VER);

  // Back button - smaller width to fit edit coins in between
  new_favorites_back_btn = lv_btn_create(new_favorites_screen);
  lv_obj_set_size(new_favorites_back_btn, 120, 50);
  lv_obj_align(new_favorites_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(new_favorites_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(new_favorites_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(new_favorites_back_btn, [](lv_event_t *e) {
    createHomepage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(new_favorites_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_center(back_label);

  // Favorites button (white with black text, positioned between Back and Continue)
  new_favorites_manage_btn = lv_btn_create(new_favorites_screen);
  lv_obj_set_size(new_favorites_manage_btn, 200, 50);
  lv_obj_align(new_favorites_manage_btn, LV_ALIGN_BOTTOM_MID, -40, -20); // Center bottom, shifted 40px left
  lv_obj_set_style_bg_color(new_favorites_manage_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(new_favorites_manage_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_shadow_width(new_favorites_manage_btn, 0, 0);  // Remove shadow effect
  lv_obj_add_event_cb(new_favorites_manage_btn, [](lv_event_t *e) {
    createCoinSearchPage();
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *manage_coins_label = lv_label_create(new_favorites_manage_btn);
  lv_label_set_text(manage_coins_label, "Edit");
  lv_obj_set_style_text_color(manage_coins_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(manage_coins_label, &poppins_medium_20, 0);
  lv_obj_center(manage_coins_label);

  // Continue button (gray and disabled if no coins, otherwise colored based on WiFi)
  new_favorites_continue_btn = lv_btn_create(new_favorites_screen);
  lv_obj_set_size(new_favorites_continue_btn, 200, 50);
  lv_obj_align(new_favorites_continue_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -20);
  lv_obj_set_style_radius(new_favorites_continue_btn, BUTTON_RADIUS, 0);
  
  if (favoriteCoinCount == 0) {
    // No favorites - keep white but reduce opacity and disable
    lv_obj_set_style_bg_color(new_favorites_continue_btn, COLOR_WHITE, 0);
    lv_obj_set_style_bg_opa(new_favorites_continue_btn, 128, 0);
    lv_obj_add_state(new_favorites_continue_btn, LV_STATE_DISABLED);
  } else {
    // Has favorites - always white
    lv_obj_clear_flag(new_favorites_continue_btn, LV_OBJ_FLAG_HIDDEN);
    lv_obj_set_style_bg_color(new_favorites_continue_btn, COLOR_WHITE, 0);
    lv_obj_set_style_bg_opa(new_favorites_continue_btn, 255, 0);
    lv_obj_clear_state(new_favorites_continue_btn, LV_STATE_DISABLED);
  }
  
  lv_obj_add_event_cb(new_favorites_continue_btn, [](lv_event_t *e) {
    // If no favorites, button is disabled - do nothing
    if (favoriteCoinCount == 0) {
      return;
    }
    
    // Check WiFi connection before proceeding
    if (WiFi.status() != WL_CONNECTED) {
      // Show error message above the continue button
      lv_obj_t *error_label = lv_label_create(new_favorites_screen);
      lv_label_set_text(error_label, "Please connect to Wi-Fi");
      lv_obj_set_style_text_color(error_label, COLOR_RED, 0);
      lv_obj_set_style_text_font(error_label, &poppins_medium_20, 0);
      lv_obj_align(error_label, LV_ALIGN_BOTTOM_RIGHT, -20, -80);
      
      // Fade out animation after 3 seconds
      lv_anim_t fade_anim;
      lv_anim_init(&fade_anim);
      lv_anim_set_var(&fade_anim, error_label);
      lv_anim_set_values(&fade_anim, 255, 0);
      lv_anim_set_time(&fade_anim, 500);
      lv_anim_set_exec_cb(&fade_anim, (lv_anim_exec_xcb_t)lv_obj_set_style_opa);
      lv_anim_set_delay(&fade_anim, 3000);
      lv_anim_set_path_cb(&fade_anim, lv_anim_path_linear);
      
      // Create timer to delete label after fade completes
      lv_timer_t *error_timer = lv_timer_create([](lv_timer_t *t) {
        lv_obj_t *label = (lv_obj_t *)t->user_data;
        if (label && lv_obj_is_valid(label)) {
          lv_obj_del(label);
        }
        lv_timer_del(t);
      }, 3500, error_label);
      lv_timer_set_repeat_count(error_timer, 1);
      
      lv_anim_start(&fade_anim);
      
      return;
    }
    
    // Show loading screen
    createCryptoLoadingScreen();
    
    // Clean up old timers first
    if (crypto_loading_step_timer) {
      lv_timer_del(crypto_loading_step_timer);
      crypto_loading_step_timer = nullptr;
    }
    if (crypto_loading_timer) {
      lv_timer_del(crypto_loading_timer);
      crypto_loading_timer = nullptr;
    }
    
    // Force UI to update and show the loading screen at 0%
    lv_timer_handler();
    
    // Trigger data loading after 1 second (progress bar will be at 20%)
    // This gives the progress bar time to animate smoothly first
    lv_timer_t *data_load_trigger = lv_timer_create([](lv_timer_t *t){
      cryptoLoadingStepTimer(t); // This will block for ~2 seconds during HTTP call
    }, 1000, NULL);
    lv_timer_set_repeat_count(data_load_trigger, 1);
    
    // Start the FAKE 5-second progress bar animation IMMEDIATELY (purely cosmetic)
    uint32_t loading_start_time = millis();
    crypto_loading_timer = lv_timer_create([](lv_timer_t *t){
      uint32_t start_time = (uint32_t)(uintptr_t)t->user_data;
      uint32_t elapsed = millis() - start_time;
      int percentage = (elapsed * 100) / 5000; // 0-100% over 5 seconds
      
      if (percentage > 100) percentage = 100;
      
      // Update bar and text together (always in sync)
      if (crypto_loading_bar && lv_obj_is_valid(crypto_loading_bar)) {
        lv_bar_set_value(crypto_loading_bar, percentage, LV_ANIM_OFF);
      }
      if (crypto_loading_label && lv_obj_is_valid(crypto_loading_label)) {
        lv_label_set_text_fmt(crypto_loading_label, "Loading... %d%%", percentage);
      }
      
      // When we reach 100%, show the screen (data should be loaded by now)
      if (percentage >= 100) {
        if (crypto_loading_timer) {
          lv_timer_del(crypto_loading_timer);
          crypto_loading_timer = nullptr;
        }
        startCryptoDisplay();
      }
    }, 50, (void*)(uintptr_t)loading_start_time);
    lv_timer_set_repeat_count(crypto_loading_timer, -1); // Repeat until 100%
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *continue_label = lv_label_create(new_favorites_continue_btn);
  lv_label_set_text(continue_label, "Continue");  // Always says "Continue" now
  lv_obj_set_style_text_color(continue_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(continue_label, &poppins_medium_20, 0);
  lv_obj_center(continue_label);
  
  // Create fade effect at bottom using multiple layered rectangles (extends 45% up from bottom)
  // LVGL doesn't support opacity gradients, so we layer rectangles with increasing opacity
  
  // Layer 1 (top) - 10% opacity
  lv_obj_t *fade_layer1 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer1, 400, 25);
  lv_obj_align(fade_layer1, LV_ALIGN_BOTTOM_MID, 0, -125);
  lv_obj_set_style_bg_color(fade_layer1, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer1, LV_OPA_10, 0);
  lv_obj_set_style_border_width(fade_layer1, 0, 0);
  lv_obj_set_style_radius(fade_layer1, 0, 0);
  lv_obj_clear_flag(fade_layer1, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer1, LV_OBJ_FLAG_SCROLLABLE);
  
  // Layer 2 - 20% opacity
  lv_obj_t *fade_layer2 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer2, 400, 25);
  lv_obj_align(fade_layer2, LV_ALIGN_BOTTOM_MID, 0, -100);
  lv_obj_set_style_bg_color(fade_layer2, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer2, LV_OPA_20, 0);
  lv_obj_set_style_border_width(fade_layer2, 0, 0);
  lv_obj_set_style_radius(fade_layer2, 0, 0);
  lv_obj_clear_flag(fade_layer2, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer2, LV_OBJ_FLAG_SCROLLABLE);
  
  // Layer 3 - 30% opacity
  lv_obj_t *fade_layer3 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer3, 400, 25);
  lv_obj_align(fade_layer3, LV_ALIGN_BOTTOM_MID, 0, -75);
  lv_obj_set_style_bg_color(fade_layer3, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer3, LV_OPA_30, 0);
  lv_obj_set_style_border_width(fade_layer3, 0, 0);
  lv_obj_set_style_radius(fade_layer3, 0, 0);
  lv_obj_clear_flag(fade_layer3, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer3, LV_OBJ_FLAG_SCROLLABLE);
  // Layer 4 - 50% opacity
  lv_obj_t *fade_layer4 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer4, 400, 25);
  lv_obj_align(fade_layer4, LV_ALIGN_BOTTOM_MID, 0, -50);
  lv_obj_set_style_bg_color(fade_layer4, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer4, LV_OPA_50, 0);
  lv_obj_set_style_border_width(fade_layer4, 0, 0);
  lv_obj_set_style_radius(fade_layer4, 0, 0);
  lv_obj_clear_flag(fade_layer4, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer4, LV_OBJ_FLAG_SCROLLABLE);
  
  // Layer 5 - 70% opacity
  lv_obj_t *fade_layer5 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer5, 400, 25);
  lv_obj_align(fade_layer5, LV_ALIGN_BOTTOM_MID, 0, -25);
  lv_obj_set_style_bg_color(fade_layer5, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer5, LV_OPA_70, 0);
  lv_obj_set_style_border_width(fade_layer5, 0, 0);
  lv_obj_set_style_radius(fade_layer5, 0, 0);
  lv_obj_clear_flag(fade_layer5, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer5, LV_OBJ_FLAG_SCROLLABLE);
  
  // Layer 6 (bottom) - 100% opacity
  lv_obj_t *fade_layer6 = lv_obj_create(new_favorites_screen);
  lv_obj_set_size(fade_layer6, 400, 25);
  lv_obj_align(fade_layer6, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_obj_set_style_bg_color(fade_layer6, COLOR_BLACK, 0);
  lv_obj_set_style_bg_opa(fade_layer6, LV_OPA_COVER, 0);
  lv_obj_set_style_border_width(fade_layer6, 0, 0);
  lv_obj_set_style_radius(fade_layer6, 0, 0);
  lv_obj_clear_flag(fade_layer6, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(fade_layer6, LV_OBJ_FLAG_SCROLLABLE);
  
  // Layer ordering: Keep fade layers above list but below buttons
  lv_obj_move_foreground(fade_layer1);
  lv_obj_move_foreground(fade_layer2);
  lv_obj_move_foreground(fade_layer3);
  lv_obj_move_foreground(fade_layer4);
  lv_obj_move_foreground(fade_layer5);
  lv_obj_move_foreground(fade_layer6);
  
  // Move buttons and static elements above fade
  lv_obj_move_foreground(new_favorites_back_btn);
  lv_obj_move_foreground(new_favorites_manage_btn);
  lv_obj_move_foreground(new_favorites_continue_btn);
  lv_obj_move_foreground(logo);
  lv_obj_move_foreground(title_label);
  lv_obj_move_foreground(counter_bg);  // Keep counter background above everything
  
  // Move WiFi signal to this screen
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(new_favorites_screen);
  }
  
  // Display favorites
  refreshNewFavoritesList();

  encoderFocusBegin(new_favorites_screen);
  if (new_favorites_back_btn && lv_obj_is_valid(new_favorites_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(new_favorites_back_btn, 0);
    encoderFocusAdd(new_favorites_back_btn, label);
  }
  if (new_favorites_manage_btn && lv_obj_is_valid(new_favorites_manage_btn)) {
    lv_obj_t *label = lv_obj_get_child(new_favorites_manage_btn, 0);
    encoderFocusAdd(new_favorites_manage_btn, label);
  }
  if (new_favorites_continue_btn && lv_obj_is_valid(new_favorites_continue_btn)) {
    lv_obj_t *label = lv_obj_get_child(new_favorites_continue_btn, 0);
    encoderFocusAdd(new_favorites_continue_btn, label);
  }
  encoderFocusCommit(0);

  showCoinInfoIcon();
}

/* ===== Settings Page ===== */
static bool settings_page_initialized = false;
static bool about_page_initialized = false;

static void setupSettingsFocus() {
  if (!settings_screen || !lv_obj_is_valid(settings_screen)) return;

  encoderFocusBegin(settings_screen);

  if (settings_wifi_btn && lv_obj_is_valid(settings_wifi_btn)) {
    lv_obj_t *label = lv_obj_get_child(settings_wifi_btn, 0);
    encoderFocusAdd(settings_wifi_btn, label);
  }
  if (settings_brightness_btn && lv_obj_is_valid(settings_brightness_btn)) {
    lv_obj_t *label = lv_obj_get_child(settings_brightness_btn, 0);
    encoderFocusAdd(settings_brightness_btn, label);
  }
  if (settings_about_btn && lv_obj_is_valid(settings_about_btn)) {
    lv_obj_t *label = lv_obj_get_child(settings_about_btn, 0);
    encoderFocusAdd(settings_about_btn, label);
  }
  if (settings_back_btn && lv_obj_is_valid(settings_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(settings_back_btn, 0);
    encoderFocusAdd(settings_back_btn, label);
  }

  encoderFocusCommit(0);
}

static void createSettingsPage() {
  // Reuse existing screen if already initialized
  if (!settings_page_initialized) {
  settings_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(settings_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(settings_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(settings_screen, LV_OBJ_FLAG_SCROLLABLE);

    // Logo
  lv_obj_t *logo = lv_img_create(settings_screen);
    LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

    // Title
    lv_obj_t *title_label = lv_label_create(settings_screen);
    lv_label_set_text(title_label, "Settings");
    lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
    lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

    // Wi-Fi button
    settings_wifi_btn = lv_btn_create(settings_screen);
    lv_obj_set_size(settings_wifi_btn, 300, 60);
    lv_obj_align(settings_wifi_btn, LV_ALIGN_CENTER, 0, -80);
    lv_obj_set_style_bg_color(settings_wifi_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(settings_wifi_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(settings_wifi_btn, wifi_settings_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *wifi_label = lv_label_create(settings_wifi_btn);
  lv_label_set_text(wifi_label, "Wi-Fi");
  lv_obj_set_style_text_font(wifi_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(wifi_label, COLOR_BLACK, 0);
  lv_obj_center(wifi_label);

    // Display & Brightness button
    settings_brightness_btn = lv_btn_create(settings_screen);
    lv_obj_set_size(settings_brightness_btn, 300, 60);
    lv_obj_align(settings_brightness_btn, LV_ALIGN_CENTER, 0, -10);
    lv_obj_set_style_bg_color(settings_brightness_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(settings_brightness_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(settings_brightness_btn, brightness_settings_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *brightness_label = lv_label_create(settings_brightness_btn);
  lv_label_set_text(brightness_label, "Display & Brightness");
  lv_obj_set_style_text_font(brightness_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(brightness_label, COLOR_BLACK, 0);
  lv_obj_center(brightness_label);

    // About button
    settings_about_btn = lv_btn_create(settings_screen);
    lv_obj_set_size(settings_about_btn, 300, 60);
    lv_obj_align(settings_about_btn, LV_ALIGN_CENTER, 0, 60);
    lv_obj_set_style_bg_color(settings_about_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(settings_about_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(settings_about_btn, about_settings_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *about_label = lv_label_create(settings_about_btn);
    lv_label_set_text(about_label, "About");
    lv_obj_set_style_text_font(about_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(about_label, COLOR_BLACK, 0);
    lv_obj_center(about_label);

    // Back button
    settings_back_btn = lv_btn_create(settings_screen);
    lv_obj_set_size(settings_back_btn, 120, 50);
    lv_obj_align(settings_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
    lv_obj_set_style_bg_color(settings_back_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(settings_back_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(settings_back_btn, settings_back_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *back_label = lv_label_create(settings_back_btn);
    lv_label_set_text(back_label, "Back");
    lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
    lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
    lv_obj_center(back_label);
    
    settings_page_initialized = true;
  }
  
  lv_scr_load(settings_screen);

  setupSettingsFocus();

  showCoinInfoIcon();
}
static void settings_back_btn_cb(lv_event_t * e) {
  lv_scr_load(homepage_screen);
  setupHomepageFocus();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(homepage_screen);
  }
}

static void wifi_settings_btn_cb(lv_event_t * e) {
  createWiFiSettingsPage();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(wifi_settings_screen);
  }
}

static void brightness_settings_btn_cb(lv_event_t * e) {
  createBrightnessPage();
}

static void about_settings_btn_cb(lv_event_t * e) {
  createAboutPage();
  // Move existing WiFi signal to About page (createWiFiSignal handles this)
  if (WiFi.status() == WL_CONNECTED && about_screen != ota_progress_screen) {
    createWiFiSignal(about_screen);
  }
}
/* ===== About Page ===== */
static void createAboutPage() {
  // Reuse existing screen if already initialized
  if (!about_page_initialized) {
    about_screen = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(about_screen, COLOR_BLACK, 0);
    lv_obj_set_scrollbar_mode(about_screen, LV_SCROLLBAR_MODE_OFF);
    lv_obj_clear_flag(about_screen, LV_OBJ_FLAG_SCROLLABLE);

    // Logo
    lv_obj_t *logo = lv_img_create(about_screen);
    LV_IMG_DECLARE(LumenLogo);
    lv_img_set_src(logo, &LumenLogo);
    lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
    lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

    // Title
    lv_obj_t *title_label = lv_label_create(about_screen);
    lv_label_set_text(title_label, "About");
    lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
    lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

    // Software Update button
    about_ota_btn = lv_btn_create(about_screen);
    lv_obj_set_size(about_ota_btn, 300, 60);
    lv_obj_align(about_ota_btn, LV_ALIGN_CENTER, 0, -20);
    lv_obj_set_style_bg_color(about_ota_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(about_ota_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(about_ota_btn, ota_settings_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *ota_label = lv_label_create(about_ota_btn);
    lv_label_set_text(ota_label, "Software Update");
    lv_obj_set_style_text_font(ota_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(ota_label, COLOR_BLACK, 0);
    lv_obj_center(ota_label);

    // Reboot button
    about_reboot_btn = lv_btn_create(about_screen);
    lv_obj_set_size(about_reboot_btn, 300, 60);
    lv_obj_align(about_reboot_btn, LV_ALIGN_CENTER, 0, 50);
    lv_obj_set_style_bg_color(about_reboot_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(about_reboot_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(about_reboot_btn, about_reboot_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *reboot_label = lv_label_create(about_reboot_btn);
    lv_label_set_text(reboot_label, "Reboot");
    lv_obj_set_style_text_font(reboot_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(reboot_label, COLOR_BLACK, 0);
    lv_obj_center(reboot_label);

    // Back button
    about_back_btn = lv_btn_create(about_screen);
    lv_obj_set_size(about_back_btn, 120, 50);
    lv_obj_align(about_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
    lv_obj_set_style_bg_color(about_back_btn, COLOR_WHITE, 0);
    lv_obj_set_style_radius(about_back_btn, BUTTON_RADIUS, 0);
    lv_obj_add_event_cb(about_back_btn, about_back_btn_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *back_label = lv_label_create(about_back_btn);
    lv_label_set_text(back_label, "Back");
    lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
    lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
    lv_obj_center(back_label);
    
    about_page_initialized = true;
  }
  
  lv_scr_load(about_screen);

  encoderFocusBegin(about_screen);
  if (about_ota_btn && lv_obj_is_valid(about_ota_btn)) {
    lv_obj_t *label = lv_obj_get_child(about_ota_btn, 0);
    encoderFocusAdd(about_ota_btn, label);
  }
  if (about_reboot_btn && lv_obj_is_valid(about_reboot_btn)) {
    lv_obj_t *label = lv_obj_get_child(about_reboot_btn, 0);
    encoderFocusAdd(about_reboot_btn, label);
  }
  if (about_back_btn && lv_obj_is_valid(about_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(about_back_btn, 0);
    encoderFocusAdd(about_back_btn, label);
  }
  encoderFocusCommit(0);

  showCoinInfoIcon();
}

static void about_back_btn_cb(lv_event_t * e) {
  createSettingsPage();
  // Move WiFi signal back to Settings page
  if (WiFi.status() == WL_CONNECTED && settings_screen) {
    createWiFiSignal(settings_screen);
  }
}

// Reboot confirmation popup
static lv_obj_t *reboot_confirm_overlay = nullptr;
static lv_obj_t *reboot_confirm_popup = nullptr;

static void reboot_confirm_yes_cb(lv_event_t * e) {
  Serial.println("Reboot confirmed - rebooting device...");
  delay(100);
  ESP.restart();
}

static void reboot_confirm_no_cb(lv_event_t * e) {
  Serial.println("Reboot cancelled");
  if (reboot_confirm_overlay && lv_obj_is_valid(reboot_confirm_overlay)) {
    lv_obj_del(reboot_confirm_overlay);
    reboot_confirm_overlay = nullptr;
    reboot_confirm_popup = nullptr;
  }
}

static void about_reboot_btn_cb(lv_event_t * e) {
  Serial.println("Reboot button clicked - showing confirmation...");
  
  // Create full-screen dimmed overlay (50% black)
  reboot_confirm_overlay = lv_obj_create(lv_layer_top());
  lv_obj_set_size(reboot_confirm_overlay, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(reboot_confirm_overlay, 0, 0);
  lv_obj_set_style_bg_color(reboot_confirm_overlay, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(reboot_confirm_overlay, 128, 0);
  lv_obj_set_style_border_width(reboot_confirm_overlay, 0, 0);
  lv_obj_set_style_radius(reboot_confirm_overlay, 0, 0);
  lv_obj_set_style_pad_all(reboot_confirm_overlay, 0, 0);
  lv_obj_clear_flag(reboot_confirm_overlay, LV_OBJ_FLAG_SCROLLABLE);
  
  // Create popup (small, centered) - same styling as other popups
  reboot_confirm_popup = lv_obj_create(reboot_confirm_overlay);
  lv_obj_set_size(reboot_confirm_popup, 350, 180);
  lv_obj_align(reboot_confirm_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(reboot_confirm_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_bg_opa(reboot_confirm_popup, 255, 0);
  lv_obj_set_style_border_width(reboot_confirm_popup, 0, 0);
  lv_obj_set_style_radius(reboot_confirm_popup, 20, 0);
  lv_obj_set_style_pad_all(reboot_confirm_popup, 20, 0);
  lv_obj_clear_flag(reboot_confirm_popup, LV_OBJ_FLAG_SCROLLABLE);
  
  // Title
  lv_obj_t *title = lv_label_create(reboot_confirm_popup);
  lv_label_set_text(title, "Are you sure you want\nto reboot?");
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_set_style_text_align(title, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 10);
  
  // No button (left, white background black text)
  lv_obj_t *no_btn = lv_btn_create(reboot_confirm_popup);
  lv_obj_set_size(no_btn, 130, 50);
  lv_obj_align(no_btn, LV_ALIGN_BOTTOM_LEFT, 0, 0);
  lv_obj_set_style_bg_color(no_btn, COLOR_WHITE, 0);
  lv_obj_set_style_border_width(no_btn, 0, 0);
  lv_obj_set_style_radius(no_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(no_btn, reboot_confirm_no_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *no_label = lv_label_create(no_btn);
  lv_label_set_text(no_label, "No");
  lv_obj_set_style_text_font(no_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(no_label, COLOR_BLACK, 0);
  lv_obj_center(no_label);
  
  // Yes button (right, red background black text)
  lv_obj_t *yes_btn = lv_btn_create(reboot_confirm_popup);
  lv_obj_set_size(yes_btn, 130, 50);
  lv_obj_align(yes_btn, LV_ALIGN_BOTTOM_RIGHT, 0, 0);
  lv_obj_set_style_bg_color(yes_btn, COLOR_RED, 0);
  lv_obj_set_style_border_width(yes_btn, 0, 0);
  lv_obj_set_style_radius(yes_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(yes_btn, reboot_confirm_yes_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *yes_label = lv_label_create(yes_btn);
  lv_label_set_text(yes_label, "Yes");
  lv_obj_set_style_text_font(yes_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(yes_label, COLOR_BLACK, 0);
  lv_obj_center(yes_label);
}
/* ===== iOS-style WiFi Symbol Helper ===== */
static lv_obj_t* createWiFiSignalIcon(lv_obj_t *parent, int rssi) {
  // Create container for both background and foreground icons
  lv_obj_t *wifi_container = lv_obj_create(parent);
  lv_obj_set_size(wifi_container, 30, 30);
  lv_obj_set_style_bg_opa(wifi_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(wifi_container, 0, 0);
  lv_obj_set_style_pad_all(wifi_container, 0, 0);
  // Tap to show Wi-Fi info popup (SSID + Forget)
  lv_obj_add_event_cb(wifi_container, [](lv_event_t *e){
    if (WiFi.status() == WL_CONNECTED) {
      show_wifi_info_popup(WiFi.SSID());
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create background 3-bar icon (low opacity)
  lv_obj_t *wifi_bg = lv_img_create(wifi_container);
  LV_IMG_DECLARE(Wifi3bar);
  lv_img_set_src(wifi_bg, &Wifi3bar);
  lv_obj_set_style_opa(wifi_bg, 30, 0); // Very low opacity (30/255)
  lv_obj_align(wifi_bg, LV_ALIGN_CENTER, 0, 0);
  
  // Create foreground icon based on signal strength
  lv_obj_t *wifi_icon = lv_img_create(wifi_container);
  
  // Convert RSSI to signal strength levels
  if (rssi >= -50) {
    // 4 bars - Excellent (use 3-bar image as highest)
    lv_img_set_src(wifi_icon, &Wifi3bar);
  } else if (rssi >= -60) {
    // 3 bars - Good
    lv_img_set_src(wifi_icon, &Wifi3bar);
  } else if (rssi >= -70) {
    // 2 bars - Fair
    LV_IMG_DECLARE(Wifi2bar);
    lv_img_set_src(wifi_icon, &Wifi2bar);
  } else if (rssi >= -80) {
    // 1 bar - Poor
    LV_IMG_DECLARE(Wifi1bar);
    lv_img_set_src(wifi_icon, &Wifi1bar);
  } else {
    // No signal - use 1 bar as minimum
    LV_IMG_DECLARE(Wifi1bar);
    lv_img_set_src(wifi_icon, &Wifi1bar);
  }
  
  lv_obj_align(wifi_icon, LV_ALIGN_CENTER, 0, 0);
  
  return wifi_container;
}
static void setupWiFiSettingsFocus() {
  if (!wifi_settings_screen || !lv_obj_is_valid(wifi_settings_screen)) return;

  encoderFocusBegin(wifi_settings_screen);

  if (wifi_settings_list && lv_obj_is_valid(wifi_settings_list) &&
      !lv_obj_has_flag(wifi_settings_list, LV_OBJ_FLAG_HIDDEN)) {
    uint32_t childCount = lv_obj_get_child_cnt(wifi_settings_list);
    for (uint32_t i = 0; i < childCount; i++) {
      lv_obj_t *item = lv_obj_get_child(wifi_settings_list, (int32_t)i);
      if (!item || !lv_obj_is_valid(item)) continue;
      if (lv_obj_has_flag(item, LV_OBJ_FLAG_HIDDEN)) continue;
      if (!lv_obj_has_flag(item, LV_OBJ_FLAG_CLICKABLE)) continue;
      lv_obj_t *text = (lv_obj_get_child_cnt(item) > 0) ? lv_obj_get_child(item, 0) : nullptr;
      encoderFocusAdd(item, text);
    }
  }

  if (wifi_settings_back_btn && lv_obj_is_valid(wifi_settings_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(wifi_settings_back_btn, 0);
    encoderFocusAdd(wifi_settings_back_btn, label);
  }
  if (wifi_settings_refresh_btn && lv_obj_is_valid(wifi_settings_refresh_btn)) {
    lv_obj_t *label = lv_obj_get_child(wifi_settings_refresh_btn, 0);
    encoderFocusAdd(wifi_settings_refresh_btn, label);
  }

  if (wifi_settings_popup && lv_obj_is_valid(wifi_settings_popup) &&
      !lv_obj_has_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN)) {
    if (wifi_settings_cancel_btn && lv_obj_is_valid(wifi_settings_cancel_btn)) {
      lv_obj_t *label = lv_obj_get_child(wifi_settings_cancel_btn, 0);
      encoderFocusAdd(wifi_settings_cancel_btn, label);
    }
    if (wifi_settings_connect_btn && lv_obj_is_valid(wifi_settings_connect_btn)) {
      lv_obj_t *label = lv_obj_get_child(wifi_settings_connect_btn, 0);
      encoderFocusAdd(wifi_settings_connect_btn, label);
    }
  }

  encoderFocusCommit(0);
}

/* ===== Wi-Fi Settings Page ===== */
static void createWiFiSettingsPage() {
  wifi_settings_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(wifi_settings_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(wifi_settings_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(wifi_settings_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(wifi_settings_screen);

  // Logo instead of title text (same as other pages)
  wifi_settings_logo = lv_img_create(wifi_settings_screen);
  LV_IMG_DECLARE(LumenLogo);  // Declare the image
  lv_img_set_src(wifi_settings_logo, &LumenLogo);
  lv_img_set_zoom(wifi_settings_logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(wifi_settings_logo, LV_ALIGN_TOP_MID, 0, 15);

  // Wi-Fi networks container
  wifi_settings_list = lv_obj_create(wifi_settings_screen);
  lv_obj_set_size(wifi_settings_list, 500, 300);
  lv_obj_align(wifi_settings_list, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(wifi_settings_list, COLOR_BLACK, 0); // Black background
  lv_obj_set_style_bg_opa(wifi_settings_list, LV_OPA_TRANSP, 0); // Transparent background
  lv_obj_set_style_radius(wifi_settings_list, 0, 0);
  lv_obj_set_style_border_width(wifi_settings_list, 0, 0);
  lv_obj_set_style_pad_all(wifi_settings_list, 0, 0); // Remove padding
  lv_obj_set_scrollbar_mode(wifi_settings_list, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(wifi_settings_list, LV_OBJ_FLAG_SCROLLABLE);

  // Back button
  wifi_settings_back_btn = lv_btn_create(wifi_settings_screen);
  lv_obj_set_size(wifi_settings_back_btn, 120, 50);
  lv_obj_align(wifi_settings_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(wifi_settings_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(wifi_settings_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(wifi_settings_back_btn, wifi_settings_back_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(wifi_settings_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label);

  // Refresh button (moved to bottom)
  wifi_settings_refresh_btn = lv_btn_create(wifi_settings_screen);
  lv_obj_set_size(wifi_settings_refresh_btn, 200, 50);
  lv_obj_align(wifi_settings_refresh_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -20);
  lv_obj_set_style_bg_color(wifi_settings_refresh_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(wifi_settings_refresh_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(wifi_settings_refresh_btn, wifi_settings_refresh_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *refresh_label = lv_label_create(wifi_settings_refresh_btn);
  lv_label_set_text(refresh_label, "Refresh");
  lv_obj_set_style_text_font(refresh_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(refresh_label, COLOR_BLACK, 0);
  lv_obj_center(refresh_label);

  // Popup for password entry
  wifi_settings_popup = lv_obj_create(wifi_settings_screen);
  lv_obj_set_size(wifi_settings_popup, 500, 200);
  lv_obj_add_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
  lv_obj_align(wifi_settings_popup, LV_ALIGN_BOTTOM_MID, 0, -220);
  lv_obj_set_style_bg_color(wifi_settings_popup, lv_color_make(10, 10, 10), 0); // Match WiFi list
  lv_obj_set_style_radius(wifi_settings_popup, 14, 0);
  lv_obj_set_style_border_width(wifi_settings_popup, 0, 0); // Remove white border

  wifi_settings_popup_label = lv_label_create(wifi_settings_popup);
  lv_label_set_text(wifi_settings_popup_label, "SSID:");
  lv_obj_align(wifi_settings_popup_label, LV_ALIGN_TOP_MID, 0, 5);
  lv_obj_set_style_text_color(wifi_settings_popup_label, COLOR_WHITE, 0);

  wifi_settings_password_ta = lv_textarea_create(wifi_settings_popup);
  lv_obj_set_size(wifi_settings_password_ta, 460, 45);
  lv_obj_align(wifi_settings_password_ta, LV_ALIGN_TOP_MID, 0, 50);
  lv_textarea_set_password_mode(wifi_settings_password_ta, false);
  lv_textarea_set_one_line(wifi_settings_password_ta, true);
  lv_textarea_set_text(wifi_settings_password_ta, "");
  lv_textarea_set_placeholder_text(wifi_settings_password_ta, "Password");
  
  // Style identical to coin search bar
  lv_obj_set_style_bg_color(wifi_settings_password_ta, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_text_color(wifi_settings_password_ta, COLOR_WHITE, 0);
  lv_obj_set_style_text_color(wifi_settings_password_ta, COLOR_WHITE, LV_PART_TEXTAREA_PLACEHOLDER);
  lv_obj_set_style_border_color(wifi_settings_password_ta, COLOR_WHITE, 0);
  lv_obj_set_style_border_width(wifi_settings_password_ta, 1, 0); // Thin border
  lv_obj_set_style_radius(wifi_settings_password_ta, 15, 0); // More rounded borders
  
  // Style the cursor (caret) to be white
  static lv_style_t wifi_password_cursor_style;
  lv_style_init(&wifi_password_cursor_style);
  lv_style_set_border_color(&wifi_password_cursor_style, COLOR_WHITE);
  lv_style_set_bg_color(&wifi_password_cursor_style, COLOR_WHITE);
  lv_obj_add_style(wifi_settings_password_ta, &wifi_password_cursor_style, LV_PART_CURSOR);

  wifi_settings_kb = lv_keyboard_create(wifi_settings_screen);
  lv_obj_align(wifi_settings_kb, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_keyboard_set_mode(wifi_settings_kb, LV_KEYBOARD_MODE_TEXT_LOWER);
  lv_obj_add_flag(wifi_settings_kb, LV_OBJ_FLAG_HIDDEN);
  lv_keyboard_set_textarea(wifi_settings_kb, wifi_settings_password_ta);

  wifi_settings_cancel_btn = lv_btn_create(wifi_settings_popup);
  lv_obj_set_size(wifi_settings_cancel_btn, 120, 40);
  // Place 120px left of center
  lv_obj_align(wifi_settings_cancel_btn, LV_ALIGN_BOTTOM_MID, -120, -5);
  lv_obj_set_style_bg_color(wifi_settings_cancel_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(wifi_settings_cancel_btn, BUTTON_RADIUS, 0);
  lv_obj_t *cancel_label = lv_label_create(wifi_settings_cancel_btn);
  lv_label_set_text(cancel_label, "Cancel");
  lv_obj_set_style_text_color(cancel_label, COLOR_BLACK, 0);
  lv_obj_center(cancel_label);
  lv_obj_add_event_cb(wifi_settings_cancel_btn, wifi_settings_cancel_btn_cb, LV_EVENT_CLICKED, NULL);

  wifi_settings_connect_btn = lv_btn_create(wifi_settings_popup);
  lv_obj_set_size(wifi_settings_connect_btn, 120, 40);
  // Place 120px right of center
  lv_obj_align(wifi_settings_connect_btn, LV_ALIGN_BOTTOM_MID, 120, -5);
  lv_obj_set_style_bg_color(wifi_settings_connect_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(wifi_settings_connect_btn, BUTTON_RADIUS, 0);
  lv_obj_t *btn_label = lv_label_create(wifi_settings_connect_btn);
  lv_label_set_text(btn_label, "Connect");
  lv_obj_set_style_text_color(btn_label, COLOR_BLACK, 0);
  lv_obj_center(btn_label);
  lv_obj_add_event_cb(wifi_settings_connect_btn, wifi_settings_connect_btn_cb, LV_EVENT_CLICKED, NULL);

  wifi_settings_connecting_label = lv_label_create(wifi_settings_popup);
  lv_label_set_text(wifi_settings_connecting_label, "Connecting...");
  lv_obj_set_style_text_font(wifi_settings_connecting_label, &poppins_extralight_14, 0);
  lv_obj_set_style_text_color(wifi_settings_connecting_label, COLOR_GREEN, 0);
  lv_obj_align(wifi_settings_connecting_label, LV_ALIGN_BOTTOM_MID, 0, -25); // Centered between buttons
  lv_obj_add_flag(wifi_settings_connecting_label, LV_OBJ_FLAG_HIDDEN);

  // Overlay will be created dynamically when popup is shown

  // Scan for networks
  wifi_settings_refresh_btn_cb(nullptr);

  setupWiFiSettingsFocus();

  showCoinInfoIcon();
}

static void wifi_settings_back_btn_cb(lv_event_t * e) {
  lv_scr_load(settings_screen);
  setupSettingsFocus();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(settings_screen);
  }
}

static void wifi_settings_refresh_btn_cb(lv_event_t * e) {
  // Check if WiFi settings list is valid
  if (!wifi_settings_list || !lv_obj_is_valid(wifi_settings_list)) {
    Serial.println("Error: WiFi settings list is not valid");
    return;
  }
  
  // Hide success message if it's showing
  if (wifi_settings_popup && lv_obj_is_valid(wifi_settings_popup)) {
    lv_obj_add_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
  }
  
  // Clear the container first
  lv_obj_clean(wifi_settings_list);
  
  // Add loading indicator (centered in the container)
  lv_obj_t *loading_label = lv_label_create(wifi_settings_list);
  if (loading_label && lv_obj_is_valid(loading_label)) {
    lv_label_set_text(loading_label, "Scanning...");
    lv_obj_set_style_text_font(loading_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(loading_label, COLOR_GREEN, 0);
    lv_obj_align(loading_label, LV_ALIGN_CENTER, 0, 0);
  }

  setupWiFiSettingsFocus();
  
  // Reset any previous scan state
  wifi_scan_in_progress = false;
  
  // CRITICAL: Ensure WiFi is in proper state before scanning
  // The ESP32 WiFi driver will fail immediately if WiFi is busy/connecting
  WiFi.scanDelete(); // Clear any previous scan results
  
  // Always disconnect first to ensure clean state
  // We need to ensure WiFi is FULLY disconnected before scanning
  // The first parameter needs to be TRUE to actually disconnect, but keep second FALSE to preserve credentials
  if (WiFi.status() != WL_DISCONNECTED) {
    Serial.println("Disconnecting from current WiFi...");
    WiFi.disconnect(true, false); // Fully disconnect but DON'T erase credentials
    
    // Wait for WiFi to fully disconnect (critical for scanning to work)
    unsigned long disconnectStart = millis();
    while (WiFi.status() != WL_DISCONNECTED && millis() - disconnectStart < 1000) {
      delay(50);
    }
    Serial.printf("WiFi status after disconnect: %d\n", WiFi.status());
  }
  
  delay(100); // Extra delay to ensure WiFi driver is ready
  
  // Ensure we're in station mode
  WiFi.mode(WIFI_STA);
  delay(100); // Let mode stabilize
  
  Serial.println("WiFi state reset, starting scan...");
  wifi_scan_start_time = millis();
  
  // Start scan in background - this will be handled in loop()
  // Limit scan to 8 networks to prevent overflow
  int scanResult = WiFi.scanNetworks(true); // true = async mode
  
  // Check if scan started successfully
  if (scanResult == WIFI_SCAN_FAILED) {
    Serial.println("WiFi scan failed to start - WiFi may be busy");
    lv_obj_clean(wifi_settings_list);
    lv_obj_t *error_label = lv_label_create(wifi_settings_list);
    lv_label_set_text(error_label, "Scan failed - retrying...");
    lv_obj_set_style_text_font(error_label, &poppins_light_20, 0);
    lv_obj_set_style_text_color(error_label, COLOR_RED, 0);
    lv_obj_align(error_label, LV_ALIGN_CENTER, 0, 0);
    
    // Retry after a delay by calling this function again
    // (In a real implementation, you'd want to do this via a timer)
  } else {
    wifi_scan_in_progress = true;
    Serial.println("WiFi scan started successfully");
  }
}

static void wifi_settings_network_btn_cb(lv_event_t * e) {
  int idx = (int)(intptr_t)lv_event_get_user_data(e);
  if (idx < 0) return;

  String ssidSel = WiFi.SSID(idx);
  // If this is the currently connected SSID (or saved), show info popup instead
  String connected = WiFi.SSID();
  bool is_saved = wifi_is_network_saved(ssidSel);
  
  Serial.printf("DEBUG: Tapped SSID: '%s', Connected: '%s', Saved: %s\n", 
                ssidSel.c_str(), connected.c_str(), is_saved ? "yes" : "no");
  
  if ((WiFi.status() == WL_CONNECTED && ssidSel == connected) || is_saved) {
    Serial.println("DEBUG: Showing WiFi info popup");
    show_wifi_info_popup(ssidSel);
    return;
  }
  
  Serial.println("DEBUG: Showing password popup");

  // Hide any success message that might be showing
  if (wifi_settings_popup && lv_obj_is_valid(wifi_settings_popup)) {
    lv_obj_add_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
  }

  // Hide all background elements to create dimming effect
  if (wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
    lv_obj_add_flag(wifi_settings_list, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_logo && lv_obj_is_valid(wifi_settings_logo)) {
    lv_obj_add_flag(wifi_settings_logo, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_back_btn && lv_obj_is_valid(wifi_settings_back_btn)) {
    lv_obj_add_flag(wifi_settings_back_btn, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_refresh_btn && lv_obj_is_valid(wifi_settings_refresh_btn)) {
    lv_obj_add_flag(wifi_settings_refresh_btn, LV_OBJ_FLAG_HIDDEN);
  }

  if (wifi_settings_popup_label && lv_obj_is_valid(wifi_settings_popup_label)) {
    lv_label_set_text_fmt(wifi_settings_popup_label, "SSID: %s", ssidSel.c_str());
  }
  if (wifi_settings_password_ta && lv_obj_is_valid(wifi_settings_password_ta)) {
    lv_textarea_set_text(wifi_settings_password_ta, "");
  }
  if (wifi_settings_kb && lv_obj_is_valid(wifi_settings_kb)) {
    lv_obj_clear_flag(wifi_settings_kb, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_popup && lv_obj_is_valid(wifi_settings_popup)) {
    lv_obj_clear_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_connecting_label && lv_obj_is_valid(wifi_settings_connecting_label)) {
    lv_obj_align(wifi_settings_connecting_label, LV_ALIGN_BOTTOM_MID, 0, -25);
  }
  selectedIndex = idx;

  setupWiFiSettingsFocus();
}
static void wifi_settings_cancel_btn_cb(lv_event_t * e) {
  lv_obj_add_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
  lv_obj_add_flag(wifi_settings_kb, LV_OBJ_FLAG_HIDDEN);
  lv_textarea_set_text(wifi_settings_password_ta, "");
  lv_obj_add_flag(wifi_settings_connecting_label, LV_OBJ_FLAG_HIDDEN);
  
  // Show all background elements again
  if (wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
    lv_obj_clear_flag(wifi_settings_list, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_logo && lv_obj_is_valid(wifi_settings_logo)) {
    lv_obj_clear_flag(wifi_settings_logo, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_back_btn && lv_obj_is_valid(wifi_settings_back_btn)) {
    lv_obj_clear_flag(wifi_settings_back_btn, LV_OBJ_FLAG_HIDDEN);
  }
  if (wifi_settings_refresh_btn && lv_obj_is_valid(wifi_settings_refresh_btn)) {
    lv_obj_clear_flag(wifi_settings_refresh_btn, LV_OBJ_FLAG_HIDDEN);
  }
  
  connecting = false;

  setupWiFiSettingsFocus();
}

static void wifi_settings_connect_btn_cb(lv_event_t * e) {
  if (connecting || selectedIndex < 0) return;

  String ssid = WiFi.SSID(selectedIndex);
  pendingPassword = lv_textarea_get_text(wifi_settings_password_ta);

  WiFi.disconnect(true, false); // Fully disconnect but preserve credentials
  delay(150);

  // Create and show connecting screen
  createWiFiConnectingScreen();
  
  WiFi.begin(ssid.c_str(), pendingPassword.c_str());
  connecting = true;
  connectStart = millis();
}

/* ===== Display & Brightness Settings Page ===== */
static void createBrightnessPage() {
  brightness_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(brightness_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(brightness_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(brightness_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(brightness_screen);

  // Logo instead of title text (same as other pages)
  lv_obj_t *logo = lv_img_create(brightness_screen);
  LV_IMG_DECLARE(LumenLogo);  // Declare the image
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Title
  lv_obj_t *title_label = lv_label_create(brightness_screen);
  lv_label_set_text(title_label, "Display & Brightness");
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 70);

  // Brightness slider container
  lv_obj_t *slider_container = lv_obj_create(brightness_screen);
  lv_obj_set_size(slider_container, 500, 100);
  lv_obj_align(slider_container, LV_ALIGN_CENTER, 0, -20);
  lv_obj_set_style_bg_color(slider_container, COLOR_BLACK, 0);
  lv_obj_set_style_border_width(slider_container, 0, 0);
  lv_obj_set_style_radius(slider_container, 10, 0);
  lv_obj_set_style_pad_all(slider_container, 20, 20);

  // Brightness slider
  brightness_slider = lv_slider_create(slider_container);
  lv_obj_set_size(brightness_slider, 400, 20); // Wider for landscape
  lv_obj_align(brightness_slider, LV_ALIGN_CENTER, 0, -10);
  lv_slider_set_range(brightness_slider, 10, 100);
  lv_slider_set_value(brightness_slider, current_brightness_percent, LV_ANIM_OFF);
  lv_obj_set_style_bg_color(brightness_slider, COLOR_GRAY, LV_PART_MAIN);
  lv_obj_set_style_bg_color(brightness_slider, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_set_style_bg_color(brightness_slider, COLOR_WHITE, LV_PART_KNOB);
  lv_obj_set_style_radius(brightness_slider, 10, LV_PART_MAIN);
  lv_obj_set_style_radius(brightness_slider, 10, LV_PART_INDICATOR);
  // Fix the 100% stuck issue by ensuring proper knob positioning
  lv_obj_set_style_width(brightness_slider, 40, LV_PART_KNOB); // Exactly 2x bigger (20 -> 40)
  lv_obj_set_style_height(brightness_slider, 40, LV_PART_KNOB); // Exactly 2x bigger (20 -> 40)
  lv_obj_set_style_radius(brightness_slider, 20, LV_PART_KNOB); // Match 2x knob radius
  lv_obj_set_style_pad_all(brightness_slider, 0, LV_PART_KNOB);
  lv_obj_add_event_cb(brightness_slider, brightness_slider_cb, LV_EVENT_VALUE_CHANGED, NULL);

  // Brightness value label
  brightness_value_label = lv_label_create(slider_container);
  lv_label_set_text_fmt(brightness_value_label, "Brightness: %d%%", current_brightness_percent);
  lv_obj_set_style_text_font(brightness_value_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(brightness_value_label, COLOR_WHITE, 0);
  lv_obj_align(brightness_value_label, LV_ALIGN_CENTER, 0, 20);

  // Back button
  brightness_back_btn = lv_btn_create(brightness_screen);
  lv_obj_set_size(brightness_back_btn, 120, 50);
  lv_obj_align(brightness_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(brightness_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(brightness_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(brightness_back_btn, brightness_back_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(brightness_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label);

  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(brightness_screen);
  }

  encoderFocusBegin(brightness_screen);
  if (brightness_back_btn && lv_obj_is_valid(brightness_back_btn)) {
    lv_obj_t *label = lv_obj_get_child(brightness_back_btn, 0);
    encoderFocusAdd(brightness_back_btn, label);
  }
  encoderFocusCommit(0);

  showCoinInfoIcon();
}

static void brightness_back_btn_cb(lv_event_t * e) {
  lv_scr_load(settings_screen);
  setupSettingsFocus();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(settings_screen);
  }
}
// Helper function to update brightness from encoder (without triggering touch callback)
static void updateBrightnessFromEncoder(int32_t new_value) {
  // Clamp value to valid range
  if (new_value < 10) new_value = 10;
  if (new_value > 100) new_value = 100;
  
  // Store the current brightness percentage
  current_brightness_percent = (int)new_value;
  
  // Update the brightness screen slider (without triggering callback)
  if (brightness_slider && lv_obj_is_valid(brightness_slider)) {
    lv_slider_set_value(brightness_slider, current_brightness_percent, LV_ANIM_OFF);
  }
  
  // Update the control panel slider (without triggering callback)
  if (control_brightness_slider && lv_obj_is_valid(control_brightness_slider)) {
    lv_slider_set_value(control_brightness_slider, current_brightness_percent, LV_ANIM_OFF);
    
    // Update control panel brightness value label
    lv_obj_t *brightness_value = lv_obj_get_child(control_panel, 3); // Get the brightness value label
    if (brightness_value && lv_obj_is_valid(brightness_value)) {
      lv_label_set_text_fmt(brightness_value, "%d%%", current_brightness_percent);
    }
  }
  
  // Update the brightness value label (brightness screen)
  if (brightness_value_label && lv_obj_is_valid(brightness_value_label)) {
    lv_label_set_text_fmt(brightness_value_label, "Brightness: %d%%", current_brightness_percent);
  }
  
  // Convert percentage to 0-255 range for amoled.setBrightness()
  int brightness = map(new_value, 10, 100, 25, 255); // Map 10-100% to 25-255 (minimum visible brightness)
  amoled.setBrightness(brightness);
  
  // Save brightness to preferences
  customPrefs.putInt("brightness", current_brightness_percent);
}

static void brightness_slider_cb(lv_event_t * e) {
  int32_t value = lv_slider_get_value(brightness_slider);
  
  // Store the current brightness percentage
  current_brightness_percent = (int)value;
  
  // Update the brightness value label
  if (brightness_value_label && lv_obj_is_valid(brightness_value_label)) {
    lv_label_set_text_fmt(brightness_value_label, "Brightness: %d%%", current_brightness_percent);
  }
  
  // Convert percentage to 0-255 range for amoled.setBrightness()
  int brightness = map(value, 10, 100, 25, 255); // Map 10-100% to 25-255 (minimum visible brightness)
  amoled.setBrightness(brightness);
  
  // Save brightness to preferences
  customPrefs.putInt("brightness", current_brightness_percent);
}
/* ===== Control Panel - NEW: Gesture-based with fade animations ===== */
static void createControlPanel() {
  Serial.println("Creating control panel...");
  
  // Create semi-transparent background overlay for click-outside detection
  control_panel_bg = lv_obj_create(lv_layer_top());
  if (!control_panel_bg) {
    Serial.println("ERROR: Failed to create control_panel_bg");
    return;
  }
  
  // Full-screen overlay for click-outside detection
  lv_obj_set_size(control_panel_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(control_panel_bg, 0, 0);
  lv_obj_set_style_bg_color(control_panel_bg, lv_color_make(0, 0, 0), 0);
  lv_obj_set_style_bg_opa(control_panel_bg, 0, 0); // Start at 0, will fade to 50%
  lv_obj_set_style_radius(control_panel_bg, 0, 0);
  lv_obj_set_style_border_width(control_panel_bg, 0, 0);
  lv_obj_set_scrollbar_mode(control_panel_bg, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(control_panel_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN); // Start hidden
  lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on overlay to close panel
  lv_obj_add_event_cb(control_panel_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Control Panel] Background clicked - closing panel");
      hideControlPanel();
    }
  }, LV_EVENT_CLICKED, NULL);
  
  Serial.println("Control panel background created");
  
  Serial.println("Creating control panel content...");
  
  // Create the actual panel content - perfectly centered both horizontally and vertically
  control_panel = lv_obj_create(control_panel_bg);
  if (!control_panel) {
    Serial.println("ERROR: Failed to create control_panel");
    return;
  }
  
  lv_obj_set_size(control_panel, control_panel_width, control_panel_height);
  lv_obj_align(control_panel, LV_ALIGN_CENTER, 0, 0); // Perfect center
  // Dark gray background (matches WiFi list style)
  lv_obj_set_style_bg_color(control_panel, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_bg_opa(control_panel, 255, 0); // Fully opaque background
  lv_obj_set_style_radius(control_panel, 20, 0);
  lv_obj_set_style_border_width(control_panel, 0, 0);
  lv_obj_set_style_pad_all(control_panel, 20, 20);
  lv_obj_set_scrollbar_mode(control_panel, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(control_panel, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(control_panel, LV_OBJ_FLAG_CLICKABLE); // Consume clicks so they don't reach bg
  
  // Start with 0 opacity (will fade in smoothly)
  lv_obj_set_style_opa(control_panel, 0, 0);
  
  Serial.printf("[Control Panel] Panel created: %dx%d dark gray panel\n",
                control_panel_width, control_panel_height);
  
  // Stop propagation of events from panel to background
  lv_obj_add_event_cb(control_panel, [](lv_event_t *e) {
    // Consume clicks on panel itself so background doesn't close it
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      // Do nothing - just stop event from bubbling
      Serial.println("[Control Panel] Click on panel itself (ignored)");
    }
  }, LV_EVENT_CLICKED, NULL);
  
  Serial.println("Control panel content configured");
  
  Serial.println("Creating title label...");
  // Add "Control Panel" title at top
  lv_obj_t *title_label = lv_label_create(control_panel);
  if (!title_label) {
    Serial.println("ERROR: Failed to create title_label");
    return;
  }
  lv_label_set_text(title_label, "Control Panel");
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 10); // 10px from top
  Serial.println("Title label created");
  
  Serial.println("Creating brightness section...");
  // Brightness control section
  lv_obj_t *brightness_label = lv_label_create(control_panel);
  if (!brightness_label) {
    Serial.println("ERROR: Failed to create brightness_label");
    return;
  }
  lv_label_set_text(brightness_label, "Brightness");
  lv_obj_set_style_text_font(brightness_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(brightness_label, COLOR_WHITE, 0);
  lv_obj_align(brightness_label, LV_ALIGN_TOP_MID, 0, 85); // Moved up to be above slider
  Serial.println("Brightness label created");
  
  control_brightness_slider = lv_slider_create(control_panel);
  if (!control_brightness_slider) {
    Serial.println("ERROR: Failed to create control_brightness_slider");
    return;
  }
  Serial.println("Brightness slider created");
  
  lv_obj_set_size(control_brightness_slider, 400, 20);
  lv_obj_align(control_brightness_slider, LV_ALIGN_TOP_MID, 0, 125); // Positioned below brightness label
  lv_slider_set_range(control_brightness_slider, 10, 100);
  lv_slider_set_value(control_brightness_slider, current_brightness_percent, LV_ANIM_OFF);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_GRAY, LV_PART_MAIN);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_WHITE, LV_PART_KNOB);
  lv_obj_set_style_radius(control_brightness_slider, 10, LV_PART_MAIN);
  lv_obj_set_style_radius(control_brightness_slider, 10, LV_PART_INDICATOR);
  lv_obj_set_style_width(control_brightness_slider, 40, LV_PART_KNOB);
  lv_obj_set_style_height(control_brightness_slider, 40, LV_PART_KNOB);
  lv_obj_set_style_radius(control_brightness_slider, 20, LV_PART_KNOB);
  lv_obj_set_style_pad_all(control_brightness_slider, 0, LV_PART_KNOB);
  lv_obj_add_event_cb(control_brightness_slider, control_panel_brightness_cb, LV_EVENT_VALUE_CHANGED, NULL);
  Serial.println("Brightness slider configured");
  
  Serial.println("Creating brightness value display...");
  // Brightness value display
  lv_obj_t *brightness_value = lv_label_create(control_panel);
  if (!brightness_value) {
    Serial.println("ERROR: Failed to create brightness_value");
    return;
  }
  lv_label_set_text_fmt(brightness_value, "%d%%", current_brightness_percent);
  lv_obj_set_style_text_font(brightness_value, &poppins_light_20, 0);
  lv_obj_set_style_text_color(brightness_value, lv_color_make(180, 180, 180), 0);
  lv_obj_align(brightness_value, LV_ALIGN_TOP_MID, 0, 160); // Adjusted to match slider
  Serial.println("Brightness value display created");
  
  Serial.println("Creating edit button...");
  // Edit button
  control_customization_btn = lv_btn_create(control_panel);
  if (!control_customization_btn) {
    Serial.println("ERROR: Failed to create control_customization_btn");
    return;
  }
  lv_obj_set_size(control_customization_btn, 200, 50);
  lv_obj_align(control_customization_btn, LV_ALIGN_CENTER, 105, 170);
  lv_obj_set_style_bg_color(control_customization_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(control_customization_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(control_customization_btn, 0, 0);
  lv_obj_add_event_cb(control_customization_btn, control_panel_customization_cb, LV_EVENT_CLICKED, NULL);
  Serial.println("Edit button created");

  lv_obj_t *customization_label = lv_label_create(control_customization_btn);
  if (!customization_label) {
    Serial.println("ERROR: Failed to create edit_label");
    return;
  }
  lv_label_set_text(customization_label, "Edit");
  lv_obj_set_style_text_font(customization_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(customization_label, COLOR_BLACK, 0);
  lv_obj_center(customization_label);
  Serial.println("Edit label created");
  
  Serial.println("Creating coin info button...");
  coin_info_button = lv_btn_create(control_panel);
  if (!coin_info_button) {
    Serial.println("ERROR: Failed to create coin_info_button");
    return;
  }
  lv_obj_set_size(coin_info_button, 200, 50);
  lv_obj_align(coin_info_button, LV_ALIGN_CENTER, -105, 90);
  lv_obj_set_style_bg_color(coin_info_button, COLOR_WHITE, 0);
  lv_obj_set_style_radius(coin_info_button, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(coin_info_button, 0, 0);
  lv_obj_add_event_cb(coin_info_button, control_panel_coin_info_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *coin_info_label = lv_label_create(coin_info_button);
  if (!coin_info_label) {
    Serial.println("ERROR: Failed to create coin_info_label");
    return;
  }
  lv_label_set_text(coin_info_label, "Coin Info");
  lv_obj_set_style_text_font(coin_info_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(coin_info_label, COLOR_BLACK, 0);
  lv_obj_center(coin_info_label);
  Serial.println("Coin info button created");

  Serial.println("Creating alert button...");
  // Create Alert button
  control_alert_btn = lv_btn_create(control_panel);
  if (!control_alert_btn) {
    Serial.println("ERROR: Failed to create control_alert_btn");
    return;
  }
  lv_obj_set_size(control_alert_btn, 200, 50);
  lv_obj_align(control_alert_btn, LV_ALIGN_CENTER, 105, 90);
  lv_obj_set_style_bg_color(control_alert_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(control_alert_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(control_alert_btn, 0, 0);
  lv_obj_add_event_cb(control_alert_btn, control_panel_alert_cb, LV_EVENT_CLICKED, NULL);
  Serial.println("Alert button created");
  
  lv_obj_t *alert_btn_label = lv_label_create(control_alert_btn);
  if (!alert_btn_label) {
    Serial.println("ERROR: Failed to create alert_btn_label");
    return;
  }
  lv_label_set_text(alert_btn_label, "Create Alert");
  lv_obj_set_style_text_font(alert_btn_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(alert_btn_label, COLOR_BLACK, 0);
  lv_obj_center(alert_btn_label);
  Serial.println("Alert button label created");
  
  Serial.println("Creating menu button...");
  // Menu button at bottom
  control_menu_btn = lv_btn_create(control_panel);
  if (!control_menu_btn) {
    Serial.println("ERROR: Failed to create control_menu_btn");
    return;
  }
  lv_obj_set_size(control_menu_btn, 200, 50);
  lv_obj_align(control_menu_btn, LV_ALIGN_CENTER, -105, 170); // Lower left corner
  lv_obj_set_style_bg_color(control_menu_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(control_menu_btn, BUTTON_RADIUS, 0);
  lv_obj_set_style_border_width(control_menu_btn, 0, 0);
  lv_obj_add_event_cb(control_menu_btn, control_panel_menu_cb, LV_EVENT_CLICKED, NULL);
  Serial.println("Menu button created");
  
  lv_obj_t *menu_label = lv_label_create(control_menu_btn);
  if (!menu_label) {
    Serial.println("ERROR: Failed to create menu_label");
    return;
  }
  lv_label_set_text(menu_label, "Menu");
  lv_obj_set_style_text_font(menu_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(menu_label, COLOR_BLACK, 0);
  lv_obj_center(menu_label);
  Serial.println("Menu label created");

  // Sync coin info visibility with preferences
  showCoinInfoIcon();
  
  // Ensure grabber is on top (grabber is created once at startup in initGlobalControlPanel)
  if (control_panel_grabber && lv_obj_is_valid(control_panel_grabber)) {
    lv_obj_move_foreground(control_panel_grabber);
    Serial.println("[Control Panel] Grabber moved to foreground");
  } else {
    Serial.println("WARNING: control_panel_grabber not found!");
  }
  
  // Ensure control panel starts in hidden state
  control_panel_visible = false;
  lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  // Don't set opacity to 0 on init - keep it at creation values
  Serial.printf("[Control Panel] Initialized: visible=%s, bg_hidden=%s\n", 
                control_panel_visible ? "TRUE" : "FALSE",
                lv_obj_has_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN) ? "TRUE" : "FALSE");
  
  Serial.println("Control panel creation complete!");
}

// Simple control panel with ONLY brightness (for non-live price pages)
static void createSimpleControlPanel() {
  Serial.println("=== Creating SIMPLE Control Panel (Brightness Only) ===");
  
  // Full-screen dimmed background
  control_panel_bg = lv_obj_create(lv_layer_top());
  if (!control_panel_bg) {
    Serial.println("ERROR: Failed to create control_panel_bg");
    return;
  }
  
  lv_obj_set_size(control_panel_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(control_panel_bg, 0, 0);
  lv_obj_set_style_bg_color(control_panel_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(control_panel_bg, 0, 0); // Start invisible for fade-in
  lv_obj_set_style_opa(control_panel_bg, 255, 0); // Content opacity = 255
  lv_obj_set_style_border_width(control_panel_bg, 0, 0);
  lv_obj_set_style_radius(control_panel_bg, 0, 0);
  lv_obj_set_style_pad_all(control_panel_bg, 0, 0);
  lv_obj_clear_flag(control_panel_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on background to close
  lv_obj_add_event_cb(control_panel_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Simple Control Panel] Background clicked - closing panel");
      hideControlPanel();
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create smaller panel for brightness only (450x300 - matches full panel style)
  control_panel = lv_obj_create(control_panel_bg);
  if (!control_panel) {
    Serial.println("ERROR: Failed to create control_panel");
    return;
  }
  
  lv_obj_set_size(control_panel, 450, 300);
  lv_obj_align(control_panel, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(control_panel, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_bg_opa(control_panel, 255, 0);
  lv_obj_set_style_radius(control_panel, 20, 0);
  lv_obj_set_style_border_width(control_panel, 0, 0);
  lv_obj_set_style_pad_all(control_panel, 20, 20);
  lv_obj_set_scrollbar_mode(control_panel, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(control_panel, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(control_panel, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_set_style_opa(control_panel, 0, 0); // Start invisible for fade-in
  
  Serial.printf("[Simple Control Panel] Panel created: 450x300 dark gray panel\n");
  
  // Stop event propagation
  lv_obj_add_event_cb(control_panel, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Simple Control Panel] Click on panel itself (ignored)");
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Title - "Control Panel" to match full panel
  lv_obj_t *title_label = lv_label_create(control_panel);
  lv_label_set_text(title_label, "Control Panel");
  lv_obj_set_style_text_font(title_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title_label, COLOR_WHITE, 0);
  lv_obj_align(title_label, LV_ALIGN_TOP_MID, 0, 10); // 10px from top, matching full panel
  
  // "Brightness" section label (above slider)
  lv_obj_t *brightness_label = lv_label_create(control_panel);
  lv_label_set_text(brightness_label, "Brightness");
  lv_obj_set_style_text_font(brightness_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(brightness_label, COLOR_WHITE, 0);
  lv_obj_align(brightness_label, LV_ALIGN_TOP_MID, 0, 85); // Position above slider
  
  // Brightness slider
  control_brightness_slider = lv_slider_create(control_panel);
  lv_obj_set_size(control_brightness_slider, 400, 20);
  lv_obj_align(control_brightness_slider, LV_ALIGN_TOP_MID, 0, 125); // Below brightness label
  lv_slider_set_range(control_brightness_slider, 10, 100);
  lv_slider_set_value(control_brightness_slider, current_brightness_percent, LV_ANIM_OFF);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_GRAY, LV_PART_MAIN);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_set_style_bg_color(control_brightness_slider, COLOR_WHITE, LV_PART_KNOB);
  lv_obj_set_style_radius(control_brightness_slider, 10, LV_PART_MAIN);
  lv_obj_set_style_radius(control_brightness_slider, 10, LV_PART_INDICATOR);
  lv_obj_set_style_width(control_brightness_slider, 40, LV_PART_KNOB);
  lv_obj_set_style_height(control_brightness_slider, 40, LV_PART_KNOB);
  lv_obj_set_style_radius(control_brightness_slider, 20, LV_PART_KNOB);
  lv_obj_set_style_pad_all(control_brightness_slider, 0, LV_PART_KNOB);
  lv_obj_add_event_cb(control_brightness_slider, control_panel_brightness_cb, LV_EVENT_VALUE_CHANGED, NULL);
  
  // Brightness value display (IMPORTANT: This is child index 3, matching the full panel layout)
  lv_obj_t *brightness_value = lv_label_create(control_panel);
  lv_label_set_text_fmt(brightness_value, "%d%%", current_brightness_percent);
  lv_obj_set_style_text_font(brightness_value, &poppins_light_20, 0);
  lv_obj_set_style_text_color(brightness_value, lv_color_make(180, 180, 180), 0);
  lv_obj_align(brightness_value, LV_ALIGN_TOP_MID, 0, 160); // Below slider, matching full panel
  
  // Ensure grabber is on top (grabber is created once at startup in initGlobalControlPanel)
  if (control_panel_grabber && lv_obj_is_valid(control_panel_grabber)) {
    lv_obj_move_foreground(control_panel_grabber);
    Serial.println("[Simple Control Panel] Grabber moved to foreground");
  } else {
    Serial.println("WARNING: control_panel_grabber not found!");
  }
  
  // Start hidden
  control_panel_visible = false;
  lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  
  Serial.println("Simple control panel creation complete!");
}

static void showControlPanel() {
  Serial.printf("[Control Panel] showControlPanel() called | visible=%s\n", 
                control_panel_visible ? "TRUE" : "FALSE");
  
  // Determine if we need the full panel (crypto_display_screen) or simple panel (all other screens)
  lv_obj_t *current_screen = lv_scr_act();
  bool is_crypto_screen = (current_screen == crypto_display_screen);
  
  // If control panel doesn't exist or we're on the wrong screen type, recreate the appropriate one
  if (!control_panel_bg || !lv_obj_is_valid(control_panel_bg)) {
    Serial.println("[Control Panel] Creating new panel...");
    if (is_crypto_screen) {
      Serial.println("[Control Panel] Creating FULL panel for live price page");
      createControlPanel();
    } else {
      Serial.println("[Control Panel] Creating SIMPLE panel (brightness only)");
      createSimpleControlPanel();
    }
    if (!control_panel_bg || !lv_obj_is_valid(control_panel_bg)) {
      Serial.println("[Control Panel] ERROR: Failed to create control panel!");
      return;
    }
  }
  
  // SAFETY: If panel appears stuck as "visible" but is actually hidden, reset the state
  if (control_panel_visible && lv_obj_has_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN)) {
    Serial.println("[Control Panel] WARNING: Panel marked visible but is hidden - resetting state");
    control_panel_visible = false;
  }
  
  if (control_panel_visible) {
    Serial.println("[Control Panel] Already visible - skipping show");
    return; // Already visible
  }
  
  // Exit TF encoder mode when control panel opens
  if (tf_encoder_mode) {
    tf_encoder_mode = false;
    if (tf_menu && lv_obj_is_valid(tf_menu)) {
      lv_obj_add_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
      tf_menu_visible = false;
    }
  }
  
  // Exit alert encoder mode if active
  if (alert_encoder_mode) {
    alert_encoder_mode = false;
  }
  
  control_panel_visible = true;
  Serial.println("[Control Panel] State set to visible=TRUE");
  
  // CRITICAL: Delete any existing animations to prevent stacking
  lv_anim_del(control_panel_bg, NULL);
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_anim_del(control_panel, NULL);
  }
  Serial.println("[Control Panel] Deleted existing animations");
  
  // Make visible immediately
    lv_obj_clear_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  
  // CRITICAL FIX: Set CONTENT opacity to 255 so children can render!
  lv_obj_set_style_opa(control_panel_bg, 255, 0); // Content must be opaque for children to show
  lv_obj_set_style_bg_opa(control_panel_bg, 0, 0); // Background RESET to 0 (will fade to 128)
  
  // CRITICAL: Move to front so it's above everything
  lv_obj_move_foreground(control_panel_bg);
  Serial.println("[Control Panel] Moved to foreground, OPA=255, BG_OPA=0");
  
  Serial.println("[Control Panel] Starting fade-in animation...");
  
  // Setup panel for fade-in
  if (control_panel && lv_obj_is_valid(control_panel)) {
    // CRITICAL FIX: Re-align panel to center
    lv_obj_align(control_panel, LV_ALIGN_CENTER, 0, 0);
    lv_obj_move_foreground(control_panel);
    Serial.println("[Control Panel] Panel re-aligned to CENTER");
  }
  
  // Smooth fade-in animation (300ms for smoother animation with more frames)
  // Fade background from 0 -> 128 (50% opacity)
  lv_anim_t bg_fade;
  lv_anim_init(&bg_fade);
  lv_anim_set_var(&bg_fade, control_panel_bg);
  lv_anim_set_exec_cb(&bg_fade, [](void *var, int32_t v) {
    lv_obj_set_style_bg_opa((lv_obj_t*)var, v, 0);
  });
  lv_anim_set_values(&bg_fade, 0, 128);
  lv_anim_set_time(&bg_fade, 300); // Longer for smoother animation
  lv_anim_set_path_cb(&bg_fade, lv_anim_path_ease_out);
  lv_anim_start(&bg_fade);
  
  // Fade panel from 0 -> 255 (100% opacity)
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_anim_t panel_fade;
    lv_anim_init(&panel_fade);
    lv_anim_set_var(&panel_fade, control_panel);
    lv_anim_set_exec_cb(&panel_fade, [](void *var, int32_t v) {
      lv_obj_set_style_opa((lv_obj_t*)var, v, 0);
    });
    lv_anim_set_values(&panel_fade, 0, 255);
    lv_anim_set_time(&panel_fade, 300); // Longer for smoother animation
    lv_anim_set_path_cb(&panel_fade, lv_anim_path_ease_out);
    lv_anim_start(&panel_fade);
  }
  
  Serial.println("[Control Panel] Smooth fade-in started (300ms)");
}

static void hideControlPanel() {
  Serial.printf("[Control Panel] hideControlPanel() called | visible=%s\n", 
                control_panel_visible ? "TRUE" : "FALSE");
  
  if (!control_panel_bg || !lv_obj_is_valid(control_panel_bg)) {
    Serial.println("[Control Panel] ERROR: control_panel_bg is invalid!");
    return;
  }
  
  // SAFETY: If panel appears stuck as "hidden" but is actually visible, reset the state
  if (!control_panel_visible && !lv_obj_has_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN)) {
    Serial.println("[Control Panel] WARNING: Panel marked hidden but is visible - resetting state");
    control_panel_visible = true;
  }
  
  if (!control_panel_visible) {
    Serial.println("[Control Panel] Already hidden - skipping hide");
    return; // Already hidden
  }
  
  // CRITICAL: Delete any existing animations to prevent conflicts
  lv_anim_del(control_panel_bg, NULL);
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_anim_del(control_panel, NULL);
  }
  Serial.println("[Control Panel] Deleted existing animations before hide");
  
  control_panel_visible = false;
  Serial.println("[Control Panel] State set to visible=FALSE");
  
  // Smooth fade-out animation (reverse of fade-in)
  // Fade background from 128 -> 0 (50% to transparent)
  lv_anim_t bg_fade_out;
  lv_anim_init(&bg_fade_out);
  lv_anim_set_var(&bg_fade_out, control_panel_bg);
  lv_anim_set_exec_cb(&bg_fade_out, [](void *var, int32_t v) {
    lv_obj_set_style_bg_opa((lv_obj_t*)var, v, 0);
  });
  lv_anim_set_values(&bg_fade_out, 128, 0);
  lv_anim_set_time(&bg_fade_out, 150);
  lv_anim_set_path_cb(&bg_fade_out, lv_anim_path_ease_in); // Ease-in for closing
  lv_anim_set_ready_cb(&bg_fade_out, [](lv_anim_t *a) {
    lv_obj_t *obj = (lv_obj_t*)a->var;
    if (obj && lv_obj_is_valid(obj)) {
      lv_obj_add_flag(obj, LV_OBJ_FLAG_HIDDEN);
      Serial.println("[Control Panel] Fade-out complete - panel hidden");
      
      // Delete the panel content to free memory and allow recreation
      // This allows us to create the appropriate panel type (full or simple) next time
      // BUT keep the grabber alive so swipes continue to work!
      lv_obj_del(obj);
      control_panel_bg = nullptr;
      control_panel = nullptr;
      control_brightness_slider = nullptr;
      // DON'T set control_panel_grabber = nullptr - keep it alive for next swipe!
      Serial.println("[Control Panel] Panel deleted - grabber kept alive for next swipe");
    }
  });
  lv_anim_start(&bg_fade_out);
  
  // Fade panel from 255 -> 0 (100% to invisible)
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_anim_t panel_fade_out;
    lv_anim_init(&panel_fade_out);
    lv_anim_set_var(&panel_fade_out, control_panel);
    lv_anim_set_exec_cb(&panel_fade_out, [](void *var, int32_t v) {
      lv_obj_set_style_opa((lv_obj_t*)var, v, 0);
    });
    lv_anim_set_values(&panel_fade_out, 255, 0);
    lv_anim_set_time(&panel_fade_out, 150);
    lv_anim_set_path_cb(&panel_fade_out, lv_anim_path_ease_in); // Ease-in for closing
    lv_anim_start(&panel_fade_out);
  }
  
  Serial.println("[Control Panel] Smooth fade-out started (150ms)");
}

// Old animation callbacks - no longer needed with new fade approach
// Keeping empty stubs in case referenced elsewhere

static void control_panel_anim_exec_cb(void *var, int32_t v) {
  // Deprecated - using inline lambda animations now
}

static void control_panel_anim_ready_cb(lv_anim_t *a) {
  // Deprecated - using inline lambda animations now
}

// Old drag event handler - NO LONGER USED (panel is not draggable)
static void control_panel_drag_event_cb(lv_event_t * e) {
  // Deprecated - control panel now uses gesture detection only, not drag mechanics
  // All drag code removed - panel is non-interactive except via top-edge gesture
}
static void control_panel_brightness_cb(lv_event_t * e) {
  int32_t value = lv_slider_get_value(control_brightness_slider);
  current_brightness_percent = (int)value;
  
  // Update brightness value display
  lv_obj_t *brightness_value = lv_obj_get_child(control_panel, 3); // Get the brightness value label
  if (brightness_value && lv_obj_is_valid(brightness_value)) {
    lv_label_set_text_fmt(brightness_value, "%d%%", current_brightness_percent);
  }
  
  // Convert percentage to 0-255 range for amoled.setBrightness()
  int brightness = map(value, 10, 100, 25, 255);
  amoled.setBrightness(brightness);
  
  // Save brightness to preferences
  customPrefs.putInt("brightness", current_brightness_percent);
  
  Serial.printf("Brightness changed to %d%% (%d)\n", current_brightness_percent, brightness);
}

static void control_panel_menu_cb(lv_event_t * e) {
  Serial.println("Menu button pressed!");
  
  // Hide control panel first
  hideControlPanel();
  
  // Navigate back to homepage (first page)
  createHomepage();
}

static void control_panel_customization_cb(lv_event_t * e) {
  Serial.println("Edit button pressed!");
  
  // Hide control panel first
  hideControlPanel();
  
  // Show customization screen
  showCustomizationScreen();
}

static void control_panel_alert_cb(lv_event_t * e) {
  Serial.println("Alert button pressed!");
  
  // Hide control panel first
  hideControlPanel();
  
  // Create and show alert popup
  createAlertPopup();
}

static void control_panel_coin_info_cb(lv_event_t * e) {
  LV_UNUSED(e);
  Serial.println("Coin Info button pressed!");
  hideControlPanel();
  showCoinInfoPopup();
}
/* ===== Alert Popup ===== */
static void createAlertPopup() {
  // Hide control panel background to prevent dimness stacking
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  // Delete any existing alert popup to prevent stacking
  if (alert_bg && lv_obj_is_valid(alert_bg)) {
    lv_obj_del(alert_bg);
    alert_bg = nullptr;
    alert_popup = nullptr;
  }
  
  // Create full-screen dimmed background (like control panel)
  alert_bg = lv_obj_create(lv_layer_top());
  lv_obj_set_size(alert_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(alert_bg, 0, 0);
  lv_obj_set_style_bg_color(alert_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(alert_bg, 128, 0); // 50% opacity dimmed overlay
  lv_obj_set_style_border_width(alert_bg, 0, 0);
  lv_obj_set_style_radius(alert_bg, 0, 0);
  lv_obj_set_style_pad_all(alert_bg, 0, 0);
  lv_obj_clear_flag(alert_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(alert_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on overlay to close alert popup
  lv_obj_add_event_cb(alert_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Alert] Background clicked - closing alert popup");
      // Delete the entire alert (background + popup)
      if (alert_bg && lv_obj_is_valid(alert_bg)) {
        lv_obj_del(alert_bg);
        alert_bg = nullptr;
        alert_popup = nullptr;
        alert_encoder_mode = false;
      }
      if (control_panel_visible) {
        hideControlPanel();
      }
      control_panel_visible = false;
      if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
        lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
      }
      if (control_panel && lv_obj_is_valid(control_panel)) {
        lv_obj_set_style_opa(control_panel, 0, 0);
      }
      if (crypto_display_screen && lv_obj_is_valid(crypto_display_screen)) {
        lv_scr_load(crypto_display_screen);
        Serial.println("[Alert] Returned to live price page");
      }
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create popup overlay
  alert_popup = lv_obj_create(alert_bg);
  lv_obj_set_size(alert_popup, control_panel_width, 460);
  lv_obj_align(alert_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(alert_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_radius(alert_popup, 20, 0);
  lv_obj_set_style_border_width(alert_popup, 0, 0);
  lv_obj_set_style_pad_all(alert_popup, 20, 0);
  lv_obj_set_scrollbar_mode(alert_popup, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(alert_popup, LV_OBJ_FLAG_SCROLLABLE);
  // Make popup non-draggable - lock it in place
  lv_obj_clear_flag(alert_popup, LV_OBJ_FLAG_CLICKABLE);
  // Prevent any drag gestures from moving the popup
  lv_obj_add_flag(alert_popup, LV_OBJ_FLAG_GESTURE_BUBBLE);
  lv_obj_add_flag(alert_popup, LV_OBJ_FLAG_PRESS_LOCK);
  
  // Title "Create Alert"
  alert_popup_title = lv_label_create(alert_popup);
  lv_label_set_text(alert_popup_title, "Create Alert");
  lv_obj_set_style_text_font(alert_popup_title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(alert_popup_title, COLOR_WHITE, 0);
  lv_obj_align(alert_popup_title, LV_ALIGN_TOP_MID, 0, 15);
  
  // Current coin label
  alert_coin_label = lv_label_create(alert_popup);
  String coinName = pairs[current_pair].display_name;
  lv_label_set_text_fmt(alert_coin_label, "%s", coinName.c_str());
  lv_obj_set_style_text_font(alert_coin_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(alert_coin_label, COLOR_WHITE, 0);
  lv_obj_align(alert_coin_label, LV_ALIGN_TOP_MID, 0, 55);
  
  // Initialize alert price with current price
  alert_price_value = pairs[current_pair].last_price > 0.0f ? pairs[current_pair].last_price : 0.0f;
  alert_encoder_mode = true;
  alert_digit_index = 0;  // Start with leftmost digit
  
  // Price display container (centered)
  alert_price_display = lv_obj_create(alert_popup);
  lv_obj_set_size(alert_price_display, 600, 100);
  lv_obj_align(alert_price_display, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_opa(alert_price_display, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(alert_price_display, 0, 0);
  lv_obj_set_style_pad_all(alert_price_display, 0, 0);
  lv_obj_clear_flag(alert_price_display, LV_OBJ_FLAG_SCROLLABLE);
  
  // Build initial price display with highlighted digit
  updateAlertPriceDisplay();
  
  // Back button (bottom left)
  alert_back_btn = lv_btn_create(alert_popup);
  lv_obj_set_size(alert_back_btn, 160, 50);
  lv_obj_align(alert_back_btn, LV_ALIGN_BOTTOM_LEFT, 15, -15);
  lv_obj_set_style_bg_color(alert_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(alert_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(alert_back_btn, alert_back_btn_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *back_label = lv_label_create(alert_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label);
  
  // Create button (bottom right)
  alert_create_btn = lv_btn_create(alert_popup);
  lv_obj_set_size(alert_create_btn, 180, 50);
  lv_obj_align(alert_create_btn, LV_ALIGN_BOTTOM_RIGHT, -15, -15);
  lv_obj_set_style_bg_color(alert_create_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(alert_create_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(alert_create_btn, alert_create_btn_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *create_label = lv_label_create(alert_create_btn);
  lv_label_set_text(create_label, "Create");
  lv_obj_set_style_text_font(create_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(create_label, COLOR_BLACK, 0);
  lv_obj_center(create_label);
}

// Build price string and map digit positions
static void buildAlertPriceString() {
  char buf[30];
  formatPriceWithCommas(alert_price_value, buf, sizeof(buf), current_pair);
  
  // Clear old labels
  if (alert_price_display && lv_obj_is_valid(alert_price_display)) {
    lv_obj_clean(alert_price_display);
  }
  
  // Reset arrays
  alert_num_digits = 0;
  for (int i = 0; i < 30; i++) {
    alert_price_labels[i] = nullptr;
    alert_char_positions[i] = -1;
  }
  
  // Use flex layout for natural letter spacing
  lv_obj_set_flex_flow(alert_price_display, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(alert_price_display, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  lv_obj_set_style_pad_column(alert_price_display, 0, 0); // No extra padding between characters
  
  // Create label for each character and map digit positions
  int len = strlen(buf);
  bool is_btc_style = (pairs[current_pair].symbol == "BTCUSDT" || pairs[current_pair].symbol == "BTC");
  
  // For BTC: Find position of first separator (comma or period) to group digits before it
  int first_separator_pos = -1;
  if (is_btc_style) {
    for (int i = 0; i < len; i++) {
      if (buf[i] == ',' || buf[i] == '.') {
        first_separator_pos = i;
        break;
      }
    }
  }
  
  for (int i = 0; i < len; i++) {
    char ch = buf[i];
    bool is_digit = (ch >= '0' && ch <= '9');
    
    lv_obj_t *char_label = lv_label_create(alert_price_display);
    char char_str[2] = {ch, '\0'};
    lv_label_set_text(char_label, char_str);
    lv_obj_set_style_text_font(char_label, &poppins_semibold_64, 0);
    lv_obj_set_style_text_color(char_label, COLOR_WHITE, 0);
    lv_obj_set_style_text_letter_space(char_label, 0, 0); // Normal letter spacing
    
    alert_price_labels[i] = char_label;
    
    // Map digit index to character position
    if (is_digit) {
      // For BTC: Digits before first separator are all grouped as index 0
      if (is_btc_style && first_separator_pos > 0 && i < first_separator_pos) {
        // All digits before first separator map to index 0
        if (alert_num_digits == 0) {
          alert_char_positions[0] = i; // First digit in group
          alert_num_digits = 1;
        }
        // Don't increment alert_num_digits for additional digits in the group
      } else {
        // Normal mapping for digits after separator or non-BTC coins
        alert_char_positions[alert_num_digits] = i;
        alert_num_digits++;
      }
    }
  }
  
  // Debug: Print digit mapping
  Serial.printf("[Alert] Digit mapping: alert_num_digits=%d\n", alert_num_digits);
  for (int i = 0; i < alert_num_digits; i++) {
    int char_pos = alert_char_positions[i];
    if (char_pos >= 0 && alert_price_labels[char_pos]) {
      const char* ch = lv_label_get_text(alert_price_labels[char_pos]);
      Serial.printf("  Digit index %d -> char pos %d ('%s')\n", i, char_pos, ch ? ch : "null");
    }
  }
  
  // BTC-style highlighting: Highlight all digits before decimal as a group when on index 0
  // (is_btc_style already defined above)
  
  // Find separator position for highlighting
  // For BTC: Use the FIRST separator found (could be period or comma depending on locale)
  // This matches the first_separator_pos used for digit grouping
  // For others: comma or period is decimal
  int highlight_separator_pos = -1;
  for (int i = 0; i < 30 && alert_price_labels[i]; i++) {
    const char* txt = lv_label_get_text(alert_price_labels[i]);
    if (txt && (txt[0] == '.' || txt[0] == ',')) {
      highlight_separator_pos = i;
      break;
    }
  }
  
  Serial.printf("[Alert] Highlight separator at position %d\n", highlight_separator_pos);
  
  // Highlight logic - iterate through ALL character labels, not just digit indices
  for (int char_idx = 0; char_idx < 30 && alert_price_labels[char_idx]; char_idx++) {
    if (!lv_obj_is_valid(alert_price_labels[char_idx])) continue;
    
    const char* ch_text = lv_label_get_text(alert_price_labels[char_idx]);
    if (!ch_text || strlen(ch_text) == 0) continue;
    
    bool is_digit = (ch_text[0] >= '0' && ch_text[0] <= '9');
    if (!is_digit) continue; // Skip non-digits
    
    bool should_highlight = false;
    
    // For BTC on index 0: highlight ALL digits before first separator
    if (is_btc_style && alert_digit_index == 0 && highlight_separator_pos > 0) {
      should_highlight = (char_idx < highlight_separator_pos);
    } else {
      // For other indices: find which digit index this character belongs to
      for (int i = 0; i < alert_num_digits; i++) {
        if (alert_char_positions[i] == char_idx && i == alert_digit_index) {
          should_highlight = true;
          break;
        }
      }
    }
    
    if (should_highlight) {
      lv_obj_set_style_text_color(alert_price_labels[char_idx], COLOR_GREEN, 0);
    } else {
      lv_obj_set_style_text_color(alert_price_labels[char_idx], COLOR_WHITE, 0);
    }
  }
}

// Update alert price display with digit highlighting
static void updateAlertPriceDisplay() {
  buildAlertPriceString();
}
// BTC-specific alert digit change (completely separate from XRP)
static void changeAlertDigit_BTC(bool is_clockwise) {
  // BTC Rules:
  // 1. Index 0 = all digits before comma (integer part) - simple increment/decrement
  // 2. After index 0 = individual digits wrap 0-9
  
  Serial.printf("[BTC Alert] changeAlertDigit_BTC called: index=%d, clockwise=%d\n", alert_digit_index, is_clockwise);
  
  if (alert_digit_index == 0) {
    // Index 0 = digits before FIRST separator
    // For "104.474,31" we want to change just "104", not the full integer 104474
    
    int full_integer = (int)alert_price_value;
    float decimal_part = alert_price_value - full_integer;
    
    // Find how many digits are before the first separator by checking the formatted string
    char temp_buf[30];
    formatPriceWithCommas(alert_price_value, temp_buf, sizeof(temp_buf), current_pair);
    
    // First pass: find the decimal separator (last separator in the string)
    int decimal_separator_pos = -1;
    for (int i = 0; i < 30 && temp_buf[i] != '\0'; i++) {
      if (temp_buf[i] == '.' || temp_buf[i] == ',') {
        decimal_separator_pos = i; // Keep updating, so we get the LAST one
      }
    }
    
    // Second pass: count digits
    int first_group_digit_count = 0;
    int total_integer_digit_count = 0;
    bool found_first_separator = false;
    
    for (int i = 0; i < 30 && temp_buf[i] != '\0'; i++) {
      // Stop at decimal separator
      if (i == decimal_separator_pos) break;
      
      if (temp_buf[i] >= '0' && temp_buf[i] <= '9') {
        if (!found_first_separator) {
          first_group_digit_count++;
        }
        total_integer_digit_count++;
      } else if ((temp_buf[i] == '.' || temp_buf[i] == ',') && !found_first_separator) {
        found_first_separator = true; // Mark first separator (thousands separator)
      }
    }
    
    // Calculate the multiplier based on digits AFTER the first group
    int remaining_digits = total_integer_digit_count - first_group_digit_count;
    int separator_multiplier = 1;
    for (int i = 0; i < remaining_digits; i++) {
      separator_multiplier *= 10;
    }
    
    // Extract first group value and remainder
    int first_group = full_integer / separator_multiplier;
    int remainder = full_integer % separator_multiplier;
    
    Serial.printf("[BTC Alert] On index 0: full=%d, first_group=%d (x%d), remainder=%d, decimal=%.8f\n", 
                  full_integer, first_group, separator_multiplier, remainder, decimal_part);
    
    // Change just the first group
    if (is_clockwise) {
      if (first_group > 0) first_group--;
    } else {
      first_group++;
    }
    
    // Reconstruct the full value
    int new_integer = (first_group * separator_multiplier) + remainder;
    alert_price_value = new_integer + decimal_part;
    
    updateAlertPriceDisplay();
    Serial.printf("[BTC Alert] First group changed to %d, new value: %d (%.8f)\n", 
                  first_group, new_integer, alert_price_value);
    return;
  }
  
  // For all other indices (after comma): simple 0-9 wrapping
  int char_pos = alert_char_positions[alert_digit_index];
  if (char_pos < 0 || !alert_price_labels[char_pos]) return;
  
  const char* current_text = lv_label_get_text(alert_price_labels[char_pos]);
  int current_digit = (current_text && strlen(current_text) > 0) ? (current_text[0] - '0') : 0;
  
  int new_digit;
  if (is_clockwise) {
    // Clockwise = decrease, wrap to 9 if below 0
    new_digit = (current_digit - 1 + 10) % 10;
  } else {
    // Counterclockwise = increase, wrap to 0 if above 9
    new_digit = (current_digit + 1) % 10;
  }
  
  // Update the label
  char new_char[2] = {(char)('0' + new_digit), '\0'};
  lv_label_set_text(alert_price_labels[char_pos], new_char);
  lv_obj_set_style_text_color(alert_price_labels[char_pos], COLOR_GREEN, 0);
  
  // Reconstruct price from labels
  char price_str[30] = {0};
  int str_idx = 0;
  for (int i = 0; i < 30 && alert_price_labels[i] && lv_obj_is_valid(alert_price_labels[i]); i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && strlen(label_text) > 0) {
      price_str[str_idx++] = label_text[0];
    }
  }
  price_str[str_idx] = '\0';
  
  // Remove commas/punctuation before parsing
  char clean_price[30] = {0};
  int clean_idx = 0;
  for (int i = 0; price_str[i] != '\0' && clean_idx < 29; i++) {
    if (price_str[i] != ',' && price_str[i] != '.') {
      clean_price[clean_idx++] = price_str[i];
    } else if (price_str[i] == '.') {
      // Keep decimal point
      clean_price[clean_idx++] = '.';
    }
  }
  clean_price[clean_idx] = '\0';
  
  alert_price_value = atof(clean_price);
  Serial.printf("[BTC Alert] Digit %d changed to %d, price: %.8f\n", alert_digit_index, new_digit, alert_price_value);
}
// XRP-specific alert digit change (original behavior)
static void changeAlertDigit_XRP(bool is_clockwise) {
  // Get character position of current digit
  if (alert_digit_index < 0 || alert_digit_index >= alert_num_digits) return;
  
  int char_pos = alert_char_positions[alert_digit_index];
  if (char_pos < 0 || !alert_price_labels[char_pos]) return;
  
  // Get current digit value
  const char* current_text = lv_label_get_text(alert_price_labels[char_pos]);
  int current_digit = (current_text && strlen(current_text) > 0) ? (current_text[0] - '0') : 0;
  
  // XRP-style (original behavior for low-value coins)
  // Find decimal point position
  int decimal_pos = -1;
  for (int i = 0; i < 30 && alert_price_labels[i]; i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && label_text[0] == '.') {
      decimal_pos = i;
      break;
    }
  }
  
  // Check if current digit is the last one before the decimal
  bool is_last_before_decimal = false;
  int last_digit_before_decimal = -1;
  int first_digit_before_decimal = -1;
  if (decimal_pos > 0) {
    // Find the first and last digit before decimal
    for (int i = 0; i < alert_num_digits; i++) {
      int pos = alert_char_positions[i];
      if (pos < decimal_pos) {
        if (first_digit_before_decimal == -1) {
          first_digit_before_decimal = i;
        }
        last_digit_before_decimal = i;
      } else {
        break;
      }
    }
    is_last_before_decimal = (alert_digit_index == last_digit_before_decimal);
  }
  
  // Check if this is a digit before the decimal (not after)
  bool is_before_decimal = true;
  for (int i = 0; i < char_pos && i < 30 && alert_price_labels[i]; i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && label_text[0] == '.') {
      is_before_decimal = false;
      break;
    }
  }
  // Get current value before decimal to check for special cases
  char before_decimal[20] = {0};
  int bd_idx = 0;
  for (int i = 0; i < 30 && alert_price_labels[i]; i++) {
    const char* txt = lv_label_get_text(alert_price_labels[i]);
    if (txt && txt[0] == '.') break;
    if (txt && txt[0] >= '0' && txt[0] <= '9') {
      before_decimal[bd_idx++] = txt[0];
    }
  }
  before_decimal[bd_idx] = '\0';
  int value_before_decimal = atoi(before_decimal);
  
  // SPECIAL RULE: If currently on last digit of "10" (the 0) and scrolling down, go to "9"
  bool is_last_digit_of_10 = (value_before_decimal == 10 && alert_digit_index == last_digit_before_decimal);
  
  // Change digit - REVERSED to match brightness/TF
  int new_digit;
  if (is_clockwise) {
    // Clockwise = decrease
    new_digit = current_digit - 1;
    
    // Apply special rule: last digit (0) of exactly 10, going down  becomes 9
    if (is_last_digit_of_10 && new_digit < 0) {
      alert_price_value = 9.0f + (alert_price_value - (int)alert_price_value); // Keep decimal part
      // Set to first digit (which will be the 9)
      alert_digit_index = 0;
      updateAlertPriceDisplay(); // Rebuild with single digit and highlight 9
      return;
    }
  } else {
    // Counterclockwise = increase
    new_digit = current_digit + 1;
  }
  
  // Special handling for digits before decimal (XRP-style)
  if (is_before_decimal) {
    if (new_digit > 9) {
      // SPECIAL CASE: Single digit 9 incrementing to 10 (not 19)
      if (value_before_decimal == 9 && is_last_before_decimal && !is_clockwise) {
        // Simply set value to 10
        alert_price_value = 10.0f + (alert_price_value - (int)alert_price_value);
        updateAlertPriceDisplay();
        return;
      }
      
      // SPECIAL CASE: 10 incrementing to 11 (not 20)
      if (value_before_decimal == 10 && is_last_before_decimal && !is_clockwise) {
        // Increment first digit: 10  11
        int first_digit_pos = alert_char_positions[first_digit_before_decimal];
        if (first_digit_pos >= 0 && alert_price_labels[first_digit_pos]) {
          const char* first_text = lv_label_get_text(alert_price_labels[first_digit_pos]);
          int first_digit = (first_text && strlen(first_text) > 0) ? (first_text[0] - '0') : 0;
          first_digit++;
          char new_first_char[2] = {(char)('0' + first_digit), '\0'};
          lv_label_set_text(alert_price_labels[first_digit_pos], new_first_char);
          lv_obj_set_style_text_color(alert_price_labels[first_digit_pos], COLOR_GREEN, 0);
          
          // Set last digit to 1
          char new_char[2] = {'1', '\0'};
          lv_label_set_text(alert_price_labels[char_pos], new_char);
          lv_obj_set_style_text_color(alert_price_labels[char_pos], COLOR_GREEN, 0);
          
          // Reconstruct price
          char price_str[30] = {0};
          int str_idx = 0;
          for (int i = 0; i < 30 && alert_price_labels[i] && lv_obj_is_valid(alert_price_labels[i]); i++) {
            const char* label_text = lv_label_get_text(alert_price_labels[i]);
            if (label_text && strlen(label_text) > 0) {
              price_str[str_idx++] = label_text[0];
            }
          }
          price_str[str_idx] = '\0';
          
          char clean_price[30] = {0};
          int clean_idx = 0;
          for (int i = 0; price_str[i] != '\0' && clean_idx < 29; i++) {
            if (price_str[i] != ',') {
              clean_price[clean_idx++] = price_str[i];
            }
          }
          clean_price[clean_idx] = '\0';
          
          alert_price_value = atof(clean_price);
          updateAlertPriceDisplay();
          return;
        }
      }
      
      // Calculate place value of this digit
      int digits_to_right = 0;
      for (int i = char_pos + 1; i < 30 && alert_price_labels[i]; i++) {
        const char* txt = lv_label_get_text(alert_price_labels[i]);
        if (txt && txt[0] == '.') break;
        if (txt && txt[0] >= '0' && txt[0] <= '9') digits_to_right++;
      }
      
      // Calculate place value (10^digits_to_right)
      float place_value = 1.0f;
      for (int i = 0; i < digits_to_right; i++) place_value *= 10.0f;
      
      // Add place_value * 10 to add a new leftmost digit (e.g., 99109)
      alert_price_value += place_value * 10.0f;
      
      // If this was the last digit before decimal, move to the new last digit (the 0)
      if (is_last_before_decimal) {
        buildAlertPriceString();
        // Find new last digit before decimal
        int decimal_pos_new = -1;
        for (int i = 0; i < 30 && alert_price_labels[i]; i++) {
          const char* txt = lv_label_get_text(alert_price_labels[i]);
          if (txt && txt[0] == '.') {
            decimal_pos_new = i;
            break;
          }
        }
        if (decimal_pos_new > 0) {
          for (int i = alert_num_digits - 1; i >= 0; i--) {
            int pos = alert_char_positions[i];
            if (pos < decimal_pos_new) {
              alert_digit_index = i;
              break;
            }
          }
        }
      }
      
      updateAlertPriceDisplay();
      return;
    } else if (new_digit < 0) {
      // Handle decrement on digits before decimal
      if (is_last_before_decimal && value_before_decimal > 10) {
        // Last digit going below 0 on multi-digit number
        int value = value_before_decimal;
        value--;
        alert_price_value = value + (alert_price_value - (int)alert_price_value);
        updateAlertPriceDisplay();
        return;
      } else {
        // Wrap to 9
        new_digit = 9;
      }
    } else {
      // Normal change (0-9)
      new_digit = new_digit % 10;
    }
  } else {
    // Digits after decimal: simple wrap 0-9
    new_digit = (new_digit + 10) % 10;
  }
  
  // Update the label
  char new_char[2] = {(char)('0' + new_digit), '\0'};
  lv_label_set_text(alert_price_labels[char_pos], new_char);
  lv_obj_set_style_text_color(alert_price_labels[char_pos], COLOR_GREEN, 0);
  
  // Reconstruct price from labels
  char price_str[30] = {0};
  int str_idx = 0;
  for (int i = 0; i < 30 && alert_price_labels[i] && lv_obj_is_valid(alert_price_labels[i]); i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && strlen(label_text) > 0) {
      price_str[str_idx++] = label_text[0];
    }
  }
  price_str[str_idx] = '\0';
  
  // Remove commas before parsing
  char clean_price[30] = {0};
  int clean_idx = 0;
  for (int i = 0; price_str[i] != '\0' && clean_idx < 29; i++) {
    if (price_str[i] != ',') {
      clean_price[clean_idx++] = price_str[i];
    }
  }
  clean_price[clean_idx] = '\0';
  
  // Parse back to float
  alert_price_value = atof(clean_price);
  
  Serial.printf("[XRP Alert] Digit %d changed to %d, price: %.8f\n", alert_digit_index, new_digit, alert_price_value);
}
// Generic coin alert digit change (simple 0-9 wrapping with expansion before decimal)
static void changeAlertDigit_Generic(bool is_clockwise) {
  // Generic Rules:
  // 1. All digits wrap 0-9 individually
  // 2. Exception: last digit before decimal can expand (91011) or contract (109)
  
  int char_pos = alert_char_positions[alert_digit_index];
  if (char_pos < 0 || !alert_price_labels[char_pos]) return;
  
  const char* current_text = lv_label_get_text(alert_price_labels[char_pos]);
  int current_digit = (current_text && strlen(current_text) > 0) ? (current_text[0] - '0') : 0;
  
  // Find decimal position
  int decimal_pos = -1;
  for (int i = 0; i < 30 && alert_price_labels[i]; i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && (label_text[0] == '.' || label_text[0] == ',')) {
      decimal_pos = i;
      break;
    }
  }
  
  // Check if this is the last digit before decimal
  bool is_last_before_decimal = false;
  if (decimal_pos > 0 && char_pos < decimal_pos) {
    // Check if there are no more digits between this position and decimal
    bool found_another_digit = false;
    for (int i = char_pos + 1; i < decimal_pos; i++) {
      const char* txt = lv_label_get_text(alert_price_labels[i]);
      if (txt && txt[0] >= '0' && txt[0] <= '9') {
        found_another_digit = true;
        break;
      }
    }
    is_last_before_decimal = !found_another_digit;
  }
  
  int new_digit;
  if (is_clockwise) {
    // Clockwise = decrease
    new_digit = current_digit - 1;
    
    // Special case: last digit before decimal going below 0
    if (is_last_before_decimal && new_digit < 0) {
      // Get integer part and decrement it
      int integer_part = (int)alert_price_value;
      if (integer_part > 10) {
        integer_part--;
        alert_price_value = integer_part + (alert_price_value - (int)alert_price_value);
        updateAlertPriceDisplay();
        Serial.printf("[Generic Alert] Last digit contract: %d\n", integer_part);
        return;
      } else {
        new_digit = 9; // Wrap to 9
      }
    } else {
      new_digit = (new_digit + 10) % 10; // Wrap 0-9
    }
  } else {
    // Counterclockwise = increase
    new_digit = current_digit + 1;
    
    // Special case: last digit before decimal going above 9
    if (is_last_before_decimal && new_digit > 9) {
      // Get integer part and increment it
      int integer_part = (int)alert_price_value;
      integer_part++;
      alert_price_value = integer_part + (alert_price_value - (int)alert_price_value);
      updateAlertPriceDisplay();
      Serial.printf("[Generic Alert] Last digit expand: %d\n", integer_part);
      return;
    } else {
      new_digit = new_digit % 10; // Wrap 0-9
    }
  }
  
  // Update the label
  char new_char[2] = {(char)('0' + new_digit), '\0'};
  lv_label_set_text(alert_price_labels[char_pos], new_char);
  lv_obj_set_style_text_color(alert_price_labels[char_pos], COLOR_GREEN, 0);
  
  // Reconstruct price from labels
  char price_str[30] = {0};
  int str_idx = 0;
  for (int i = 0; i < 30 && alert_price_labels[i] && lv_obj_is_valid(alert_price_labels[i]); i++) {
    const char* label_text = lv_label_get_text(alert_price_labels[i]);
    if (label_text && strlen(label_text) > 0) {
      price_str[str_idx++] = label_text[0];
    }
  }
  price_str[str_idx] = '\0';
  
  // Remove commas/punctuation before parsing
  char clean_price[30] = {0};
  int clean_idx = 0;
  for (int i = 0; price_str[i] != '\0' && clean_idx < 29; i++) {
    if (price_str[i] != ',' && price_str[i] != '.') {
      clean_price[clean_idx++] = price_str[i];
    } else if (price_str[i] == '.' || price_str[i] == ',') {
      // Keep the first decimal separator we find
      bool already_has_decimal = false;
      for (int j = 0; j < clean_idx; j++) {
        if (clean_price[j] == '.') {
          already_has_decimal = true;
          break;
        }
      }
      if (!already_has_decimal) {
        clean_price[clean_idx++] = '.';
      }
    }
  }
  clean_price[clean_idx] = '\0';
  
  alert_price_value = atof(clean_price);
  Serial.printf("[Generic Alert] Digit %d changed to %d, price: %.8f\n", alert_digit_index, new_digit, alert_price_value);
}

// Main router function - calls BTC, XRP, or Generic specific function
static void changeAlertDigit(bool is_clockwise) {
  bool is_btc = (pairs[current_pair].symbol == "BTCUSDT" || pairs[current_pair].symbol == "BTC");
  bool is_xrp = (pairs[current_pair].symbol == "XRPUSDT" || pairs[current_pair].symbol == "XRP");
  
  const char* logic_type = is_btc ? "BTC" : (is_xrp ? "XRP" : "Generic");
  Serial.printf("[Alert Router] symbol=%s, calling %s logic\n", 
                pairs[current_pair].symbol.c_str(), logic_type);
  
  if (is_btc) {
    changeAlertDigit_BTC(is_clockwise);
  } else if (is_xrp) {
    changeAlertDigit_XRP(is_clockwise);
  } else {
    changeAlertDigit_Generic(is_clockwise);
  }
}

// Move to next digit
static void nextAlertDigit() {
  // Simple increment with wrap around (works for both BTC and XRP now)
  alert_digit_index = (alert_digit_index + 1) % alert_num_digits;
  updateAlertPriceDisplay();  // Rebuild to update highlighting
  Serial.printf("[Alert] Moved to digit index %d (total digits: %d)\n", alert_digit_index, alert_num_digits);
}

static void alert_create_btn_cb(lv_event_t * e) {
  Serial.println("Create alert button pressed!");
  Serial.printf("[Alert] Current alert_price_value: %.8f\n", alert_price_value);
  Serial.printf("[Alert] Current coin: %s (symbol: %s)\n", 
                pairs[current_pair].display_name.c_str(), 
                pairs[current_pair].symbol.c_str());
  
  // ALWAYS create alert - removed validation that was blocking legitimate alerts
  // Add the alert BEFORE closing popup or changing screens
  addAlert(alert_price_value);
  
  // Small delay to ensure alert is saved to NVS
  delay(50);
  
  // Delete the entire alert (background + popup) to prevent dimness stacking
  if (alert_bg && lv_obj_is_valid(alert_bg)) {
    lv_obj_del(alert_bg);
    alert_bg = nullptr;
    alert_popup = nullptr;
    alert_encoder_mode = false;
  }
  
  if (control_panel_visible) {
    hideControlPanel();
  }
  control_panel_visible = false;
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_obj_set_style_opa(control_panel, 0, 0);
  }
  
  // Navigate to live price page (crypto display screen)
  if (crypto_display_screen && lv_obj_is_valid(crypto_display_screen)) {
    lv_scr_load(crypto_display_screen);
    Serial.println("[Alert] Navigated to live price page");
    
    // Force bell icon to show after screen loads
    delay(100); // Small delay for screen to fully load
    lv_timer_handler(); // Process UI updates
    
    // Check if alert was actually created and show bell
    if (hasActiveAlerts()) {
      Serial.println("[Alert] Active alerts detected, showing bell icon");
      showAlertBellIcon();
    } else {
      Serial.println("[Alert] WARNING: No active alerts found after creation!");
    }
  }
}
static void alert_back_btn_cb(lv_event_t * e) {
  Serial.println("Back from alert popup");
  
  // Delete the entire alert (background + popup) to prevent dimness stacking
  if (alert_bg && lv_obj_is_valid(alert_bg)) {
    lv_obj_del(alert_bg);
    alert_bg = nullptr;
    alert_popup = nullptr;
    alert_encoder_mode = false;
  }
  
  if (control_panel_visible) {
    hideControlPanel();
  }
  control_panel_visible = false;
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_obj_set_style_opa(control_panel, 0, 0);
  }
  if (crypto_display_screen && lv_obj_is_valid(crypto_display_screen)) {
    lv_scr_load(crypto_display_screen);
    Serial.println("[Alert] Returned to live price page");
  }
}

/* ===== ALERT SYSTEM ===== */

// Load all universal alerts from NVS
static void loadAlerts() {
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    String alert_key = "alert_" + String(i);
    coin_alerts[i].coin_symbol = customPrefs.getString((alert_key + "_sym").c_str(), "");
    coin_alerts[i].coin_name = customPrefs.getString((alert_key + "_name").c_str(), "");
    coin_alerts[i].price = customPrefs.getFloat((alert_key + "_price").c_str(), 0.0f);
    coin_alerts[i].created = customPrefs.getULong((alert_key + "_time").c_str(), 0);
    coin_alerts[i].is_upward = customPrefs.getBool((alert_key + "_up").c_str(), true);
    coin_alerts[i].active = (coin_alerts[i].price > 0.0f && coin_alerts[i].coin_symbol.length() > 0);
  }
  Serial.printf("[Alerts] Loaded %d universal alerts\n", MAX_TOTAL_ALERTS);
}

// Save all universal alerts to NVS
static void saveAlerts() {
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    String alert_key = "alert_" + String(i);
    if (coin_alerts[i].active) {
      customPrefs.putString((alert_key + "_sym").c_str(), coin_alerts[i].coin_symbol);
      customPrefs.putString((alert_key + "_name").c_str(), coin_alerts[i].coin_name);
      customPrefs.putFloat((alert_key + "_price").c_str(), coin_alerts[i].price);
      customPrefs.putULong((alert_key + "_time").c_str(), coin_alerts[i].created);
      customPrefs.putBool((alert_key + "_up").c_str(), coin_alerts[i].is_upward);
    } else {
      customPrefs.remove((alert_key + "_sym").c_str());
      customPrefs.remove((alert_key + "_name").c_str());
      customPrefs.remove((alert_key + "_price").c_str());
      customPrefs.remove((alert_key + "_time").c_str());
      customPrefs.remove((alert_key + "_up").c_str());
    }
  }
  Serial.println("[Alerts] Saved all universal alerts");
}

// Add a new alert
static void addAlert(float price) {
  Serial.printf("[addAlert] Called with price: %.8f\n", price);
  
  float current_price = pairs[current_pair].last_price;
  Serial.printf("[addAlert] Current price: %.8f\n", current_price);
  
  // Count active alerts before adding
  int active_count_before = 0;
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (coin_alerts[i].active) active_count_before++;
  }
  Serial.printf("[addAlert] Active alerts before: %d/%d\n", active_count_before, MAX_TOTAL_ALERTS);
  
  // Find first empty slot
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (!coin_alerts[i].active) {
      Serial.printf("[addAlert] Found empty slot at index %d\n", i);
      
      coin_alerts[i].coin_symbol = pairs[current_pair].symbol;
      coin_alerts[i].coin_name = pairs[current_pair].display_name;
      coin_alerts[i].price = price;
      coin_alerts[i].created = time(nullptr);
      coin_alerts[i].active = true;
      // Determine direction: if alert price > current price, it's upward (GREEN), else downward (RED)
      coin_alerts[i].is_upward = (price > current_price);
      
      Serial.printf("[addAlert] Alert data: symbol=%s, name=%s, price=%.8f, active=%d, is_upward=%d\n",
                    coin_alerts[i].coin_symbol.c_str(),
                    coin_alerts[i].coin_name.c_str(),
                    coin_alerts[i].price,
                    coin_alerts[i].active,
                    coin_alerts[i].is_upward);
      
      saveAlerts();
      Serial.printf("[Alerts]  Added %s alert for %s at $%.8f (current: $%.8f) - slot %d\n", 
                   coin_alerts[i].is_upward ? "UPWARD/GREEN" : "DOWNWARD/RED", 
                   coin_alerts[i].coin_name.c_str(), price, current_price, i);
      
      // Show bell icon since we have at least one alert
      showAlertBellIcon();
      
      // Verify alert was saved
      int active_count_after = 0;
      for (int j = 0; j < MAX_TOTAL_ALERTS; j++) {
        if (coin_alerts[j].active) active_count_after++;
      }
      Serial.printf("[addAlert] Active alerts after: %d/%d\n", active_count_after, MAX_TOTAL_ALERTS);
      
      return;
    }
  }
  Serial.println("[Alerts]  ERROR: No free alert slots! All slots full.");
}

// Remove an alert
static void removeAlert(int index) {
  if (index >= 0 && index < MAX_TOTAL_ALERTS && coin_alerts[index].active) {
    Serial.printf("[Alerts] Removing alert for %s at $%.8f\n", 
                 coin_alerts[index].coin_name.c_str(), coin_alerts[index].price);
    coin_alerts[index].active = false;
    coin_alerts[index].coin_symbol = "";
    coin_alerts[index].coin_name = "";
    coin_alerts[index].price = 0.0f;
    coin_alerts[index].created = 0;
    saveAlerts();
    
    // Check if any alerts remain
    bool has_alerts = false;
    for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
      if (coin_alerts[i].active) {
        has_alerts = true;
        break;
      }
    }
    
    // Hide bell icon if no alerts remain
    if (!has_alerts) {
      hideAlertBellIcon();
    }
  }
}

static bool hasActiveAlerts() {
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (coin_alerts[i].active) {
      return true;
    }
  }
  return false;
}

static void refreshAlertBellIcon() {
  if (lv_scr_act() != crypto_display_screen) return;

  if (!show_alert_bell || !hasActiveAlerts()) {
    hideAlertBellIcon();
    return;
  }

  showAlertBellIcon();
}
// Show alert bell icon on homepage (positioned beneath the coin name)
static void showAlertBellIcon() {
  if (!swipe_container || !lv_obj_is_valid(swipe_container)) return;
  
  // First hide existing icon if present to ensure clean recreation
  if (alert_bell_icon && lv_obj_is_valid(alert_bell_icon)) {
    hideAlertBellIcon();
  }
  
  // Create bell icon with expanded hitbox
  if (!alert_bell_icon || !lv_obj_is_valid(alert_bell_icon)) {
    // Create a transparent container for larger hitbox - CHILD OF SWIPE_CONTAINER
    lv_obj_t *bell_hitbox = lv_obj_create(swipe_container);
    lv_obj_set_size(bell_hitbox, 60, 60); // Larger hitbox (30% bigger than visual)
    lv_obj_set_style_bg_opa(bell_hitbox, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(bell_hitbox, 0, 0);
    lv_obj_set_style_pad_all(bell_hitbox, 0, 0);
    lv_obj_clear_flag(bell_hitbox, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_flag(bell_hitbox, LV_OBJ_FLAG_EVENT_BUBBLE); // Allow events to bubble up
    
    // Position hitbox beneath the clock label on the left side
    if (clock_label && lv_obj_is_valid(clock_label)) {
      lv_obj_align_to(bell_hitbox, clock_label, LV_ALIGN_OUT_BOTTOM_LEFT, -5, 6);
    } else {
      lv_obj_align(bell_hitbox, LV_ALIGN_TOP_LEFT, 0, 60); // Fallback if clock unavailable
    }
    
    // Make hitbox clickable with SHORT press detection
    lv_obj_add_flag(bell_hitbox, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(bell_hitbox, alert_bell_clicked_cb, LV_EVENT_CLICKED, NULL);
    
    // Create actual bell icon inside hitbox (centered)
    alert_bell_icon = lv_img_create(bell_hitbox);
    lv_img_set_src(alert_bell_icon, &Alert);
    
    // Scale 30% smaller (70% of original size)
    lv_img_set_zoom(alert_bell_icon, 179); // 256 * 0.70 = 179
    
    // Center icon in hitbox
    lv_obj_center(alert_bell_icon);
    
    Serial.println("[Alerts] Bell icon shown beneath coin name (inside swipe_container)");
  }
}

// Hide alert bell icon
static void hideAlertBellIcon() {
  if (alert_bell_icon && lv_obj_is_valid(alert_bell_icon)) {
    // Delete parent hitbox (which will delete the icon too)
    lv_obj_t *parent = lv_obj_get_parent(alert_bell_icon);
    if (parent && lv_obj_is_valid(parent)) {
      lv_obj_del(parent);
    }
    alert_bell_icon = nullptr;
    Serial.println("[Alerts] Bell icon and hitbox hidden");
  }
}

// Bell icon clicked - show alerts popup
static void alert_bell_clicked_cb(lv_event_t * e) {
  Serial.println("[Alerts] Bell icon clicked");
  showAlertsPopup();
}

/* ===== COIN INFO SYSTEM ===== */

// Show coin info button in control panel (only on live price page)
static void showCoinInfoIcon() {
  if (!coin_info_button || !lv_obj_is_valid(coin_info_button)) return;

  bool on_live_price = (lv_scr_act() == crypto_display_screen);

  if (!show_coin_info || !on_live_price) {
    lv_obj_add_flag(coin_info_button, LV_OBJ_FLAG_HIDDEN);
  } else {
    lv_obj_clear_flag(coin_info_button, LV_OBJ_FLAG_HIDDEN);
  }
}

// Hide coin info button
static void hideCoinInfoIcon() {
  if (coin_info_button && lv_obj_is_valid(coin_info_button)) {
    lv_obj_add_flag(coin_info_button, LV_OBJ_FLAG_HIDDEN);
    Serial.println("[CoinInfo] Coin info button hidden");
  }
}

// Info icon clicked - show coin info popup
static void coin_info_clicked_cb(lv_event_t * e) {
  LV_UNUSED(e);
  Serial.println("[CoinInfo] Coin info button clicked");
  hideControlPanel();
  showCoinInfoPopup();
}

// Check if coin info is cached and still valid
static bool getCachedCoinInfo(const String& symbol, String& cachedData) {
  unsigned long currentTime = millis();
  
  for (int i = 0; i < COIN_INFO_CACHE_SIZE; i++) {
    if (coin_info_cache[i].valid && coin_info_cache[i].symbol == symbol) {
      // Check if cache is still fresh (within 10 minutes)
      if (currentTime - coin_info_cache[i].timestamp < COIN_INFO_CACHE_DURATION) {
        cachedData = coin_info_cache[i].displayData;
        if (cachedData.indexOf("Performance past year") == -1) {
          coin_info_cache[i].valid = false;
          Serial.println("[CoinInfo] Cache entry invalidated due to outdated format");
          continue;
        }
        Serial.printf("[CoinInfo] Cache HIT for %s (age: %lu seconds)\n", 
                     symbol.c_str(), (currentTime - coin_info_cache[i].timestamp) / 1000);
        return true;
      } else {
        // Cache expired
        coin_info_cache[i].valid = false;
        Serial.printf("[CoinInfo] Cache EXPIRED for %s\n", symbol.c_str());
      }
    }
  }
  
  Serial.printf("[CoinInfo] Cache MISS for %s - fetching from API\n", symbol.c_str());
  return false;
}

// Store coin info in cache
static void cacheCoinInfo(const String& symbol, const String& data) {
  // Find empty slot or oldest entry
  int oldestIndex = 0;
  unsigned long oldestTime = coin_info_cache[0].timestamp;
  bool foundEmpty = false;
  
  for (int i = 0; i < COIN_INFO_CACHE_SIZE; i++) {
    // Use empty slot if available
    if (!coin_info_cache[i].valid) {
      oldestIndex = i;
      foundEmpty = true;
      break;
    }
    
    // Track oldest entry
    if (coin_info_cache[i].timestamp < oldestTime) {
      oldestTime = coin_info_cache[i].timestamp;
      oldestIndex = i;
    }
  }
  
  // Store in cache
  coin_info_cache[oldestIndex].symbol = symbol;
  coin_info_cache[oldestIndex].displayData = data;
  coin_info_cache[oldestIndex].timestamp = millis();
  coin_info_cache[oldestIndex].valid = true;
  
  Serial.printf("[CoinInfo] Cached data for %s in slot %d\n", symbol.c_str(), oldestIndex);
}

// Recalculate popup and label sizing after content updates
static void updateCoinInfoPopupLayout() {
  if (!coin_info_label || !lv_obj_is_valid(coin_info_label)) return;
  if (!coin_info_popup || !lv_obj_is_valid(coin_info_popup)) return;

  // Allow label to take natural size based on content
  lv_obj_set_width(coin_info_label, LV_SIZE_CONTENT);
  lv_obj_update_layout(coin_info_label);

  int content_width = lv_obj_get_width(coin_info_label);
  int popup_width = content_width + 60; // 30px padding on each side

  // Constrain popup width to screen bounds
  if (popup_width < 400) popup_width = 400;
  if (popup_width > 580) popup_width = 580;

  int label_width = popup_width - 60; // keep label within popup padding
  if (label_width < 300) label_width = 300;

  lv_obj_set_width(coin_info_label, label_width);
  lv_obj_update_layout(coin_info_label);

  int content_height = lv_obj_get_height(coin_info_label);
  int popup_height = content_height + 100; // space for title and padding
  if (popup_height < 350) popup_height = 350;
  if (popup_height > 440) popup_height = 440;

  lv_obj_set_size(coin_info_popup, popup_width, popup_height);
  lv_obj_center(coin_info_popup);

  lv_obj_t *title = lv_obj_get_child(coin_info_popup, 0);
  if (title && lv_obj_is_valid(title)) {
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, -15);
  }

  lv_obj_align(coin_info_label, LV_ALIGN_TOP_MID, 0, 25);

  Serial.printf("[CoinInfo] Popup layout updated (%dx%d, label width %d)\n",
                popup_width, popup_height, label_width);
}
// Fetch coin statistics from CoinGecko API (with caching)
static void fetchCoinStats(const String& symbol) {
  if (!coin_info_label || !lv_obj_is_valid(coin_info_label)) return;
  
  // Check cache first
  String cachedData;
  if (getCachedCoinInfo(symbol, cachedData)) {
    // Use cached data - display immediately (instant load!)
    lv_label_set_recolor(coin_info_label, false);
    lv_label_set_text(coin_info_label, cachedData.c_str());
    lv_obj_set_style_text_color(coin_info_label, COLOR_WHITE, 0);
    lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
    
    updateCoinInfoPopupLayout();
    
    Serial.println("[CoinInfo] Displayed cached data instantly with updated layout");
    return; // Exit - no need to fetch from API
  }
  
  // No cache - show loading message and fetch from API
  lv_label_set_text(coin_info_label, "Loading coin data...");
  lv_obj_set_style_text_color(coin_info_label, COLOR_WHITE, 0);
  
  if (WiFi.status() != WL_CONNECTED) {
    lv_label_set_text(coin_info_label, "No internet connection");
    lv_obj_set_style_text_color(coin_info_label, COLOR_RED, 0);
    lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
    return;
  }
  
  // Convert symbol to CoinGecko ID (simplified mapping)
  String coinId = symbol;
  coinId.toLowerCase();
  
  // Comprehensive coin ID mappings for CoinGecko API
  if (symbol == "BTC") coinId = "bitcoin";
  else if (symbol == "ETH") coinId = "ethereum";
  else if (symbol == "XRP") coinId = "ripple";
  else if (symbol == "BNB") coinId = "binancecoin";
  else if (symbol == "SOL") coinId = "solana";
  else if (symbol == "ADA") coinId = "cardano";
  else if (symbol == "DOGE") coinId = "dogecoin";
  else if (symbol == "DOT") coinId = "polkadot";
  else if (symbol == "MATIC" || symbol == "POL") coinId = "matic-network";
  else if (symbol == "LINK") coinId = "chainlink";
  else if (symbol == "UNI") coinId = "uniswap";
  else if (symbol == "AVAX") coinId = "avalanche-2";
  else if (symbol == "ATOM") coinId = "cosmos";
  else if (symbol == "LTC") coinId = "litecoin";
  else if (symbol == "BCH") coinId = "bitcoin-cash";
  else if (symbol == "SHIB") coinId = "shiba-inu";
  else if (symbol == "TRX") coinId = "tron";
  else if (symbol == "APT") coinId = "aptos";
  else if (symbol == "ARB") coinId = "arbitrum";
  else if (symbol == "OP") coinId = "optimism";
  else if (symbol == "IMX") coinId = "immutable-x";
  else if (symbol == "NEAR") coinId = "near";
  else if (symbol == "STX") coinId = "blockstack";
  else if (symbol == "FIL") coinId = "filecoin";
  else if (symbol == "ICP") coinId = "internet-computer";
  else if (symbol == "HBAR") coinId = "hedera-hashgraph";
  else if (symbol == "VET") coinId = "vechain";
  else if (symbol == "ALGO") coinId = "algorand";
  else if (symbol == "XLM") coinId = "stellar";
  else if (symbol == "AAVE") coinId = "aave";
  else if (symbol == "SAND") coinId = "the-sandbox";
  else if (symbol == "MANA") coinId = "decentraland";
  else if (symbol == "THETA") coinId = "theta-token";
  else if (symbol == "AXS") coinId = "axie-infinity";
  else if (symbol == "FTM") coinId = "fantom";
  else if (symbol == "GRT") coinId = "the-graph";
  else if (symbol == "SUSHI") coinId = "sushi";
  else if (symbol == "CRV") coinId = "curve-dao-token";
  else if (symbol == "SNX") coinId = "havven";
  else if (symbol == "COMP") coinId = "compound-governance-token";
  else if (symbol == "MKR") coinId = "maker";
  else if (symbol == "LDO") coinId = "lido-dao";
  else if (symbol == "RUNE") coinId = "thorchain";
  else if (symbol == "INJ") coinId = "injective-protocol";
  else if (symbol == "PEPE") coinId = "pepe";
  else if (symbol == "FLOKI") coinId = "floki";
  else if (symbol == "BONK") coinId = "bonk";
  else if (symbol == "SUI") coinId = "sui";
  else if (symbol == "SEI") coinId = "sei-network";
  else if (symbol == "TIA") coinId = "celestia";
  else if (symbol == "TON") coinId = "the-open-network";
  else if (symbol == "USDT") coinId = "tether";
  else if (symbol == "USDC") coinId = "usd-coin";
  else if (symbol == "BUSD") coinId = "binance-usd";
  
  // CoinGecko API endpoint (free tier)
  String url = "https://api.coingecko.com/api/v3/coins/" + coinId + "?localization=false&tickers=false&community_data=false&developer_data=false";
  
  Serial.printf("[CoinInfo] Fetching data for %s (ID: %s)\n", symbol.c_str(), coinId.c_str());
  Serial.printf("[CoinInfo] URL: %s\n", url.c_str());
  
  HTTPClient http;
  http.begin(url);
  http.setTimeout(15000); // 15 second timeout for API
  
  int httpCode = http.GET();
  Serial.printf("[CoinInfo] HTTP Response Code: %d\n", httpCode);
  
  if (httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    Serial.printf("[CoinInfo] Payload size: %d bytes\n", payload.length());
    
    // Parse JSON response - large buffer for CoinGecko's detailed response (can be 30KB+)
    DynamicJsonDocument doc(32768); // 32KB buffer for coin data
    DeserializationError error = deserializeJson(doc, payload);
    
    if (error) {
      Serial.printf("[CoinInfo] JSON Parsing Error: %s\n", error.c_str());
      char errorMsg[100];
      snprintf(errorMsg, sizeof(errorMsg), "JSON Parse Error:\n%s", error.c_str());
      lv_label_set_text(coin_info_label, errorMsg);
      lv_obj_set_style_text_color(coin_info_label, COLOR_RED, 0);
      http.end();
      return;
    }
    
    if (!error) {
      // Extract data with proper null checking
      JsonObject market_data = doc["market_data"];
      if (!market_data) {
        lv_label_set_text(coin_info_label, "No market data available");
        lv_obj_set_style_text_color(coin_info_label, COLOR_RED, 0);
        http.end();
        return;
      }
      
      float marketCap = market_data["market_cap"]["usd"].as<float>();
      float volume24h = market_data["total_volume"]["usd"].as<float>();
      float circulatingSupply = market_data["circulating_supply"].as<float>();
      float totalSupply = market_data["total_supply"].as<float>();
      float ath = market_data["ath"]["usd"].as<float>();
      float athChangePercent = market_data["ath_change_percentage"]["usd"].as<float>();
      float priceChange1y = market_data["price_change_percentage_1y"].as<float>();
      
      Serial.printf("[CoinInfo] Parsed data - MCap: %.0f, Vol: %.0f, Supply: %.0f, ATH: %.2f, ATH%%: %.2f, 1y%%: %.2f\n",
                    marketCap, volume24h, circulatingSupply, ath, athChangePercent, priceChange1y);
      
      // Format market cap
      char mcapStr[30];
      if (marketCap >= 1000000000.0) {
        snprintf(mcapStr, sizeof(mcapStr), "$%.1fB", marketCap / 1000000000.0);
      } else if (marketCap >= 1000000.0) {
        snprintf(mcapStr, sizeof(mcapStr), "$%.1fM", marketCap / 1000000.0);
      } else {
        snprintf(mcapStr, sizeof(mcapStr), "$%.0f", marketCap);
      }
      
      // Format volume
      char volumeStr[30];
      if (volume24h >= 1000000000.0) {
        snprintf(volumeStr, sizeof(volumeStr), "$%.1fB", volume24h / 1000000000.0);
      } else if (volume24h >= 1000000.0) {
        snprintf(volumeStr, sizeof(volumeStr), "$%.1fM", volume24h / 1000000.0);
      } else {
        snprintf(volumeStr, sizeof(volumeStr), "$%.0f", volume24h);
      }
      
      // Format circulating supply
      char supplyStr[60];
      if (totalSupply > 0) {
        float supplyPercent = (circulatingSupply / totalSupply) * 100.0;
        if (circulatingSupply >= 1000000000.0) {
          snprintf(supplyStr, sizeof(supplyStr), "%.1fB (%.0f%% of total)", circulatingSupply / 1000000000.0, supplyPercent);
        } else if (circulatingSupply >= 1000000.0) {
          snprintf(supplyStr, sizeof(supplyStr), "%.1fM (%.0f%% of total)", circulatingSupply / 1000000.0, supplyPercent);
        } else {
          snprintf(supplyStr, sizeof(supplyStr), "%.0f (%.0f%% of total)", circulatingSupply, supplyPercent);
        }
      } else {
        if (circulatingSupply >= 1000000000.0) {
          snprintf(supplyStr, sizeof(supplyStr), "%.1fB", circulatingSupply / 1000000000.0);
        } else if (circulatingSupply >= 1000000.0) {
          snprintf(supplyStr, sizeof(supplyStr), "%.1fM", circulatingSupply / 1000000.0);
        } else {
          snprintf(supplyStr, sizeof(supplyStr), "%.0f", circulatingSupply);
        }
      }
      
      // Build display string without color coding (all white text)
      char displayStr[512];
      char athStr[40];
      snprintf(athStr, sizeof(athStr), "$%.2f", ath);
      
      // Build the display string with neutral coloring
      snprintf(displayStr, sizeof(displayStr),
               "Market Cap: %s\n\n"
               "Volume (24h): %s\n\n"
               "Circulating Supply:\n%s\n\n"
               "All Time High: %s\n\n"
               "Down from ATH: %.2f%%\n\n"
               "Performance past year: %+.2f%%",
               mcapStr,
               volumeStr,
               supplyStr,
               athStr,
               fabs(athChangePercent),
               priceChange1y);
      
      lv_label_set_recolor(coin_info_label, false);
      lv_label_set_text(coin_info_label, displayStr);
      
      // Set base text color to white
      lv_obj_set_style_text_color(coin_info_label, COLOR_WHITE, 0);
      
      // Center align the text
      lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
      
      // Cache the formatted display string for future use
      cacheCoinInfo(symbol, displayStr);
      
      updateCoinInfoPopupLayout();
      
      Serial.println("[CoinInfo] Coin stats fetched from API, cached, and layout updated");
      
    } else {
      lv_label_set_text(coin_info_label, "Failed to parse coin data");
      lv_obj_set_style_text_color(coin_info_label, COLOR_RED, 0);
      lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
    }
  } else {
    // Handle specific error codes
    char errorMsg[150];
    if (httpCode == 429) {
      snprintf(errorMsg, sizeof(errorMsg), "Rate limit reached\n\nPlease wait 1 minute\nbefore trying again");
    } else if (httpCode == 404) {
      snprintf(errorMsg, sizeof(errorMsg), "Coin not found\n\nThis coin may not be\navailable on CoinGecko");
    } else {
      snprintf(errorMsg, sizeof(errorMsg), "API request failed\nHTTP Code: %d", httpCode);
    }
    lv_label_set_text(coin_info_label, errorMsg);
    lv_obj_set_style_text_color(coin_info_label, COLOR_RED, 0);
    lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
  }
  
  http.end();
}

// Show coin info popup with stats
static void showCoinInfoPopup() {
  // Create full-screen dimmed background
  coin_info_popup_bg = lv_obj_create(lv_layer_top());
  lv_obj_set_size(coin_info_popup_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(coin_info_popup_bg, 0, 0);
  lv_obj_set_style_bg_color(coin_info_popup_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(coin_info_popup_bg, 128, 0); // 50% opacity dimmed overlay
  lv_obj_set_style_border_width(coin_info_popup_bg, 0, 0);
  lv_obj_set_style_radius(coin_info_popup_bg, 0, 0);
  lv_obj_set_style_pad_all(coin_info_popup_bg, 0, 0);
  lv_obj_clear_flag(coin_info_popup_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(coin_info_popup_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on overlay to close popup
  lv_obj_add_event_cb(coin_info_popup_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[CoinInfo] Background clicked - closing coin info popup");
      hideCoinInfoPopup();
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create popup panel (centered, dark gray) - will be resized after content loads
  coin_info_popup = lv_obj_create(coin_info_popup_bg);
  lv_obj_set_size(coin_info_popup, 500, 400); // Initial size
  lv_obj_center(coin_info_popup);
  lv_obj_set_style_bg_color(coin_info_popup, lv_color_make(10, 10, 10), 0); // Dark gray
  lv_obj_set_style_bg_opa(coin_info_popup, LV_OPA_COVER, 0);
  lv_obj_set_style_radius(coin_info_popup, 20, 0); // Rounded corners
  lv_obj_set_style_border_width(coin_info_popup, 0, 0);
  lv_obj_set_style_pad_all(coin_info_popup, 30, 0); // Extra padding for centered text
  lv_obj_clear_flag(coin_info_popup, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(coin_info_popup, LV_OBJ_FLAG_CLICKABLE); // Prevent click-through
  
  // Stop event propagation (clicking on popup doesn't close it)
  lv_obj_add_event_cb(coin_info_popup, [](lv_event_t *e) {
    // Do nothing - just stop event from bubbling to background
  }, LV_EVENT_CLICKED, NULL);
  
  // Title - moved up 15 pixels
  lv_obj_t *title = lv_label_create(coin_info_popup);
  String titleText = pairs[current_pair].display_name + " Info";
  lv_label_set_text(title, titleText.c_str());
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, -15);
  
  // Info label (will be populated by API fetch or cache)
  coin_info_label = lv_label_create(coin_info_popup);
  lv_label_set_text(coin_info_label, "Loading...");
  lv_obj_set_width(coin_info_label, LV_SIZE_CONTENT);
  lv_label_set_long_mode(coin_info_label, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(coin_info_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(coin_info_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_align(coin_info_label, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_align(coin_info_label, LV_ALIGN_TOP_MID, 0, 25); // Adjusted for title moved up
  updateCoinInfoPopupLayout();
  
  // Fetch coin stats from API (will auto-resize popup after data loads)
  fetchCoinStats(pairs[current_pair].display_name);
  
  Serial.println("[CoinInfo] Coin info popup shown");
}
// Hide coin info popup
static void hideCoinInfoPopup() {
  if (coin_info_popup_bg && lv_obj_is_valid(coin_info_popup_bg)) {
    lv_obj_del(coin_info_popup_bg);
    coin_info_popup_bg = nullptr;
    coin_info_popup = nullptr;
    coin_info_label = nullptr;
    Serial.println("[CoinInfo] Coin info popup hidden");
  }
}
// Create alerts popup (list of all active alerts)
static void createAlertsPopup() {
  // Hide control panel to prevent dimness stacking
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  // Create full-screen dimmed background
  alerts_popup_bg = lv_obj_create(lv_layer_top());
  lv_obj_set_size(alerts_popup_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(alerts_popup_bg, 0, 0);
  lv_obj_set_style_bg_color(alerts_popup_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(alerts_popup_bg, 128, 0);
  lv_obj_set_style_border_width(alerts_popup_bg, 0, 0);
  lv_obj_set_style_radius(alerts_popup_bg, 0, 0);
  lv_obj_set_style_pad_all(alerts_popup_bg, 0, 0);
  lv_obj_clear_flag(alerts_popup_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(alerts_popup_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on overlay to close alerts popup
  lv_obj_add_event_cb(alerts_popup_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Alerts] Background clicked - closing alerts popup");
      hideAlertsPopup();
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create popup panel (not scrollable itself)
  alerts_popup = lv_obj_create(alerts_popup_bg);
  lv_obj_set_size(alerts_popup, control_panel_width, 460);
  lv_obj_align(alerts_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(alerts_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_radius(alerts_popup, 20, 0);
  lv_obj_set_style_border_width(alerts_popup, 0, 0);
  lv_obj_set_style_pad_all(alerts_popup, 20, 0);
  lv_obj_clear_flag(alerts_popup, LV_OBJ_FLAG_SCROLLABLE);
  
  // Title
  lv_obj_t *title = lv_label_create(alerts_popup);
  lv_label_set_text(title, "All Alerts");
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 25);
  
  // Clear all button (red text, same size as title, to the right of title)
  // Count active alerts to determine visibility
  int active_alert_count = 0;
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (coin_alerts[i].active) active_alert_count++;
  }
  
  lv_obj_t *clear_all_btn = lv_label_create(alerts_popup);
  lv_label_set_text(clear_all_btn, "Clear all");
  lv_obj_set_style_text_font(clear_all_btn, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(clear_all_btn, COLOR_RED, 0);
  lv_obj_align_to(clear_all_btn, title, LV_ALIGN_OUT_RIGHT_MID, 40, 0); // 40px to the right of title
  lv_obj_add_flag(clear_all_btn, LV_OBJ_FLAG_CLICKABLE);
  
  // Hide if no active alerts
  if (active_alert_count == 0) {
    lv_obj_add_flag(clear_all_btn, LV_OBJ_FLAG_HIDDEN);
  }
  
  lv_obj_add_event_cb(clear_all_btn, [](lv_event_t *e) {
    Serial.println("[Alerts] Clear all clicked");
    // Clear all alerts
    for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
      if (coin_alerts[i].active) {
        coin_alerts[i].active = false;
        coin_alerts[i].coin_symbol = "";
        coin_alerts[i].coin_name = "";
        coin_alerts[i].price = 0.0f;
        coin_alerts[i].created = 0;
      }
    }
    saveAlerts();
    hideAlertBellIcon();
    // Refresh the popup to show empty state
    hideAlertsPopup();
    showAlertsPopup();
  }, LV_EVENT_CLICKED, NULL);
  
  // Scrollable container for alerts (invisible scrollbar, no rubberband)
  lv_obj_t *alerts_scroll_container = lv_obj_create(alerts_popup);
  lv_obj_set_size(alerts_scroll_container, 410, 300); // Increased height for scrollable area
  lv_obj_set_pos(alerts_scroll_container, 0, 60);
  lv_obj_set_style_bg_opa(alerts_scroll_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(alerts_scroll_container, 0, 0);
  lv_obj_set_style_pad_all(alerts_scroll_container, 0, 0);
  lv_obj_set_scrollbar_mode(alerts_scroll_container, LV_SCROLLBAR_MODE_OFF); // Invisible scrollbar
  lv_obj_set_scroll_dir(alerts_scroll_container, LV_DIR_VER); // Only vertical scrolling
  lv_obj_clear_flag(alerts_scroll_container, LV_OBJ_FLAG_SCROLL_ELASTIC); // Disable rubberband
  lv_obj_set_flex_flow(alerts_scroll_container, LV_FLEX_FLOW_COLUMN); // Stack alerts vertically
  lv_obj_set_flex_align(alerts_scroll_container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
  
  // List active alerts
  int alert_count = 0;
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (coin_alerts[i].active) {
      // Create alert item container (no background, just text) - NOT scrollable
      lv_obj_t *alert_item = lv_obj_create(alerts_scroll_container);
      lv_obj_set_size(alert_item, 410, 70);
      lv_obj_set_style_bg_opa(alert_item, LV_OPA_TRANSP, 0); // Transparent background
      lv_obj_set_style_radius(alert_item, 0, 0);
      lv_obj_set_style_border_width(alert_item, 0, 0);
      lv_obj_set_style_pad_all(alert_item, 10, 0);
      lv_obj_add_flag(alert_item, LV_OBJ_FLAG_CLICKABLE);
      lv_obj_clear_flag(alert_item, LV_OBJ_FLAG_SCROLLABLE); // Individual items NOT scrollable
      lv_obj_add_event_cb(alert_item, alert_item_clicked_cb, LV_EVENT_CLICKED, (void*)(intptr_t)i);
      
      // Coin name (top left, moved up 10 pixels)
      lv_obj_t *coin_name_label = lv_label_create(alert_item);
      lv_label_set_text(coin_name_label, coin_alerts[i].coin_name.c_str());
      lv_obj_set_style_text_font(coin_name_label, &poppins_light_20, 0);
      lv_obj_set_style_text_color(coin_name_label, COLOR_GRAY, 0);
      lv_obj_align(coin_name_label, LV_ALIGN_TOP_LEFT, 10, -10);
      
      // Alert price - colored based on direction (green for upward, red for downward)
      lv_obj_t *price_label = lv_label_create(alert_item);
      char buf[30];
      // Find the coin's pair index to format correctly
      int pair_idx = current_pair; // default to current
      for (int p = 0; p < active_pair_count; p++) {
        if (pairs[p].symbol == coin_alerts[i].coin_symbol) {
          pair_idx = p;
          break;
        }
      }
      formatPriceWithCommas(coin_alerts[i].price, buf, sizeof(buf), pair_idx);
      lv_label_set_text_fmt(price_label, "$%s", buf);
      lv_obj_set_style_text_font(price_label, &poppins_semibold_32, 0);
      // Color: green if upward alert, red if downward alert
      lv_color_t price_color = coin_alerts[i].is_upward ? COLOR_GREEN : COLOR_RED;
      lv_obj_set_style_text_color(price_label, price_color, 0);
      lv_obj_align(price_label, LV_ALIGN_BOTTOM_LEFT, 10, 0);
      
      // Time created - now in white, using epoch time
      time_t now = time(nullptr);
      unsigned long age_seconds = (now > coin_alerts[i].created) ? (now - coin_alerts[i].created) : 0;
      unsigned long age_minutes = age_seconds / 60;
      lv_obj_t *time_label = lv_label_create(alert_item);
      if (age_minutes < 60) {
        lv_label_set_text_fmt(time_label, "%lum ago", age_minutes);
      } else if (age_minutes < 1440) {
        lv_label_set_text_fmt(time_label, "%luh ago", age_minutes / 60);
      } else {
        lv_label_set_text_fmt(time_label, "%lud ago", age_minutes / 1440);
      }
      lv_obj_set_style_text_font(time_label, &poppins_medium_20, 0); // Smaller font for time
      lv_obj_set_style_text_color(time_label, COLOR_WHITE, 0); // White instead of gray
      lv_obj_align(time_label, LV_ALIGN_RIGHT_MID, -10, 0);
      
      alert_count++;
    }
  }
  
  // If no alerts, show message in the scroll container (centered horizontally)
  if (alert_count == 0) {
    lv_obj_t *no_alerts = lv_label_create(alerts_scroll_container);
    lv_label_set_text(no_alerts, "No active alerts");
    lv_obj_set_style_text_font(no_alerts, &poppins_light_20, 0);
    lv_obj_set_style_text_color(no_alerts, COLOR_GRAY, 0);
    lv_obj_set_width(no_alerts, lv_pct(100)); // Full width for centering
    lv_obj_set_style_text_align(no_alerts, LV_TEXT_ALIGN_CENTER, 0); // Center text horizontally
    lv_obj_align(no_alerts, LV_ALIGN_TOP_MID, 0, 100); // Center horizontally, specific vertical position
  }
  
  // Back button (bottom left, moved down 10px)
  lv_obj_t *back_btn = lv_btn_create(alerts_popup);
  lv_obj_set_size(back_btn, 160, 50);
  lv_obj_align(back_btn, LV_ALIGN_BOTTOM_LEFT, 15, -25); // Moved from -15 to -25
  lv_obj_set_style_bg_color(back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(back_btn, alerts_popup_back_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *back_label = lv_label_create(back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label);
  
  // Create Alert button (bottom right, moved down 10px)
  lv_obj_t *create_btn = lv_btn_create(alerts_popup);
  lv_obj_set_size(create_btn, 180, 50);
  lv_obj_align(create_btn, LV_ALIGN_BOTTOM_RIGHT, -15, -25); // Moved from -15 to -25
  lv_obj_set_style_bg_color(create_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(create_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(create_btn, [](lv_event_t *e) {
    // Close Alerts popup and open Create Alert page
    hideAlertsPopup();
    control_panel_alert_cb(nullptr); // Opens Create Alert popup
  }, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *create_label = lv_label_create(create_btn);
  lv_label_set_text(create_label, "Create Alert");
  lv_obj_set_style_text_font(create_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(create_label, COLOR_BLACK, 0);
  lv_obj_center(create_label);
  
  // Setup encoder focus for button navigation with rotary wheel
  encoderFocusBegin(alerts_popup);
  encoderFocusAdd(back_btn, back_label);
  encoderFocusAdd(create_btn, create_label);
  encoderFocusCommit(0);
  
  Serial.printf("[Alerts] Popup created with %d alerts and encoder focus enabled\n", alert_count);
}

// Show alerts popup
static void showAlertsPopup() {
  createAlertsPopup();
}

// Hide alerts popup
static void hideAlertsPopup() {
  if (alerts_popup_bg && lv_obj_is_valid(alerts_popup_bg)) {
    // Clear encoder focus if active for this screen
    if (encoderFocusIsActive() && encoder_focus_ctx.screen == alerts_popup) {
      encoderFocusReset();
    }
    lv_obj_del(alerts_popup_bg);
    alerts_popup_bg = nullptr;
    alerts_popup = nullptr;
  }
}

// Alerts popup back button
static void alerts_popup_back_cb(lv_event_t * e) {
  hideAlertsPopup();
}

// Alert item clicked - show delete confirmation
static void alert_item_clicked_cb(lv_event_t * e) {
  int index = (int)(intptr_t)lv_event_get_user_data(e);
  Serial.printf("[Alerts] Alert clicked: index=%d, price=$%.8f\n", index, coin_alerts[index].price);
  selected_alert_index = index;
  createAlertDeleteConfirmation(index);
}

// Create delete confirmation popup
static void createAlertDeleteConfirmation(int alert_index) {
  // Create delete confirmation popup
  alert_delete_popup = lv_obj_create(lv_layer_top());
  lv_obj_set_size(alert_delete_popup, 350, 200);
  lv_obj_center(alert_delete_popup);
  lv_obj_set_style_bg_color(alert_delete_popup, lv_color_make(20, 20, 20), 0);
  lv_obj_set_style_radius(alert_delete_popup, 15, 0);
  lv_obj_set_style_border_width(alert_delete_popup, 0, 0);
  lv_obj_set_style_pad_all(alert_delete_popup, 20, 0);
  
  // Title
  lv_obj_t *title = lv_label_create(alert_delete_popup);
  lv_label_set_text(title, "Remove Alert?");
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 10);
  
  // Alert price
  lv_obj_t *price = lv_label_create(alert_delete_popup);
  char buf[30];
  formatPriceWithCommas(coin_alerts[alert_index].price, buf, sizeof(buf), current_pair);
  lv_label_set_text_fmt(price, "$%s", buf);
  lv_obj_set_style_text_font(price, &poppins_light_20, 0);
  lv_obj_set_style_text_color(price, COLOR_GRAY, 0);
  lv_obj_align(price, LV_ALIGN_TOP_MID, 0, 50);
  
  // Cancel button
  lv_obj_t *cancel_btn = lv_btn_create(alert_delete_popup);
  lv_obj_set_size(cancel_btn, 140, 45);
  lv_obj_align(cancel_btn, LV_ALIGN_BOTTOM_LEFT, 10, -10);
  lv_obj_set_style_bg_color(cancel_btn, lv_color_make(60, 60, 60), 0);
  lv_obj_set_style_radius(cancel_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(cancel_btn, alert_delete_cancel_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *cancel_label = lv_label_create(cancel_btn);
  lv_label_set_text(cancel_label, "Cancel");
  lv_obj_set_style_text_font(cancel_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(cancel_label, COLOR_WHITE, 0);
  lv_obj_center(cancel_label);
  
  // Remove button
  lv_obj_t *remove_btn = lv_btn_create(alert_delete_popup);
  lv_obj_set_size(remove_btn, 140, 45);
  lv_obj_align(remove_btn, LV_ALIGN_BOTTOM_RIGHT, -10, -10);
  lv_obj_set_style_bg_color(remove_btn, COLOR_RED, 0);
  lv_obj_set_style_radius(remove_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(remove_btn, alert_delete_confirm_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *remove_label = lv_label_create(remove_btn);
  lv_label_set_text(remove_label, "Remove");
  lv_obj_set_style_text_font(remove_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(remove_label, COLOR_WHITE, 0);
  lv_obj_center(remove_label);
}

// Delete confirmed
static void alert_delete_confirm_cb(lv_event_t * e) {
  removeAlert(selected_alert_index);
  
  // Close confirmation popup
  if (alert_delete_popup && lv_obj_is_valid(alert_delete_popup)) {
    lv_obj_del(alert_delete_popup);
    alert_delete_popup = nullptr;
  }
  
  // Refresh alerts popup
  hideAlertsPopup();
  showAlertsPopup();
}

// Delete cancelled
static void alert_delete_cancel_cb(lv_event_t * e) {
  if (alert_delete_popup && lv_obj_is_valid(alert_delete_popup)) {
    lv_obj_del(alert_delete_popup);
    alert_delete_popup = nullptr;
  }
}
// Check if any alerts have been triggered (universal - checks all coins)
static void checkAlertTriggers() {
  if (alert_triggered) return; // Already flashing an alert
  
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (!coin_alerts[i].active) continue;
    
    // Find the coin's current price
    float current_price = 0.0f;
    for (int p = 0; p < active_pair_count; p++) {
      if (pairs[p].symbol == coin_alerts[i].coin_symbol) {
        current_price = pairs[p].last_price;
        break;
      }
    }
    
    if (current_price <= 0.0f) continue; // No valid price for this coin yet
    
    float alert_price = coin_alerts[i].price;
    bool is_upward = coin_alerts[i].is_upward;
    
    // Check if price crossed the alert level in the expected direction
    bool triggered = false;
    if (is_upward && current_price >= alert_price) {
      // Upward alert (GREEN): price reached or exceeded target from below
      triggered = true;
      Serial.printf("[Alerts] TRIGGERED GREEN! %s Alert at $%.8f, current: $%.8f (upward)\n", 
                   coin_alerts[i].coin_name.c_str(), alert_price, current_price);
    } else if (!is_upward && current_price <= alert_price) {
      // Downward alert (RED): price reached or fell below target from above
      triggered = true;
      Serial.printf("[Alerts] TRIGGERED RED! %s Alert at $%.8f, current: $%.8f (downward)\n", 
                   coin_alerts[i].coin_name.c_str(), alert_price, current_price);
    }
    
    if (triggered) {
      triggered_alert_price = alert_price;
      triggered_alert_coin = coin_alerts[i].coin_name;  // Store coin name (e.g., "BTC")
      flashAlertBorder(is_upward); // Use stored direction
      removeAlert(i);
      break; // Only trigger one alert at a time
    }
  }
}

// Version 3: "Alert Badge Popup" - Centered card with slide-in animation
static void flashAlertBorder(bool is_upward) {
  if (!crypto_display_screen || !lv_obj_is_valid(crypto_display_screen)) return;
  
  alert_triggered = true;
  alert_is_upward = is_upward;
  lv_color_t popup_color = is_upward ? COLOR_GREEN : COLOR_RED;
  
  // Full-screen dimmed overlay (same as other popups: 50% black)
  lv_obj_t *alert_overlay = lv_obj_create(lv_layer_top());
  lv_obj_set_size(alert_overlay, LV_PCT(100), LV_PCT(100));
  lv_obj_set_pos(alert_overlay, 0, 0);
  lv_obj_set_style_bg_color(alert_overlay, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(alert_overlay, 128, 0); // 50% dim (same as other popups)
  lv_obj_set_style_border_width(alert_overlay, 0, 0);
  lv_obj_set_style_radius(alert_overlay, 0, 0);
  lv_obj_set_style_pad_all(alert_overlay, 0, 0);
  lv_obj_clear_flag(alert_overlay, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(alert_overlay, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_add_event_cb(alert_overlay, dismissAlertFlash, LV_EVENT_CLICKED, NULL);
  
  // Create temporary popup to measure content (will be resized after price label is added)
  alert_flash_border = lv_obj_create(alert_overlay);
  
  // Popup styling - colored background (green or red)
  lv_obj_set_style_bg_color(alert_flash_border, popup_color, 0);
  lv_obj_set_style_bg_opa(alert_flash_border, 255, 0);
  lv_obj_set_style_radius(alert_flash_border, 20, 0);
  lv_obj_set_style_border_width(alert_flash_border, 0, 0);
  lv_obj_set_style_pad_all(alert_flash_border, 15, 0); // Reduced padding for compactness
  lv_obj_clear_flag(alert_flash_border, LV_OBJ_FLAG_SCROLLABLE);
  
  // Make popup clickable to dismiss
  lv_obj_add_flag(alert_flash_border, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_add_event_cb(alert_flash_border, [](lv_event_t *e) {
    Serial.println("[Alerts] Popup clicked - dismissing");
    dismissAlertFlash(nullptr);
  }, LV_EVENT_CLICKED, NULL);
  
  // "COIN TARGET REACHED" text (white, smaller to fit compact design)
  lv_obj_t *title = lv_label_create(alert_flash_border);
  String title_text = triggered_alert_coin + " TARGET REACHED";
  lv_label_set_text(title, title_text.c_str());
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  
  // Price display using same formatting as current coin (matches decimal places)
  char price_str[64];
  char formatted_price[30];
  formatPriceWithCommas(triggered_alert_price, formatted_price, sizeof(formatted_price), current_pair);
  snprintf(price_str, sizeof(price_str), "$%s", formatted_price);
  
  lv_obj_t *price_label = lv_label_create(alert_flash_border);
  lv_label_set_text(price_label, price_str);
  lv_obj_set_style_text_font(price_label, &poppins_semibold_64, 0); // Same as live price
  lv_obj_set_style_text_color(price_label, COLOR_WHITE, 0);
  
  // Auto-size popup based on content width
  lv_obj_update_layout(price_label); // Force layout update to get accurate width
  int price_width = lv_obj_get_width(price_label);
  int title_width = lv_obj_get_width(title);
  int content_width = (price_width > title_width) ? price_width : title_width;
  
  // Add padding: 15px left + 15px right + 20px extra margin = 50px total
  const int popup_width = content_width + 50;
  const int popup_height = 160;
  
  // Constrain width to reasonable bounds (min 300px, max 580px to fit screen with margin)
  int final_popup_width = popup_width;
  if (final_popup_width < 300) final_popup_width = 300;
  if (final_popup_width > 580) final_popup_width = 580;
  
  lv_obj_set_size(alert_flash_border, final_popup_width, popup_height);
  
  // Re-center elements after popup resize
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 10);
  lv_obj_align(price_label, LV_ALIGN_CENTER, 0, 5);
  
  // Calculate centered positions
  const int screen_height = 450;
  const int screen_width = 600;
  const int centered_y = (screen_height - popup_height) / 2; // Vertical center
  const int centered_x = (screen_width - final_popup_width) / 2; // Horizontal center
  
  // Slide-in animation from top to center
  lv_anim_t slide_in;
  lv_anim_init(&slide_in);
  lv_anim_set_var(&slide_in, alert_flash_border);
  lv_anim_set_exec_cb(&slide_in, [](void *obj, int32_t value) {
    lv_obj_set_y((lv_obj_t*)obj, value);
  });
  lv_anim_set_values(&slide_in, -popup_height, centered_y); // From above screen to vertical center
  lv_anim_set_time(&slide_in, 400); // 400ms smooth slide
  lv_anim_set_path_cb(&slide_in, lv_anim_path_ease_out);
  
  // Start pulsing opacity animation after slide completes (simpler and smoother than scale)
  lv_anim_set_ready_cb(&slide_in, [](lv_anim_t *a) {
    lv_obj_t *popup = (lv_obj_t*)a->var;
    if (popup && lv_obj_is_valid(popup)) {
      // Subtle opacity pulsing animation: 100%  90%  100% (repeat)
      lv_anim_t opacity_pulse;
      lv_anim_init(&opacity_pulse);
      lv_anim_set_var(&opacity_pulse, popup);
      lv_anim_set_exec_cb(&opacity_pulse, [](void *var, int32_t v) {
        lv_obj_set_style_opa((lv_obj_t*)var, v, 0);
      });
      lv_anim_set_values(&opacity_pulse, 230, 255); // 90% to 100% opacity
      lv_anim_set_time(&opacity_pulse, 1500); // 1.5 seconds
      lv_anim_set_playback_time(&opacity_pulse, 1500); // 1.5 seconds back
      lv_anim_set_repeat_count(&opacity_pulse, LV_ANIM_REPEAT_INFINITE);
      lv_anim_set_path_cb(&opacity_pulse, lv_anim_path_ease_in_out);
      lv_anim_start(&opacity_pulse);
      
      Serial.println("[Alerts] Pulsing opacity animation started");
    }
  });
  
  lv_anim_start(&slide_in);
  
  // Set X to center horizontally
  lv_obj_set_x(alert_flash_border, centered_x);
  
  Serial.printf("[Alerts] %s popup displayed at %s\n", is_upward ? "GREEN" : "RED", price_str);
}
// Dismiss alert popup (click anywhere or rotary button)
static void dismissAlertFlash(lv_event_t * e) {
  lv_obj_t *overlay = nullptr;
  
  // Stop any animations on the popup first
  if (alert_flash_border && lv_obj_is_valid(alert_flash_border)) {
    lv_anim_del(alert_flash_border, NULL); // Delete all animations on popup
  }
  
  // Get overlay differently depending on how we were called
  if (e != nullptr) {
    // Called from LVGL event (touch/click) - get from event target
    overlay = lv_event_get_current_target(e);
  } else {
    // Called from encoder button (e is nullptr) - get from alert_flash_border's parent
    if (alert_flash_border && lv_obj_is_valid(alert_flash_border)) {
      overlay = lv_obj_get_parent(alert_flash_border);
    }
  }
  
  // Delete immediately without animation
  if (overlay && lv_obj_is_valid(overlay)) {
    lv_obj_del(overlay);
    alert_flash_border = nullptr;
    alert_triggered = false;
    Serial.println("[Alerts] Popup dismissed");
  }
}


/* ===== Customization Screen ===== */
// Save customization settings to persistent storage
static void saveCustomizationSettings() {
  customPrefs.putBool("show_clock", show_clock);
  customPrefs.putBool("show_wifi", show_wifi);
  customPrefs.putBool("show_coin_name", show_coin_name);
  customPrefs.putBool("show_timeframe", show_timeframe);
  customPrefs.putBool("show_candles", show_candles);
  customPrefs.putBool("show_price", show_price);
  customPrefs.putBool("show_alert_bell", show_alert_bell);
  customPrefs.putBool("show_coin_info", show_coin_info);
  customPrefs.putInt("tf_index", tf_current_index);
  Serial.println("Customization settings saved");
}

// Load customization settings from persistent storage
static void loadCustomizationSettings() {
  show_clock = customPrefs.getBool("show_clock", true);
  show_wifi = customPrefs.getBool("show_wifi", true);
  show_coin_name = customPrefs.getBool("show_coin_name", true);
  show_timeframe = customPrefs.getBool("show_timeframe", true);
  show_candles = customPrefs.getBool("show_candles", true);
  show_price = customPrefs.getBool("show_price", true);
  show_alert_bell = customPrefs.getBool("show_alert_bell", true);
  show_coin_info = customPrefs.getBool("show_coin_info", true);
  
  // Load brightness setting (default to 80% if not set)
  current_brightness_percent = customPrefs.getInt("brightness", 80);
  int brightness = map(current_brightness_percent, 10, 100, 25, 255);
  amoled.setBrightness(brightness);
  
  // Load timeframe setting (default to index 4 which is "4h")
  tf_current_index = customPrefs.getInt("tf_index", 4);
  if (tf_current_index < 0 || tf_current_index >= tfCount) {
    tf_current_index = 4; // fallback to 4h
  }
  tf_preview_index = tf_current_index;  // Sync preview with current
  currentTFStr = tfOptions[tf_current_index];
  
  Serial.printf("Customization settings loaded - Clock:%d WiFi:%d Name:%d TF:%d Candles:%d Price:%d Info:%d Alerts:%d Brightness:%d%% Timeframe:%s\n",
                show_clock, show_wifi, show_coin_name, show_timeframe, show_candles, show_price, show_coin_info, show_alert_bell, current_brightness_percent, currentTFStr);
}

// Helper function to create iOS-style toggle switch
static lv_obj_t* createIOSToggle(lv_obj_t *parent, const char *label_text, bool *state_var, int y_pos) {
  // Container for this toggle row
  lv_obj_t *row = lv_obj_create(parent);
  lv_obj_set_size(row, 410, 40);
  lv_obj_align(row, LV_ALIGN_TOP_LEFT, 0, y_pos);
  lv_obj_set_style_bg_opa(row, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(row, 0, 0);
  lv_obj_set_style_pad_all(row, 0, 0);
  
  // Disable scrolling on the row
  lv_obj_set_scrollbar_mode(row, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(row, LV_OBJ_FLAG_SCROLLABLE);
  
  // Label on the left (not clickable)
  lv_obj_t *label = lv_label_create(row);
  lv_label_set_text(label, label_text);
  lv_obj_set_style_text_font(label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(label, COLOR_WHITE, 0);
  lv_obj_align(label, LV_ALIGN_LEFT_MID, 0, 0);
  
  // iOS-style toggle switch on the right
  lv_obj_t *toggle_bg = lv_obj_create(row);
  lv_obj_set_size(toggle_bg, 51, 31); // iOS toggle size
  lv_obj_align(toggle_bg, LV_ALIGN_RIGHT_MID, 0, 0);
  lv_obj_set_style_radius(toggle_bg, 16, 0); // Round pill shape
  lv_obj_set_style_border_width(toggle_bg, 0, 0);
  lv_obj_set_style_pad_all(toggle_bg, 2, 0);
  
  // Set background color based on state
  if (*state_var) {
    lv_obj_set_style_bg_color(toggle_bg, COLOR_GREEN, 0); // Green when ON
  } else {
    lv_obj_set_style_bg_color(toggle_bg, lv_color_make(120, 120, 120), 0); // Gray when OFF
  }
  
  // White pill inside
  lv_obj_t *toggle_pill = lv_obj_create(toggle_bg);
  lv_obj_set_size(toggle_pill, 27, 27); // White circle
  lv_obj_set_style_radius(toggle_pill, 14, 0); // Round
  lv_obj_set_style_bg_color(toggle_pill, COLOR_WHITE, 0);
  lv_obj_set_style_border_width(toggle_pill, 0, 0);
  lv_obj_set_style_shadow_width(toggle_pill, 0, 0);
  lv_obj_set_style_pad_all(toggle_pill, 0, 0);
  lv_obj_set_scrollbar_mode(toggle_pill, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(toggle_pill, LV_OBJ_FLAG_SCROLLABLE);
  
  // Position pill based on state
  if (*state_var) {
    lv_obj_align(toggle_pill, LV_ALIGN_RIGHT_MID, 0, 0); // Right when ON
  } else {
    lv_obj_align(toggle_pill, LV_ALIGN_LEFT_MID, 0, 0); // Left when OFF
  }
  
  // Create larger invisible clickable area over the toggle - easier to hit!
  lv_obj_t *click_area = lv_obj_create(row);
  lv_obj_set_size(click_area, 120, 40); // Much larger hit area (120px wide, full height)
  lv_obj_align(click_area, LV_ALIGN_RIGHT_MID, 0, 0); // Position on the right over the toggle
  lv_obj_set_style_bg_opa(click_area, LV_OPA_TRANSP, 0); // Invisible
  lv_obj_set_style_border_width(click_area, 0, 0);
  lv_obj_set_scrollbar_mode(click_area, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(click_area, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(click_area, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_add_event_cb(click_area, customization_toggle_cb, LV_EVENT_CLICKED, state_var);
  
  return row;
}

static void customization_toggle_cb(lv_event_t * e) {
  lv_obj_t *click_area = lv_event_get_target(e);
  bool *state_var = (bool*)lv_event_get_user_data(e);
  
  // Toggle the state
  *state_var = !(*state_var);
  
  // Get the row (parent of click_area)
  lv_obj_t *row = lv_obj_get_parent(click_area);
  if (!row || !lv_obj_is_valid(row)) return;
  
  // Get the toggle_bg (child 1 of row - child 0 is label, child 1 is toggle_bg, child 2 is click_area)
  lv_obj_t *toggle_bg = lv_obj_get_child(row, 1);
  if (!toggle_bg || !lv_obj_is_valid(toggle_bg)) return;
  
  // Update toggle appearance
  lv_obj_t *toggle_pill = lv_obj_get_child(toggle_bg, 0);
  
  if (*state_var) {
    // ON state: green background, pill on right
    lv_obj_set_style_bg_color(toggle_bg, COLOR_GREEN, 0);
    lv_obj_align(toggle_pill, LV_ALIGN_RIGHT_MID, 0, 0);
  } else {
    // OFF state: gray background, pill on left
    lv_obj_set_style_bg_color(toggle_bg, lv_color_make(120, 120, 120), 0);
    lv_obj_align(toggle_pill, LV_ALIGN_LEFT_MID, 0, 0);
  }
  
  Serial.printf("Toggle changed: %s\n", *state_var ? "ON" : "OFF");
  
  // Save settings to persistent storage
  saveCustomizationSettings();
  
  // Apply visibility changes immediately
  lv_obj_t *current_screen = lv_scr_act();
  
  // Update clock visibility
  if (state_var == &show_clock && clock_label && lv_obj_is_valid(clock_label)) {
    if (show_clock) {
      lv_obj_clear_flag(clock_label, LV_OBJ_FLAG_HIDDEN);
    } else {
      lv_obj_add_flag(clock_label, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  // Update WiFi visibility (both foreground and background)
  if (state_var == &show_wifi) {
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      if (show_wifi) {
        lv_obj_clear_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
      } else {
        lv_obj_add_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
      }
    }
    // Also hide/show WiFi background
    if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
      if (show_wifi) {
        lv_obj_clear_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
      } else {
        lv_obj_add_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
      }
    }
  }
  
  // Update coin name visibility
  if (state_var == &show_coin_name && pair_label && lv_obj_is_valid(pair_label)) {
    if (show_coin_name) {
      lv_obj_clear_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
    } else {
      lv_obj_add_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  // Update timeframe visibility
  if (state_var == &show_timeframe && tf_btn && lv_obj_is_valid(tf_btn)) {
    if (show_timeframe) {
      lv_obj_clear_flag(tf_btn, LV_OBJ_FLAG_HIDDEN);
    } else {
      lv_obj_add_flag(tf_btn, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  // Update candles visibility
  if (state_var == &show_candles && candle_canvas && lv_obj_is_valid(candle_canvas)) {
    if (show_candles) {
      lv_obj_clear_flag(candle_canvas, LV_OBJ_FLAG_HIDDEN);
    } else {
      lv_obj_add_flag(candle_canvas, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  // Update coin info visibility
  if (state_var == &show_coin_info) {
    if (!show_coin_info) {
      hideCoinInfoIcon();
    } else if (lv_scr_act() == crypto_display_screen) {
      showCoinInfoIcon();
    }
    refreshAlertBellIcon();
  }

  // Update price visibility
  if (state_var == &show_price && price_label && lv_obj_is_valid(price_label)) {
    if (show_price) {
      lv_obj_clear_flag(price_label, LV_OBJ_FLAG_HIDDEN);
    } else {
      lv_obj_add_flag(price_label, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  // Update alert bell visibility
  if (state_var == &show_alert_bell) {
    if (!show_alert_bell) {
      hideAlertBellIcon();
    } else {
      refreshAlertBellIcon();
    }
  }
}

static void createCustomizationScreen() {
  Serial.println("[Edit] ===== CREATING EDIT SCREEN =====");
  Serial.printf("[Edit] Before create: customization_bg=%p, customization_panel=%p\n", 
                customization_bg, customization_panel);
  
  // Create background overlay (same as control panel - 50% opacity)
  customization_bg = lv_obj_create(lv_layer_top());
  lv_obj_set_size(customization_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_bg_color(customization_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(customization_bg, 128, 0); // 50% opacity like control panel and alert
  lv_obj_set_style_radius(customization_bg, 0, 0);
  lv_obj_set_style_border_width(customization_bg, 0, 0);
  lv_obj_add_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
  
  // Disable scrolling on background
  lv_obj_set_scrollbar_mode(customization_bg, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(customization_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_set_scroll_dir(customization_bg, LV_DIR_NONE);
  lv_obj_add_flag(customization_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Click anywhere on overlay to close customization
  lv_obj_add_event_cb(customization_bg, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
      Serial.println("[Edit] Background clicked - closing edit screen");
      hideCustomizationScreen();
      if (control_panel_visible) {
        hideControlPanel();
      }
      control_panel_visible = false;
      if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
        lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
      }
      if (control_panel && lv_obj_is_valid(control_panel)) {
        lv_obj_set_style_opa(control_panel, 0, 0);
      }
      if (crypto_display_screen && lv_obj_is_valid(crypto_display_screen)) {
        lv_scr_load(crypto_display_screen);
      }
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create the actual customization panel (scrollable to fit all toggles + back button)
  customization_panel = lv_obj_create(customization_bg);
  lv_obj_set_size(customization_panel, control_panel_width, 460);
  lv_obj_center(customization_panel);
  lv_obj_set_style_bg_color(customization_panel, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_radius(customization_panel, 20, 0);
  lv_obj_set_style_border_width(customization_panel, 0, 0);
  lv_obj_set_style_pad_all(customization_panel, 20, 20);
  
  // Enable scrolling with invisible scrollbar, no rubberband
  lv_obj_set_scrollbar_mode(customization_panel, LV_SCROLLBAR_MODE_OFF); // Invisible scrollbar
  lv_obj_set_scroll_dir(customization_panel, LV_DIR_VER); // Vertical scrolling only
  lv_obj_clear_flag(customization_panel, LV_OBJ_FLAG_SCROLL_ELASTIC); // No rubberband
  lv_obj_set_flex_flow(customization_panel, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(customization_panel, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
  
  // Title (centered horizontally, moved down 15px)
  lv_obj_t *title = lv_label_create(customization_panel);
  lv_label_set_text(title, "Edit");
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_set_style_pad_top(title, 15, 0); // Move down 15 pixels
  lv_obj_set_style_pad_bottom(title, 30, 0); // Space below title
  lv_obj_set_width(title, lv_pct(100)); // Full width for centering
  lv_obj_set_style_text_align(title, LV_TEXT_ALIGN_CENTER, 0); // Center text
  
  // Create toggles for each UI element (in flex flow)
  // Store in global array for encoder focus
  customization_toggle_rows[0] = createIOSToggle(customization_panel, "Clock", &show_clock, 0);
  customization_toggle_rows[1] = createIOSToggle(customization_panel, "WiFi Symbol", &show_wifi, 0);
  customization_toggle_rows[2] = createIOSToggle(customization_panel, "Alerts", &show_alert_bell, 0);
  customization_toggle_rows[3] = createIOSToggle(customization_panel, "Coin Name", &show_coin_name, 0);
  customization_toggle_rows[4] = createIOSToggle(customization_panel, "Timeframe", &show_timeframe, 0);
  customization_toggle_rows[5] = createIOSToggle(customization_panel, "Candles", &show_candles, 0);
  customization_toggle_rows[6] = createIOSToggle(customization_panel, "Price", &show_price, 0);
  
  // Store toggle state variables in user data for encoder activation
  bool *toggle_states[7] = {&show_clock, &show_wifi, &show_alert_bell, &show_coin_name, &show_timeframe, &show_candles, &show_price};
  for (int i = 0; i < 7; i++) {
    if (customization_toggle_rows[i]) {
      lv_obj_set_user_data(customization_toggle_rows[i], (void*)(intptr_t)i); // Store index
    }
  }
  
  // Container for back button to center it in flex
  lv_obj_t *back_btn_container = lv_obj_create(customization_panel);
  lv_obj_set_size(back_btn_container, lv_pct(100), 80); // Full width container
  lv_obj_set_style_bg_opa(back_btn_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(back_btn_container, 0, 0);
  lv_obj_set_style_pad_all(back_btn_container, 0, 0);
  lv_obj_set_style_pad_top(back_btn_container, 30, 0); // Space above
  lv_obj_clear_flag(back_btn_container, LV_OBJ_FLAG_SCROLLABLE);
  
  // Back button at bottom (centered using align in container)
  customization_back_btn = lv_btn_create(back_btn_container);
  lv_obj_set_size(customization_back_btn, 200, 50);
  lv_obj_align(customization_back_btn, LV_ALIGN_CENTER, 0, 0); // Center in container
  lv_obj_set_style_bg_color(customization_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(customization_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(customization_back_btn, customization_back_cb, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *back_label = lv_label_create(customization_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label); // Center text both horizontally and vertically
  
  // DON'T setup encoder focus here while screen is hidden
  // It will be set up when showing the screen
  
  Serial.println("[Edit] Edit screen created (encoder focus will be set up when showing)");
}

static void showCustomizationScreen() {
  Serial.printf("[Edit] showCustomizationScreen called, customization_bg=%p\n", customization_bg);
  
  // Hide control panel background to prevent dimness stacking
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  
  if (!customization_bg) {
    Serial.println("[Edit] customization_bg is null, calling createCustomizationScreen()");
    createCustomizationScreen();
  }
  
  if (customization_bg && lv_obj_is_valid(customization_bg)) {
    // Show the screen FIRST so items are not hidden
    lv_obj_clear_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
    Serial.println("[Edit] Screen unhidden");
    
    // NOW set up encoder focus while items are visible
    Serial.printf("[Edit] About to set up encoder focus, customization_panel=%p\n", customization_panel);
    
    if (!customization_panel || !lv_obj_is_valid(customization_panel)) {
      Serial.println("[Edit] ERROR: customization_panel is null or invalid!");
      return;
    }
    
    // Reset scroll position to top
    lv_obj_scroll_to_y(customization_panel, 0, LV_ANIM_OFF);
    
    // Set up encoder focus with minimal logging
    encoderFocusBegin(customization_panel);
    
    // Add toggle rows
    for (int i = 0; i < 7; i++) {
      if (customization_toggle_rows[i] && lv_obj_is_valid(customization_toggle_rows[i])) {
        lv_obj_t *label = lv_obj_get_child(customization_toggle_rows[i], 0);
        if (label && lv_obj_is_valid(label)) {
          encoderFocusAdd(customization_toggle_rows[i], label);
        }
      }
    }
    
    // Add back button
    if (customization_back_btn && lv_obj_is_valid(customization_back_btn)) {
      lv_obj_t *back_label = lv_obj_get_child(customization_back_btn, 0);
      if (back_label) {
        encoderFocusAdd(customization_back_btn, back_label);
      }
    }
    
    encoderFocusCommit(0);
    Serial.printf("[Edit] Encoder focus ready: %d items\n", encoder_focus_ctx.count);
  }
}

static void hideCustomizationScreen() {
  // Clear any highlights before hiding to prevent them from persisting
  if (encoder_focus_ctx.screen == customization_panel && encoder_focus_ctx.has_highlight) {
    Serial.printf("[Edit] Clearing highlight at index %d before hiding\n", encoder_focus_ctx.index);
    encoderFocusClearHighlight(encoder_focus_ctx.index);
    encoder_focus_ctx.has_highlight = false;
  }
  
  if (customization_bg && lv_obj_is_valid(customization_bg)) {
    lv_obj_add_flag(customization_bg, LV_OBJ_FLAG_HIDDEN);
  }
}

static void customization_back_cb(lv_event_t * e) {
  Serial.println("Edit back button pressed");
  
  hideCustomizationScreen();

  if (control_panel_visible) {
    hideControlPanel();
  }
  control_panel_visible = false;
  if (control_panel_bg && lv_obj_is_valid(control_panel_bg)) {
    lv_obj_add_flag(control_panel_bg, LV_OBJ_FLAG_HIDDEN);
  }
  if (control_panel && lv_obj_is_valid(control_panel)) {
    lv_obj_set_style_opa(control_panel, 0, 0);
  }
  if (crypto_display_screen && lv_obj_is_valid(crypto_display_screen)) {
    lv_scr_load(crypto_display_screen);
    Serial.println("[Edit] Returned to live price screen");
  }
}

static void initGlobalControlPanel() {
  // Initialize control panel system
  // Create the grabber (swipe detector) at startup, but panels are created on demand
  Serial.println("Initializing control panel system...");
  Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
  
  // Ensure visible state starts as false
  control_panel_visible = false;
  Serial.println("[Control Panel] State reset to visible=FALSE on init");
  
  // Create the persistent top-edge gesture detector (grabber)
  // This must exist from the start to detect swipe gestures
  if (!control_panel_grabber || !lv_obj_is_valid(control_panel_grabber)) {
    control_panel_grabber = lv_obj_create(lv_layer_top());
    if (!control_panel_grabber) {
      Serial.println("ERROR: Failed to create control_panel_grabber");
      return;
    }
    
    lv_obj_set_size(control_panel_grabber, LV_PCT(100), 50); // 50px tall touch area at top
    lv_obj_align(control_panel_grabber, LV_ALIGN_TOP_MID, 0, 0);
    lv_obj_set_style_bg_opa(control_panel_grabber, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(control_panel_grabber, 0, 0);
    lv_obj_set_scrollbar_mode(control_panel_grabber, LV_SCROLLBAR_MODE_OFF);
    lv_obj_clear_flag(control_panel_grabber, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_flag(control_panel_grabber, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_move_foreground(control_panel_grabber);
    
    // Add gesture detection callback
    lv_obj_add_event_cb(control_panel_grabber, [](lv_event_t *e) {
      static int start_y = 0;
      static bool dragging = false;
      
      lv_event_code_t code = lv_event_get_code(e);
      lv_indev_t *indev = lv_indev_get_act();
      if (!indev) return;
      
      lv_point_t point;
      lv_indev_get_point(indev, &point);
      
      if (code == LV_EVENT_PRESSED) {
        start_y = point.y;
        dragging = true;
        Serial.printf("[Control Panel] Drag started at y=%d\n", start_y);
      }
      else if (code == LV_EVENT_PRESSING && dragging) {
        int drag_distance = point.y - start_y;
        if (drag_distance > 50 && !control_panel_visible) {
          Serial.println("[Control Panel] Opening panel!");
          showControlPanel();
          dragging = false;
        }
      }
      else if (code == LV_EVENT_RELEASED) {
        dragging = false;
      }
    }, LV_EVENT_ALL, NULL);
    
    Serial.println("[Control Panel] Persistent grabber created - ready to detect swipes");
  }
  
  // Panel will be created dynamically in showControlPanel() based on current screen
  Serial.println("[Control Panel] Panels will be created on demand (full for live price, simple for other pages)");
}

/* ===== Coins Quick Navigation Popup ===== */

/**
 * @brief Displays a popup with all favorite coins for quick navigation
 * @details Creates a modal popup showing all favorite coins with live prices
 *          and daily price changes. User can click any coin to jump to it
 *          on the main crypto display screen. Popup is fully navigable with
 *          rotary encoder (scroll through coins, click to select).
 * @note - Automatically fetches and displays latest prices for all coins
 *       - Closes any other open popups before displaying
 *       - Registers with PopupManager to prevent multiple popups
 *       - Resets sleep timer on all interactions to prevent accidental sleep
 * @see PopupManager, encoderFocusAdd(), safeDeletePopup()
 */
static void showCoinsPopup() {
  if (favoriteCoinCount == 0) {
    Serial.println("[Coins Popup] No favorite coins to display");
    return;
  }
  
  // Register popup with manager
  PopupManager::registerPopup(PopupManager::COINS);
  
  // Create dark overlay background
  coins_popup_bg = lv_obj_create(lv_layer_top());
  lv_obj_set_size(coins_popup_bg, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_bg_color(coins_popup_bg, lv_color_black(), 0);
  lv_obj_set_style_bg_opa(coins_popup_bg, LV_OPA_50, 0);
  lv_obj_set_style_border_width(coins_popup_bg, 0, 0);
  lv_obj_clear_flag(coins_popup_bg, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_add_flag(coins_popup_bg, LV_OBJ_FLAG_CLICKABLE);
  
  // Close popup on background click
  lv_obj_add_event_cb(coins_popup_bg, [](lv_event_t *e) {
    if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg)) {
      // Reset encoder focus
      encoderFocusReset();
      
      lv_obj_del(coins_popup_bg);
      coins_popup_bg = nullptr;
      coins_popup = nullptr;
      coins_popup_list = nullptr;
    }
  }, LV_EVENT_CLICKED, NULL);
  
  // Create popup panel (same size and style as other popups)
  coins_popup = lv_obj_create(coins_popup_bg);
  lv_obj_set_size(coins_popup, 450, 480);  // Reduced by 20px (10px top + 10px bottom)
  lv_obj_align(coins_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(coins_popup, lv_color_make(10, 10, 10), 0);  // Dark gray (same as control panel)
  lv_obj_set_style_radius(coins_popup, 20, 0);  // Rounded corners (20px radius)
  lv_obj_set_style_border_width(coins_popup, 0, 0);
  lv_obj_set_style_pad_all(coins_popup, 20, 0);  // Add padding like alerts popup
  lv_obj_set_scrollbar_mode(coins_popup, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(coins_popup, LV_OBJ_FLAG_SCROLLABLE);
  
  // Title label (moved down slightly)
  lv_obj_t *title = lv_label_create(coins_popup);
  lv_label_set_text(title, "Coins");
  lv_obj_set_style_text_font(title, &poppins_medium_20, 0);  // Same font as alerts popup
  lv_obj_set_style_text_color(title, COLOR_WHITE, 0);
  lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 20);  // Moved down from 25px to 20px (accounting for shorter popup)
  
  // Scrollable coin list (adjusted for new popup size with padding)
  coins_popup_list = lv_obj_create(coins_popup);
  lv_obj_set_size(coins_popup_list, 410, 320);  // Reduced height by 10px (from 330 to 320)
  lv_obj_align(coins_popup_list, LV_ALIGN_TOP_MID, 0, 60);  // Position below title (adjusted from 65)
  lv_obj_set_style_bg_color(coins_popup_list, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_border_width(coins_popup_list, 0, 0);
  lv_obj_set_style_pad_all(coins_popup_list, 0, 0);
  lv_obj_set_scrollbar_mode(coins_popup_list, LV_SCROLLBAR_MODE_AUTO);
  lv_obj_set_scroll_dir(coins_popup_list, LV_DIR_VER);
  
  // Create coin buttons (same layout as favorites list)
  const int button_width = 390;
  const int button_height = 70;  // Same as favorites
  const int v_spacing = 12;      // Same as favorites
  const int start_x = 10;
  const int start_y = 10;
  
  for (int i = 0; i < favoriteCoinCount; i++) {
    lv_obj_t *btn = lv_btn_create(coins_popup_list);
    lv_obj_set_size(btn, button_width, button_height);
    
    int y = start_y + (i * (button_height + v_spacing));
    lv_obj_set_pos(btn, start_x, y);
    
    // Same styling as favorites page
    lv_obj_set_style_bg_color(btn, lv_color_make(10, 10, 10), 0);  // Same dark gray
    lv_obj_set_style_radius(btn, BUTTON_RADIUS, 0);
    lv_obj_set_style_shadow_width(btn, 0, 0);
    lv_obj_set_style_border_width(btn, 0, 0);
    
    // Store coin symbol in user data
    lv_obj_set_user_data(btn, (void*)(intptr_t)i);
    
    // Click handler to navigate to this coin
    lv_obj_add_event_cb(btn, [](lv_event_t *e) {
      lv_obj_t *btn = lv_event_get_target(e);
      int idx = (int)(intptr_t)lv_obj_get_user_data(btn);
      
      if (idx >= 0 && idx < favoriteCoinCount) {
        // CRITICAL: Reset sleep timer to prevent accidental sleep mode
        extern unsigned long encoderPressStart;
        encoderPressStart = 0;
        Serial.println("[Coins Popup] Reset sleep timer to prevent sleep mode");
        
        // Find the pair index for this coin
        String targetSymbol = favoriteCoinSymbols[idx];
        int targetPairIdx = -1;
        
        for (int p = 0; p < active_pair_count; p++) {
          if (pairs[p].symbol == targetSymbol) {
            targetPairIdx = p;
            break;
          }
        }
        
        if (targetPairIdx >= 0) {
          Serial.printf("[Coins Popup] Jumping to %s (pair index %d)\n", targetSymbol.c_str(), targetPairIdx);
          
          // Reset encoder focus
          encoderFocusReset();
          
          // Close the popup
          if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg)) {
            lv_obj_del(coins_popup_bg);
            coins_popup_bg = nullptr;
            coins_popup = nullptr;
            coins_popup_list = nullptr;
          }
          
          // Jump to the selected coin
          current_pair = targetPairIdx;
          
          // Navigate to crypto display screen if not already there
          if (lv_scr_act() != crypto_display_screen) {
            lv_scr_load(crypto_display_screen);
          }
          
          // Update the coin name label at the top
          if (pair_label && lv_obj_is_valid(pair_label)) {
            lv_label_set_text(pair_label, pairs[current_pair].display_name.c_str());
            if (show_coin_name) {
              lv_obj_clear_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
            }
          }
          
          // Update the price label
          if (price_label && lv_obj_is_valid(price_label)) {
            char price_buf[30];
            formatPriceWithCommas(pairs[current_pair].last_price, price_buf, sizeof(price_buf), current_pair);
            lv_label_set_text_fmt(price_label, "$%s", price_buf);
          }
          
          // Update the display
          fetchHistory(currentTFStr);
          startKlineWS(currentTFStr);
          
          // Update coin dots
          updateCoinDots();
          
          // Refresh alert bell icon (in case this coin has alerts)
          refreshAlertBellIcon();
        }
      }
    }, LV_EVENT_CLICKED, NULL);
    
    // Extract base coin name (remove USDT suffix)
    String baseCoin = favoriteCoinSymbols[i];
    if (baseCoin.endsWith("USDT")) {
      baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
    }
    
    // Find the pair index to get price data (same as favorites page)
    int pairIdx = -1;
    for (int p = 0; p < active_pair_count; p++) {
      if (pairs[p].symbol == favoriteCoinSymbols[i]) {
        pairIdx = p;
        break;
      }
    }
    
    // Coin name (left-aligned) - Layout: coinname left, price middle, % right
    lv_obj_t *name_label = lv_label_create(btn);
    lv_label_set_text(name_label, baseCoin.c_str());
    lv_obj_set_style_text_font(name_label, &poppins_medium_20, 0);
    lv_obj_align(name_label, LV_ALIGN_LEFT_MID, 25, 0);  // Left-aligned
    
    // Price and daily % layout: Price (center), % (right) - color based on daily change
    if (pairIdx >= 0 && pairs[pairIdx].last_price > 0.0f) {
      // Get formatted price
      char price_buf[30];
      formatPriceWithCommas(pairs[pairIdx].last_price, price_buf, sizeof(price_buf), pairIdx);
      
      // Get daily % change
      float daily_change_percent = pairs[pairIdx].daily_change_percent;
      
      // Color based on daily change (green for positive, red for negative, white for zero)
      lv_color_t text_color = COLOR_WHITE;
      if (daily_change_percent > 0.0f) {
        text_color = COLOR_GREEN;
      } else if (daily_change_percent < 0.0f) {
        text_color = COLOR_RED;
      }
      
      // Price (center) - Middle position
      char price_text[40];
      snprintf(price_text, sizeof(price_text), "$%s", price_buf);
      
      lv_obj_t *price_label = lv_label_create(btn);
      lv_label_set_text(price_label, price_text);
      lv_obj_set_style_text_font(price_label, &poppins_medium_20, 0);
      lv_obj_align(price_label, LV_ALIGN_CENTER, 0, 0);  // Centered (middle)
      lv_obj_set_style_text_color(price_label, text_color, 0);
      
      // Daily % (right) - Right-aligned
      if (daily_change_percent != 0.0f) {
        char percent_text[20];
        char sign = (daily_change_percent > 0) ? '+' : '-';
        snprintf(percent_text, sizeof(percent_text), "%c%.2f%%", sign, fabs(daily_change_percent));
        
        lv_obj_t *percent_label = lv_label_create(btn);
        lv_label_set_text(percent_label, percent_text);
        lv_obj_set_style_text_font(percent_label, &poppins_medium_20, 0);
        lv_obj_align(percent_label, LV_ALIGN_RIGHT_MID, -25, 0);  // Right-aligned
        lv_obj_set_style_text_color(percent_label, text_color, 0);
      }
      
      // Coin name color
      lv_obj_set_style_text_color(name_label, text_color, 0);
    } else {
      // No price data - show "Loading price.." in red
      lv_obj_t *loading_label = lv_label_create(btn);
      lv_label_set_text(loading_label, "Loading price..");
      lv_obj_set_style_text_font(loading_label, &poppins_medium_20, 0);
      lv_obj_align(loading_label, LV_ALIGN_CENTER, 0, 0);  // Centered (middle)
      lv_obj_set_style_text_color(loading_label, COLOR_RED, 0);
      
      // Coin name in white
      lv_obj_set_style_text_color(name_label, COLOR_WHITE, 0);
    }
  }
  
  // Back button at the bottom (moved up)
  lv_obj_t *back_btn = lv_btn_create(coins_popup);
  lv_obj_set_size(back_btn, 120, 50);
  lv_obj_align(back_btn, LV_ALIGN_BOTTOM_MID, 0, -10);  // Moved up from -15 to -10
  lv_obj_set_style_bg_color(back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(back_btn, [](lv_event_t *e) {
    if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg)) {
      // CRITICAL: Reset sleep timer to prevent accidental sleep mode
      extern unsigned long encoderPressStart;
      encoderPressStart = 0;
      Serial.println("[Coins Popup] Back button - reset sleep timer");
      
      // Reset encoder focus
      encoderFocusReset();
      
      lv_obj_del(coins_popup_bg);
      coins_popup_bg = nullptr;
      coins_popup = nullptr;
      coins_popup_list = nullptr;
    }
  }, LV_EVENT_CLICKED, NULL);
  
  lv_obj_t *back_label = lv_label_create(back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_center(back_label);
  
  // Ensure text stays black even when highlighted (override highlighting for back button)
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, LV_PART_MAIN | LV_STATE_DEFAULT);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, LV_PART_MAIN | LV_STATE_FOCUSED);
  
  Serial.printf("[Coins Popup] Showing %d favorite coins\n", favoriteCoinCount);
  
  // Set up encoder focus for rotary wheel navigation
  // We need to re-collect the buttons since they were created in a loop
  encoderFocusBegin(coins_popup);
  
  // Add all coin buttons to encoder focus (they're children of coins_popup_list)
  uint32_t child_count = lv_obj_get_child_cnt(coins_popup_list);
  for (uint32_t j = 0; j < child_count; j++) {
    lv_obj_t *coin_btn = lv_obj_get_child(coins_popup_list, j);
    if (coin_btn && lv_obj_is_valid(coin_btn)) {
      // Get the first label child (coin name label)
      lv_obj_t *coin_label = lv_obj_get_child(coin_btn, 0);
      if (coin_label && lv_obj_is_valid(coin_label)) {
        encoderFocusAdd(coin_btn, coin_label);
      }
    }
  }
  
  // Add back button to encoder focus
  encoderFocusAdd(back_btn, back_label);
  
  // Commit encoder focus (highlight first item)
  encoderFocusCommit(0);
  
  Serial.println("[Coins Popup] Encoder focus enabled for rotary navigation");
}

/* ===== Crypto Loading Logo (Overlay for Pair Changes) ===== */
static void showCryptoLoadingLogo(int pairIndex) {
  // Clean up existing logo if any
  if (crypto_loading_logo_overlay && lv_obj_is_valid(crypto_loading_logo_overlay)) {
    lv_obj_del(crypto_loading_logo_overlay);
    crypto_loading_logo_overlay = nullptr;
  }
  
  // Create the loading logo container
  crypto_loading_logo_overlay = lv_obj_create(lv_layer_top());
  lv_obj_set_size(crypto_loading_logo_overlay, 200, 200);
  lv_obj_align(crypto_loading_logo_overlay, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_opa(crypto_loading_logo_overlay, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(crypto_loading_logo_overlay, 0, 0);
  lv_obj_set_style_pad_all(crypto_loading_logo_overlay, 0, 0);
  
  // Show loading text for the coin
  lv_obj_t *loading_label = lv_label_create(crypto_loading_logo_overlay);
  String coinName = String(pairs[pairIndex].display_name);
  lv_label_set_text_fmt(loading_label, "Loading %s...", coinName.c_str());
  lv_obj_set_style_text_color(loading_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_font(loading_label, &poppins_medium_20, 0);
  lv_obj_center(loading_label);
  
  // Start with full opacity
  lv_obj_set_style_opa(crypto_loading_logo_overlay, LV_OPA_COVER, 0);
  
  // Show coin indicator dots when loading logo appears
  showCoinDots();
  
  // Start timer to hide logo after 1.5 seconds
  if (crypto_loading_timer) {
    lv_timer_del(crypto_loading_timer);
  }
  crypto_loading_timer = lv_timer_create(crypto_loading_timer_cb, 1500, NULL);
  lv_timer_set_repeat_count(crypto_loading_timer, 1);
}
static void hideCryptoLoadingLogo() {
  if (!crypto_loading_logo_overlay || !lv_obj_is_valid(crypto_loading_logo_overlay)) return;
  
  // Show pair_label when loading is complete (respect customization setting)
  if (pair_label && lv_obj_is_valid(pair_label)) {
    lv_label_set_text(pair_label, pairs[current_pair].display_name.c_str());
    if (show_coin_name) {
      lv_obj_clear_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
    }
  }
  
  if (show_coin_info) {
    showCoinInfoIcon();
  } else {
    hideCoinInfoIcon();
  }
  refreshAlertBellIcon();
  
  // Start fade out animation
  lv_anim_init(&crypto_loading_fade_anim);
  lv_anim_set_var(&crypto_loading_fade_anim, crypto_loading_logo_overlay);
  lv_anim_set_exec_cb(&crypto_loading_fade_anim, crypto_loading_fade_anim_cb);
  lv_anim_set_values(&crypto_loading_fade_anim, LV_OPA_COVER, LV_OPA_TRANSP);
  lv_anim_set_time(&crypto_loading_fade_anim, 300);
  lv_anim_set_ready_cb(&crypto_loading_fade_anim, [](lv_anim_t *a) {
    if (crypto_loading_logo_overlay && lv_obj_is_valid(crypto_loading_logo_overlay)) {
      lv_obj_del(crypto_loading_logo_overlay);
      crypto_loading_logo_overlay = nullptr;
    }
  });
  lv_anim_start(&crypto_loading_fade_anim);
}

static void crypto_loading_fade_anim_cb(void *var, int32_t v) {
  lv_obj_t *obj = (lv_obj_t*)var;
  if (obj && lv_obj_is_valid(obj)) {
    lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
  }
}

static void crypto_loading_timer_cb(lv_timer_t *timer) {
  hideCryptoLoadingLogo();
  if (crypto_loading_timer) {
    lv_timer_del(crypto_loading_timer);
    crypto_loading_timer = nullptr;
  }
}

static void startCryptoDisplay() {
  // Connected screen (crypto display - coin screen with live prices)
  crypto_display_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(crypto_display_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(crypto_display_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(crypto_display_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(crypto_display_screen);

  // Add swipe-down gesture detection to show control panel
  // Removed auto-show; drag is handled by top-edge grabber


  // Swipe container (only enable if more than one pair selected)
  swipe_container = lv_obj_create(crypto_display_screen);
  lv_obj_set_size(swipe_container, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_bg_opa(swipe_container, LV_OPA_TRANSP, 0);
  lv_obj_set_style_border_width(swipe_container, 0, 0);
  lv_obj_set_style_pad_all(swipe_container, 0, 0);
  lv_obj_set_scrollbar_mode(swipe_container, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(swipe_container, LV_OBJ_FLAG_SCROLLABLE);
  lv_obj_center(swipe_container);

  // Only add swipe events if multiple pairs are selected
  if (selected_pair_count > 1) {
    lv_obj_add_event_cb(swipe_container, swipe_event_cb, LV_EVENT_PRESSED, NULL);
    lv_obj_add_event_cb(swipe_container, swipe_event_cb, LV_EVENT_PRESSING, NULL);
    lv_obj_add_event_cb(swipe_container, swipe_event_cb, LV_EVENT_RELEASED, NULL);
  }

  static lv_obj_t *crypto_event_screen = nullptr;
  if (crypto_event_screen != crypto_display_screen) {
    lv_obj_add_event_cb(crypto_display_screen, [](lv_event_t *e) {
      if (lv_event_get_code(e) == LV_EVENT_SCREEN_LOADED) {
        if (show_coin_info) {
          showCoinInfoIcon();
        } else {
          hideCoinInfoIcon();
        }
        refreshAlertBellIcon();
      }
    }, LV_EVENT_ALL, NULL);
    crypto_event_screen = crypto_display_screen;
  }

  // Clock (top-left, parent = swipe_container) - MOVES WITH SWIPE
  clock_label = lv_label_create(swipe_container);
  lv_label_set_text(clock_label, "--:--");
  lv_obj_align(clock_label, LV_ALIGN_TOP_LEFT, 5, 10);
  lv_obj_set_style_text_color(clock_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_font(clock_label, &poppins_medium_20, 0);

  // Pair label (top-center)
  pair_label = lv_label_create(swipe_container);
  lv_label_set_text(pair_label, pairs[current_pair].display_name.c_str());
  lv_obj_align(pair_label, LV_ALIGN_TOP_MID, 0, 10);
  lv_obj_set_style_text_color(pair_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_font(pair_label, &poppins_medium_20, 0);

  // Price
  price_label = lv_label_create(swipe_container);
  static char default_buf[20];
  getDefaultPriceText(current_pair, default_buf, sizeof(default_buf));
  lv_label_set_text(price_label, default_buf);
  lv_obj_align(price_label, LV_ALIGN_CENTER, 0, -15);
  lv_obj_set_style_text_font(price_label, &poppins_semibold_64, 0);
  lv_obj_set_style_text_color(price_label, COLOR_WHITE, 0);

  // TF + Candles + Wi-Fi bars + Coin Dots
  setupTFSelector(swipe_container);
  setupCandles(swipe_container);
  createCoinDots(crypto_display_screen);
  createWiFiSignal(swipe_container); // WiFi now moves with swipe
  
  // Add candle inspection events to swipe_container so user can touch anywhere
  lv_obj_add_flag(swipe_container, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_add_event_cb(swipe_container, candle_inspection_event_cb, LV_EVENT_PRESSED, NULL);
  lv_obj_add_event_cb(swipe_container, candle_inspection_event_cb, LV_EVENT_PRESSING, NULL);
  lv_obj_add_event_cb(swipe_container, candle_inspection_event_cb, LV_EVENT_RELEASED, NULL);

  // Show CoinInfo icon on live price page if enabled
  if (show_coin_info) {
    showCoinInfoIcon();
  } else {
    hideCoinInfoIcon();
  }
  
  refreshAlertBellIcon();
  
  // Apply customization visibility settings
  if (!show_clock && clock_label && lv_obj_is_valid(clock_label)) {
    lv_obj_add_flag(clock_label, LV_OBJ_FLAG_HIDDEN);
  }
  if (!show_wifi) {
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      lv_obj_add_flag(wifi_signal, LV_OBJ_FLAG_HIDDEN);
    }
    if (wifi_signal_bg && lv_obj_is_valid(wifi_signal_bg)) {
      lv_obj_add_flag(wifi_signal_bg, LV_OBJ_FLAG_HIDDEN);
    }
  }
  if (!show_alert_bell && alert_bell_icon && lv_obj_is_valid(alert_bell_icon)) {
    lv_obj_add_flag(alert_bell_icon, LV_OBJ_FLAG_HIDDEN);
  }
  if (!show_coin_name && pair_label && lv_obj_is_valid(pair_label)) {
    lv_obj_add_flag(pair_label, LV_OBJ_FLAG_HIDDEN);
  }
  if (!show_timeframe && tf_btn && lv_obj_is_valid(tf_btn)) {
    lv_obj_add_flag(tf_btn, LV_OBJ_FLAG_HIDDEN);
  }
  if (!show_candles && candle_canvas && lv_obj_is_valid(candle_canvas)) {
    lv_obj_add_flag(candle_canvas, LV_OBJ_FLAG_HIDDEN);
  }
  if (!show_price && price_label && lv_obj_is_valid(price_label)) {
    lv_obj_add_flag(price_label, LV_OBJ_FLAG_HIDDEN);
  }

  // Initial fade-in
  if (swipe_container && lv_obj_is_valid(swipe_container)) {
    lv_obj_set_style_opa(swipe_container, 0, 0);
    lv_anim_t initial_fade;
    lv_anim_init(&initial_fade);
    lv_anim_set_var(&initial_fade, swipe_container);
    lv_anim_set_exec_cb(&initial_fade, [](void *var, int32_t v) {
      lv_obj_t *obj = (lv_obj_t*)var;
      if (obj && lv_obj_is_valid(obj)) lv_obj_set_style_opa(obj, (lv_opa_t)v, 0);
    });
    lv_anim_set_values(&initial_fade, 0, 255);
    lv_anim_set_time(&initial_fade, 500);
    lv_anim_start(&initial_fade);
  }

  // Show coin indicator dots immediately on initial load
  showCoinDots();

  // Time + data
  syncTimeWithAPI();
  fetchHistory(currentTFStr);   // triggers animated reveal
  startKlineWS(currentTFStr);
}

/* ===== Pair Display Refresh ===== */
static void updatePairDisplay() {
  if (pair_label && lv_obj_is_valid(pair_label)) {
    lv_label_set_text(pair_label, pairs[current_pair].display_name.c_str());
    lv_obj_align(pair_label, LV_ALIGN_TOP_MID, 0, 10);
  }
  if (show_coin_info) {
    showCoinInfoIcon();
  } else {
    hideCoinInfoIcon();
  }
  refreshAlertBellIcon();
  if (price_label && lv_obj_is_valid(price_label)) {
    static char buf[20];
    if (pairs[current_pair].last_price > 0.0f) {
      formatPriceWithCommas(pairs[current_pair].last_price, buf, sizeof(buf), current_pair);
      lv_label_set_text(price_label, buf);
    } else {
      static char default_buf[20];
      getDefaultPriceText(current_pair, default_buf, sizeof(default_buf));
      lv_label_set_text(price_label, default_buf);
    }
  }
  // Do NOT fade container here; just refresh candles/data if you still call this on pair switch:
  drawCandles();
  fetchHistory(currentTFStr);
  startKlineWS(currentTFStr);
  lv_obj_invalidate(candle_canvas);
  lv_obj_invalidate(swipe_container);
  lv_refr_now(NULL);
}

/* ===== WiFi Connecting Screen ===== */
static void createWiFiConnectingScreen() {
  // Remember the screen to return to after connecting
  wifi_prev_screen = lv_scr_act();
  // Create full screen black background
  wifi_connecting_screen = lv_obj_create(NULL);
  lv_obj_set_size(wifi_connecting_screen, 600, 400);
  lv_obj_set_style_bg_color(wifi_connecting_screen, COLOR_BLACK, 0);
  lv_obj_set_style_border_width(wifi_connecting_screen, 0, 0);
  lv_obj_set_style_radius(wifi_connecting_screen, 0, 0);
  lv_obj_set_scrollbar_mode(wifi_connecting_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(wifi_connecting_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(wifi_connecting_screen);
  
  // Create static "Connecting to Wi-Fi" text
  lv_obj_t *static_text = lv_label_create(wifi_connecting_screen);
  lv_label_set_text(static_text, "Connecting to Wi-Fi");
  lv_obj_set_style_text_font(static_text, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(static_text, COLOR_GREEN, 0);
  lv_obj_align(static_text, LV_ALIGN_CENTER, 0, 0);
  
  // Create separate animated dots label
  wifi_connecting_label = lv_label_create(wifi_connecting_screen);
  lv_label_set_text(wifi_connecting_label, "...");
  lv_obj_set_style_text_font(wifi_connecting_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(wifi_connecting_label, COLOR_GREEN, 0);
  lv_obj_align(wifi_connecting_label, LV_ALIGN_CENTER, 0, 30); // Position below main text
  
  // Start dots animation timer
  wifi_connecting_dots = 0;
  if (wifi_connecting_timer) {
    lv_timer_del(wifi_connecting_timer);
  }
  wifi_connecting_timer = lv_timer_create(wifi_connecting_timer_cb, 500, NULL);
}

static void wifi_connecting_timer_cb(lv_timer_t *t) {
  if (!wifi_connecting_label || !lv_obj_is_valid(wifi_connecting_label)) {
    lv_timer_del(t);
    wifi_connecting_timer = nullptr;
    return;
  }
  
  wifi_connecting_dots = (wifi_connecting_dots + 1) % 4; // 0, 1, 2, 3
  
  String dots = "";
  for (int i = 0; i < wifi_connecting_dots; i++) {
    dots += ".";
  }
  
  lv_label_set_text(wifi_connecting_label, dots.c_str());
}

static void hideWiFiConnectingScreen() {
  // Stop timer first
  if (wifi_connecting_timer) {
    lv_timer_del(wifi_connecting_timer);
    wifi_connecting_timer = nullptr;
  }
  
  // Ensure we are not deleting the currently active screen
  if (wifi_prev_screen && lv_obj_is_valid(wifi_prev_screen)) {
    lv_scr_load(wifi_prev_screen);
  }
  
  // Clean up screen
  if (wifi_connecting_screen && lv_obj_is_valid(wifi_connecting_screen)) {
    lv_obj_del(wifi_connecting_screen);
    wifi_connecting_screen = nullptr;
  }
  wifi_prev_screen = nullptr;
  
  // Reset label pointer
  wifi_connecting_label = nullptr;
  
  // Force LVGL to process the deletion
  lv_timer_handler();
}

// ===== OTA UPDATE PAGE =====
static void createOTAUpdatePage() {
  ota_update_screen = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(ota_update_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(ota_update_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(ota_update_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(ota_update_screen);

  // Logo
  lv_obj_t *logo = lv_img_create(ota_update_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(logo, &LumenLogo);
  lv_img_set_zoom(logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(logo, LV_ALIGN_TOP_MID, 0, 0);

  // Title
  ota_update_label = lv_label_create(ota_update_screen);
  lv_label_set_text(ota_update_label, "Software Update");
  lv_obj_set_style_text_font(ota_update_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(ota_update_label, COLOR_WHITE, 0);
  lv_obj_align(ota_update_label, LV_ALIGN_TOP_MID, 0, 70);

  // Current version
  ota_version_label = lv_label_create(ota_update_screen);
  String version_text = "Current Version: " + String(FIRMWARE_VERSION);
  lv_label_set_text(ota_version_label, version_text.c_str());
  lv_obj_set_style_text_font(ota_version_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(ota_version_label, COLOR_GRAY, 0);
  lv_obj_align(ota_version_label, LV_ALIGN_TOP_MID, 0, 160);

  // Status label (moved down 25px)
  ota_status_label = lv_label_create(ota_update_screen);
  lv_label_set_text(ota_status_label, ""); // Empty initially
  lv_obj_set_style_text_font(ota_status_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(ota_status_label, COLOR_WHITE, 0);
  lv_obj_align(ota_status_label, LV_ALIGN_CENTER, 0, -10);

  // Progress bar (initially hidden)
  ota_progress_bar = lv_bar_create(ota_update_screen);
  lv_obj_set_size(ota_progress_bar, 400, 20);
  lv_obj_align(ota_progress_bar, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(ota_progress_bar, lv_color_make(40, 40, 40), 0);
  lv_obj_set_style_bg_opa(ota_progress_bar, LV_OPA_COVER, 0);
  lv_obj_set_style_bg_color(ota_progress_bar, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_add_flag(ota_progress_bar, LV_OBJ_FLAG_HIDDEN);

  // Single button that changes between "Check for update" and "Update Now"
  ota_check_btn = lv_btn_create(ota_update_screen);
  lv_obj_set_size(ota_check_btn, 200, 50);
  lv_obj_align(ota_check_btn, LV_ALIGN_BOTTOM_RIGHT, -20, -20);
  lv_obj_set_style_bg_color(ota_check_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(ota_check_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(ota_check_btn, ota_check_btn_cb, LV_EVENT_CLICKED, NULL);

  ota_check_btn_label = lv_label_create(ota_check_btn);
  lv_label_set_text(ota_check_btn_label, "Check for update");
  lv_obj_set_style_text_font(ota_check_btn_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(ota_check_btn_label, COLOR_BLACK, 0);
  lv_obj_center(ota_check_btn_label);

  // Back button
  ota_back_btn = lv_btn_create(ota_update_screen);
  lv_obj_set_size(ota_back_btn, 120, 50);
  lv_obj_align(ota_back_btn, LV_ALIGN_BOTTOM_LEFT, 20, -20);
  lv_obj_set_style_bg_color(ota_back_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(ota_back_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(ota_back_btn, ota_back_btn_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *back_label = lv_label_create(ota_back_btn);
  lv_label_set_text(back_label, "Back");
  lv_obj_set_style_text_font(back_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(back_label, COLOR_BLACK, 0);
  lv_obj_center(back_label);
}

// ===== OTA UPDATE CALLBACKS =====
static void ota_settings_btn_cb(lv_event_t * e) {
  createOTAUpdatePage();
  // Add WiFi signal if connected
  if (WiFi.status() == WL_CONNECTED) {
    createWiFiSignal(ota_update_screen);
  }

  showCoinInfoIcon();
}

static void ota_back_btn_cb(lv_event_t * e) {
  createAboutPage();
  // WiFi signal should already be present, don't recreate
}

static void ota_check_btn_cb(lv_event_t * e) {
  if (WiFi.status() != WL_CONNECTED) {
    showOTAStatus("Please connect to Wi-Fi");
    // Fade out the status after 3 seconds
    if (ota_status_label && lv_obj_is_valid(ota_status_label)) {
      lv_obj_set_style_opa(ota_status_label, LV_OPA_COVER, 0);
      lv_anim_t fade;
      lv_anim_init(&fade);
      lv_anim_set_var(&fade, ota_status_label);
      lv_anim_set_exec_cb(&fade, [](void *var, int32_t val) {
        lv_obj_t *obj = (lv_obj_t*)var;
        if (obj && lv_obj_is_valid(obj)) lv_obj_set_style_opa(obj, val, 0);
      });
      lv_anim_set_values(&fade, LV_OPA_COVER, LV_OPA_TRANSP);
      lv_anim_set_time(&fade, 500);
      lv_anim_set_delay(&fade, 3000);
      lv_anim_start(&fade);
    }
    return;
  }
  
  showOTAStatus("Checking for updates...");
  checkForUpdates();
}

static void ota_update_btn_cb(lv_event_t * e) {
  if (WiFi.status() != WL_CONNECTED) {
    showOTAStatus("Please connect to Wi-Fi");
    // Fade out after 3 seconds
    if (ota_status_label && lv_obj_is_valid(ota_status_label)) {
      lv_obj_set_style_opa(ota_status_label, LV_OPA_COVER, 0);
      lv_anim_t fade;
      lv_anim_init(&fade);
      lv_anim_set_var(&fade, ota_status_label);
      lv_anim_set_exec_cb(&fade, [](void *var, int32_t val) {
        lv_obj_t *obj = (lv_obj_t*)var;
        if (obj && lv_obj_is_valid(obj)) lv_obj_set_style_opa(obj, val, 0);
      });
      lv_anim_set_values(&fade, LV_OPA_COVER, LV_OPA_TRANSP);
      lv_anim_set_time(&fade, 500);
      lv_anim_set_delay(&fade, 3000);
      lv_anim_start(&fade);
    }
    return;
  }
  
  showOTAWarningPopup();
}

// ===== OTA UPDATE LOGIC =====
static void showOTAStatus(const String& status) {
  ota_update_status = status;
  if (ota_status_label && lv_obj_is_valid(ota_status_label)) {
    lv_label_set_text(ota_status_label, status.c_str());
    // Colorize statuses
    if (status.indexOf("Update available") >= 0) {
      lv_obj_set_style_text_color(ota_status_label, COLOR_GREEN, 0);
    } else if (status.indexOf("Please connect to Wi-Fi") >= 0) {
      lv_obj_set_style_text_color(ota_status_label, COLOR_RED, 0);
    } else {
      lv_obj_set_style_text_color(ota_status_label, COLOR_WHITE, 0);
    }
  }
  Serial.println("OTA Status: " + status);
}

static void updateOTAProgress(int progress) {
  // Use the modern progress screen if it exists
  if (ota_progress_screen && lv_obj_is_valid(ota_progress_screen)) {
    updateOTAProgressModern(progress);
  } else {
    // Fallback to old progress bar
    if (ota_progress_bar && lv_obj_is_valid(ota_progress_bar)) {
      lv_bar_set_value(ota_progress_bar, progress, LV_ANIM_ON);
    }
    if (ota_status_label && lv_obj_is_valid(ota_status_label)) {
      String status = "Updating... " + String(progress) + "%";
      lv_label_set_text(ota_status_label, status.c_str());
    }
  }
}

static void otaUpdateProgressCallback(size_t current, size_t total) {
  int progress = (current * 100) / total;
  updateOTAProgress(progress);
  lv_timer_handler(); // Update display during download
}
static void checkForUpdates() {
  if (WiFi.status() != WL_CONNECTED) {
    showOTAStatus("Wi-Fi not connected");
    return;
  }

  HTTPClient http;
  http.begin(VERSION_CHECK_URL);
  http.setTimeout(10000); // 10 second timeout
  
  int httpCode = http.GET();
  
  if (httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    
    // Parse JSON response
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, payload);
    
    if (!error) {
      String server_version = doc["version"];
      String download_url = doc["url"];
      
      if (server_version != FIRMWARE_VERSION) {
        latest_version = server_version;
        ota_update_available = true;
        
        // Change button to "Update Now" mode
        if (ota_check_btn && lv_obj_is_valid(ota_check_btn)) {
          // Change text
          if (ota_check_btn_label && lv_obj_is_valid(ota_check_btn_label)) {
            lv_label_set_text(ota_check_btn_label, "Update Now");
          }
          // Keep button white but tint text to indicate action
          lv_obj_set_style_bg_color(ota_check_btn, COLOR_WHITE, 0);
          if (ota_check_btn_label && lv_obj_is_valid(ota_check_btn_label)) {
            lv_obj_set_style_text_color(ota_check_btn_label, COLOR_GREEN, 0);
          }
          // Remove old callback and add update callback
          lv_obj_remove_event_cb(ota_check_btn, ota_check_btn_cb);
          lv_obj_add_event_cb(ota_check_btn, ota_update_btn_cb, LV_EVENT_CLICKED, NULL);
        }
        
        showOTAStatus("Update available: v" + server_version);
      } else {
        ota_update_available = false;
        
        // Reset button to "Check for update" mode
        if (ota_check_btn && lv_obj_is_valid(ota_check_btn)) {
          if (ota_check_btn_label && lv_obj_is_valid(ota_check_btn_label)) {
            lv_label_set_text(ota_check_btn_label, "Check for update");
          }
          lv_obj_set_style_bg_color(ota_check_btn, COLOR_WHITE, 0);
          if (ota_check_btn_label && lv_obj_is_valid(ota_check_btn_label)) {
            lv_obj_set_style_text_color(ota_check_btn_label, COLOR_BLACK, 0);
          }
          lv_obj_remove_event_cb(ota_check_btn, ota_update_btn_cb);
          lv_obj_add_event_cb(ota_check_btn, ota_check_btn_cb, LV_EVENT_CLICKED, NULL);
        }
        
        showOTAStatus("You have the latest version");
      }
    } else {
      showOTAStatus("Failed to parse version info");
    }
  } else {
    showOTAStatus("Failed to check for updates");
  }
  
  http.end();
  last_ota_check = millis();
}

static void performOTAUpdate() {
  if (!ota_update_available) {
    showOTAStatus("No update available");
    return;
  }
  // Kick off the smooth fake progress animation; install afterwards
  startFakeProgressThenInstall();
}

// ===== OTA WARNING POPUP =====
static void showOTAWarningPopup() {
  // Create warning popup (bigger) and non-scrollable
  ota_warning_popup = lv_obj_create(ota_update_screen);
  lv_obj_set_size(ota_warning_popup, 520, 380); // Made bigger
  lv_obj_align(ota_warning_popup, LV_ALIGN_CENTER, 0, 0);
  lv_obj_set_style_bg_color(ota_warning_popup, lv_color_make(10, 10, 10), 0);
  lv_obj_set_style_radius(ota_warning_popup, 20, 0);
  lv_obj_set_style_border_width(ota_warning_popup, 0, 0);
  lv_obj_set_scrollbar_mode(ota_warning_popup, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(ota_warning_popup, LV_OBJ_FLAG_SCROLLABLE);

  // Warning text
  ota_warning_label = lv_label_create(ota_warning_popup);
  lv_label_set_text(ota_warning_label, "WARNING\n\n"
                                      "Do not power off or unplug the device during the update.\n\n"
                                      "Interrupting the process may damage the device.\n\n"
                                      "The unit will automatically restart when completed.");
  lv_obj_set_style_text_font(ota_warning_label, &poppins_light_20, 0); // Keep font size
  // Remove transform zoom (caused invisibility on some targets). Use wrap & width.
  lv_obj_set_width(ota_warning_label, 480); // Fit inside popup with margins
  lv_label_set_long_mode(ota_warning_label, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_color(ota_warning_label, COLOR_WHITE, 0);
  lv_obj_set_style_text_align(ota_warning_label, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_align(ota_warning_label, LV_ALIGN_CENTER, 0, -40); // Move up 10px

  // Cancel button
  ota_warning_cancel_btn = lv_btn_create(ota_warning_popup);
  lv_obj_set_size(ota_warning_cancel_btn, 150, 50);
  lv_obj_align(ota_warning_cancel_btn, LV_ALIGN_BOTTOM_LEFT, 50, -20); // 50 pixels to the left
  lv_obj_set_style_bg_color(ota_warning_cancel_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(ota_warning_cancel_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(ota_warning_cancel_btn, ota_warning_cancel_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *cancel_label = lv_label_create(ota_warning_cancel_btn);
  lv_label_set_text(cancel_label, "Cancel");
  lv_obj_set_style_text_font(cancel_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(cancel_label, COLOR_BLACK, 0);
  lv_obj_center(cancel_label);

  // Continue button
  ota_warning_continue_btn = lv_btn_create(ota_warning_popup);
  lv_obj_set_size(ota_warning_continue_btn, 150, 50);
  lv_obj_align(ota_warning_continue_btn, LV_ALIGN_BOTTOM_RIGHT, -50, -20); // 50 pixels to the right
  lv_obj_set_style_bg_color(ota_warning_continue_btn, COLOR_WHITE, 0);
  lv_obj_set_style_radius(ota_warning_continue_btn, BUTTON_RADIUS, 0);
  lv_obj_add_event_cb(ota_warning_continue_btn, ota_warning_continue_cb, LV_EVENT_CLICKED, NULL);

  lv_obj_t *continue_label = lv_label_create(ota_warning_continue_btn);
  lv_label_set_text(continue_label, "Continue");
  lv_obj_set_style_text_font(continue_label, &poppins_medium_20, 0);
  lv_obj_set_style_text_color(continue_label, COLOR_BLACK, 0); // Black text instead of white
  lv_obj_center(continue_label);
}

static void ota_warning_cancel_cb(lv_event_t * e) {
  // Hide popup
  if (ota_warning_popup && lv_obj_is_valid(ota_warning_popup)) {
    lv_obj_del(ota_warning_popup);
    ota_warning_popup = nullptr;
  }
}

static void ota_warning_continue_cb(lv_event_t * e) {
  Serial.println("Continue button pressed - starting update process");
  
  // Hide popup
  if (ota_warning_popup && lv_obj_is_valid(ota_warning_popup)) {
    lv_obj_del(ota_warning_popup);
    ota_warning_popup = nullptr;
  }
  
  // Small delay to ensure popup is fully removed
  delay(100);
  lv_timer_handler();
  
  Serial.println("Creating progress screen...");
  // Show progress screen
  createOTAProgressScreen();
  
  // Start the OTA via a short one-shot timer to let LVGL render the progress screen first
  static lv_timer_t *ota_start_timer = nullptr;
  if (ota_start_timer) {
    lv_timer_del(ota_start_timer);
  }
  ota_start_timer = lv_timer_create([](lv_timer_t *t){
    Serial.println("Starting OTA update (timer fired)...");
    ota_update_in_progress = true;
    performOTAUpdate();
    lv_timer_del(t);
  }, 200, NULL);
}
// ===== OTA PROGRESS SCREEN =====
static void createOTAProgressScreen() {
  Serial.println("Creating OTA progress screen...");
  
  // Create progress screen
  ota_progress_screen = lv_obj_create(NULL);
  if (!ota_progress_screen) {
    Serial.println("ERROR: Failed to create progress screen!");
    return;
  }
  
  lv_obj_set_style_bg_color(ota_progress_screen, COLOR_BLACK, 0);
  lv_obj_set_scrollbar_mode(ota_progress_screen, LV_SCROLLBAR_MODE_OFF);
  lv_obj_clear_flag(ota_progress_screen, LV_OBJ_FLAG_SCROLLABLE);
  lv_scr_load(ota_progress_screen);
  Serial.println("Progress screen created successfully");

  // Ensure any global WiFi symbol is removed while on progress screen
  if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
    lv_obj_del(wifi_signal);
    wifi_signal = nullptr;
  }

  // Logo (no WiFi symbol on this screen)
  ota_progress_logo = lv_img_create(ota_progress_screen);
  LV_IMG_DECLARE(LumenLogo);
  lv_img_set_src(ota_progress_logo, &LumenLogo);
  lv_img_set_zoom(ota_progress_logo, 102);  // Scale to 40% (102/256)
  lv_obj_align(ota_progress_logo, LV_ALIGN_TOP_MID, 0, 100);

  // Progress label
  ota_progress_label = lv_label_create(ota_progress_screen);
  lv_label_set_text(ota_progress_label, "Downloading... 0%");
  lv_obj_set_style_text_font(ota_progress_label, &poppins_light_20, 0);
  lv_obj_set_style_text_color(ota_progress_label, COLOR_WHITE, 0);
  lv_obj_align(ota_progress_label, LV_ALIGN_CENTER, 0, 0);

  // Modern progress bar (like brightness slider)
  ota_progress_bar_modern = lv_bar_create(ota_progress_screen);
  lv_obj_set_size(ota_progress_bar_modern, 400, 30);
  lv_obj_align(ota_progress_bar_modern, LV_ALIGN_CENTER, 0, 50);
  lv_obj_set_style_bg_color(ota_progress_bar_modern, lv_color_make(40, 40, 40), 0);
  lv_obj_set_style_bg_opa(ota_progress_bar_modern, LV_OPA_COVER, 0);
  lv_obj_set_style_bg_color(ota_progress_bar_modern, COLOR_GREEN, LV_PART_INDICATOR);
  lv_obj_set_style_radius(ota_progress_bar_modern, 15, 0);
  lv_obj_set_style_radius(ota_progress_bar_modern, 15, LV_PART_INDICATOR);
  lv_bar_set_range(ota_progress_bar_modern, 0, 100);
  lv_bar_set_value(ota_progress_bar_modern, 0, LV_ANIM_OFF);
  
  // Force display update
  lv_timer_handler();
  delay(100); // Give time for display to update
  Serial.println("OTA progress screen created");
}

static void updateOTAProgressModern(int progress) {
  if (ota_progress_bar_modern && lv_obj_is_valid(ota_progress_bar_modern)) {
    lv_bar_set_value(ota_progress_bar_modern, progress, LV_ANIM_ON);
  }
  if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
    String status = "Updating... " + String(progress) + "%";
    lv_label_set_text(ota_progress_label, status.c_str());
  }
  lv_timer_handler(); // Update display during download
}

// Smooth 10s fake progress, then perform real install streaming
static void startFakeProgressThenInstall() {
  if (!ota_progress_bar_modern || !lv_obj_is_valid(ota_progress_bar_modern)) return;
  lv_obj_set_style_anim_time(ota_progress_bar_modern, 10000, 0); // total anim duration
  lv_bar_set_value(ota_progress_bar_modern, 0, LV_ANIM_OFF);
  if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
    lv_label_set_text(ota_progress_label, "Downloading... 0%");
  }

  // Use a timer to update the text percentage while the bar animates
  static lv_timer_t *progress_timer = nullptr;
  if (progress_timer) lv_timer_del(progress_timer);
  uint32_t start_ms = lv_tick_get();
  progress_timer = lv_timer_create([](lv_timer_t *t){
    uint32_t start_ms_local = (uint32_t)(uintptr_t)t->user_data;
    uint32_t elapsed = lv_tick_elaps(start_ms_local);
    int pct = (int)((elapsed * 100) / 10000);
    if (pct > 100) pct = 100;
    if (ota_progress_bar_modern && lv_obj_is_valid(ota_progress_bar_modern)) {
      lv_bar_set_value(ota_progress_bar_modern, pct, LV_ANIM_OFF);
    }
    if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
      if (pct < 100) {
        char buf[32];
        snprintf(buf, sizeof(buf), "Downloading... %d%%", pct);
        lv_label_set_text(ota_progress_label, buf);
      } else {
        lv_label_set_text(ota_progress_label, "Installing...");
      }
    }
    if (pct >= 100) {
      lv_timer_del(t);
      // Small pause then perform install
      lv_timer_create([](lv_timer_t *tt){
        performOTAInstallStreaming();
        lv_timer_del(tt);
      }, 100, NULL);
    }
  }, 50, (void*)(uintptr_t)start_ms);
}

static void performOTAInstallStreaming() {
  if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
    lv_label_set_text(ota_progress_label, "Installing update...");
  }
  HTTPClient http;
  http.begin(UPDATE_SERVER_URL);
  http.setTimeout(60000);
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  int httpCode = http.GET();
  if (httpCode != HTTP_CODE_OK) {
    if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
      String msg = "Update failed: HTTP "; msg += httpCode; lv_label_set_text(ota_progress_label, msg.c_str());
    }
    http.end();
    return;
  }
  int contentLength = http.getSize();
  if (contentLength <= 0) {
    if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
      lv_label_set_text(ota_progress_label, "Update failed: Invalid file size");
    }
    http.end();
    return;
  }
  if (!Update.begin(contentLength)) {
    if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
      lv_label_set_text(ota_progress_label, "Update failed: Not enough space");
    }
    http.end();
    return;
  }
  WiFiClient* client = http.getStreamPtr();
  uint8_t buff[1024];
  size_t written = 0;
  while (http.connected()) {
    size_t avail = client->available();
    if (avail > 0) {
      int toRead = (avail > sizeof(buff)) ? sizeof(buff) : (int)avail;
      int c = client->readBytes(buff, toRead);
      if (c <= 0) break;
      size_t w = Update.write(buff, (size_t)c);
      written += w;
      if (contentLength > 0 && written >= (size_t)contentLength) {
        break; // Finished writing expected content
      }
    } else {
      // No data available yet; yield to UI and wait a moment
      lv_timer_handler();
      delay(10);
    }
  }
  client->stop();
  if (Update.end()) {
    const esp_partition_t* updated_partition = esp_ota_get_next_update_partition(NULL);
    if (updated_partition != NULL && esp_ota_set_boot_partition(updated_partition) == ESP_OK) {
      if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
        lv_label_set_text(ota_progress_label, "Update complete! Rebooting...");
      }
      lv_timer_handler();
      delay(1500);
      ESP.restart();
    } else {
      if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
        lv_label_set_text(ota_progress_label, "Update failed: Boot partition error");
      }
    }
  } else {
    if (ota_progress_label && lv_obj_is_valid(ota_progress_label)) {
      String msg = "Update failed: "; msg += Update.errorString();
      lv_label_set_text(ota_progress_label, msg.c_str());
    }
  }
  http.end();
}

// Highlight connected WiFi in the existing list without rescanning
static void updateConnectedWiFiHighlight() {
  if (!wifi_settings_list || !lv_obj_is_valid(wifi_settings_list)) return;
  if (WiFi.status() != WL_CONNECTED) return;
  String connected = WiFi.SSID();

  uint32_t childCount = lv_obj_get_child_cnt(wifi_settings_list);
  for (uint32_t i = 0; i < childCount; i++) {
    lv_obj_t *item_container = lv_obj_get_child(wifi_settings_list, (int32_t)i);
    if (!item_container || !lv_obj_is_valid(item_container)) continue;
    if (lv_obj_get_child_cnt(item_container) == 0) continue;

    // name_label was created first in each item_container
    lv_obj_t *name_label = lv_obj_get_child(item_container, 0);
    if (!name_label || !lv_obj_is_valid(name_label)) continue;
    const char *name_text = lv_label_get_text(name_label);
    bool is_connected = (name_text && connected == String(name_text));
    lv_obj_set_style_text_color(name_label, is_connected ? COLOR_GREEN : COLOR_WHITE, 0);
  }
}
/* ===== Setup ===== */
void setup() {
  Serial.begin(115200);
  Serial.printf("Free heap at startup: %d bytes\n", ESP.getFreeHeap());

  Serial.println("Initializing display...");
  amoled.begin();
  amoled.setRotation(0);
  // Set initial brightness to 80%
  int initial_brightness = map(80, 10, 100, 25, 255); // Map 80% to 0-255 range
  amoled.setBrightness(initial_brightness);
  beginLvglHelper(amoled);
  Serial.println("Display initialized");

  Serial.println("Showing logo...");
  showLogo();
  Serial.println("Logo shown");

  Serial.println("Initializing WiFi...");
  // Initialize WiFi but don't show selection screen
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(false, false); // Disconnect but DON'T erase any stored credentials
  
  // Set WiFi country code to enable all channels
  // Use "US" for USA, "EU" for Europe, "JP" for Japan, "CN" for China, etc.
  // Or use "01" for world mode (most permissive)
  wifi_country_t wifi_country = {
    .cc = "01",           // World mode - supports all channels
    .schan = 1,           // Start channel
    .nchan = 13,          // Number of channels (1-13 for world mode)
    .policy = WIFI_COUNTRY_POLICY_AUTO
  };
  esp_wifi_set_country(&wifi_country);
  
  wifiPrefs.begin("wifi", false);
  wifi_try_autoconnect();
  lastWiFiReconnectCheck = millis();  // Initialize timer for periodic reconnect attempts
  Serial.println("WiFi initialized");

  Serial.println("Initializing customization preferences...");
  customPrefs.begin("custom", false);
  loadCustomizationSettings();
  Serial.println("Customization preferences loaded");

  Serial.println("Initializing coin favorites...");
  coinPrefs.begin("coins", false);
  loadFavoriteCoins();
  Serial.println("Coin favorites loaded");

  Serial.println("Initializing portfolio tracker...");
  portfolioPrefs.begin("portfolio", false);
  loadPortfolioCoins();
  Serial.println("Portfolio data loaded");
  
  // Initialize coin info cache
  for (int i = 0; i < COIN_INFO_CACHE_SIZE; i++) {
    coin_info_cache[i].valid = false;
    coin_info_cache[i].timestamp = 0;
  }
  Serial.println("Coin info cache initialized");
  
  // If WiFi connected and we have favorite coins, fetch all ticker data immediately on startup
  if (WiFi.status() == WL_CONNECTED && favoriteCoinCount > 0) {
    // Set up pairs array for ticker data
    for (int i = 0; i < favoriteCoinCount && i < PAIR_COUNT; i++) {
      String symbol = favoriteCoinSymbols[i];
      String baseCoin = symbol;
      if (baseCoin.endsWith("USDT")) {
        baseCoin = baseCoin.substring(0, baseCoin.length() - 4);
      }
      
      pairs[i].symbol = symbol;
      pairs[i].display_name = baseCoin;
      pairs[i].last_price = 0.0f;
      pairs[i].last_update = 0;
      pairs[i].daily_change_percent = 0.0f;
      pairs[i].last_ticker_update = 0;
      pairs[i].candle_count = 0;
      pairs[i].is_selected = true;
      active_pair_count++;
    }
    
    Serial.println("Fetching initial price data for all favorite coins...");
    fetchAll24hTickers();
    Serial.println("Initial price data loaded");
  }

  Serial.println("Initializing OTA...");
  // Initialize OTA update system
  last_ota_check = 0;
  ota_update_available = false;
  ota_update_in_progress = false;
  
  // Debug: Show current partition info
  const esp_partition_t* running = esp_ota_get_running_partition();
  Serial.printf("Running partition: %s, type: %d, subtype: %d, address: 0x%08x\n", 
                running->label, running->type, running->subtype, running->address);
  
  const esp_partition_t* next_update = esp_ota_get_next_update_partition(NULL);
  if (next_update != NULL) {
    Serial.printf("Next update partition: %s, type: %d, subtype: %d, address: 0x%08x\n", 
                  next_update->label, next_update->type, next_update->subtype, next_update->address);
  }
  
  Serial.println("OTA initialized");

  Serial.println("Creating homepage...");
  // Add a small delay before creating homepage
  delay(100);
  // Show homepage directly
  createHomepage();
  Serial.println("Homepage created");

  Serial.println("Initializing control panel...");
  initGlobalControlPanel();
  Serial.println("Control panel initialized");
  
  Serial.println("Creating WiFi UI elements...");
  // Initialize the original WiFi UI elements (needed for connection handling)
  wifi_label = lv_label_create(lv_scr_act());
  if (wifi_label) lv_obj_add_flag(wifi_label, LV_OBJ_FLAG_HIDDEN);
  Serial.println("WiFi label created");
  
  wifi_list = lv_list_create(lv_scr_act());
  if (wifi_list) lv_obj_add_flag(wifi_list, LV_OBJ_FLAG_HIDDEN);
  Serial.println("WiFi list created");
  
  refresh_btn = lv_btn_create(lv_scr_act());
  if (refresh_btn) lv_obj_add_flag(refresh_btn, LV_OBJ_FLAG_HIDDEN);
  Serial.println("Refresh button created");
  
  // Initialize rotary encoder pins
  Serial.println("Initializing rotary encoder...");
  pinMode(ENCODER_PIN_A, INPUT_PULLUP);
  pinMode(ENCODER_PIN_B, INPUT_PULLUP);
  pinMode(ENCODER_PIN_SW, INPUT_PULLUP);
  encoder_last_A = digitalRead(ENCODER_PIN_A);
  encoder_last_B = digitalRead(ENCODER_PIN_B);
  encoder_state = (encoder_last_A << 1) | encoder_last_B;  // Initial state
  encoder_last_sw = digitalRead(ENCODER_PIN_SW);
  Serial.println("Rotary encoder initialized");
  
  // USB cable detection disabled - only monitoring battery level now
  Serial.println("Charging detection disabled - showing battery level only");
  
  // OLD WiFi system - DISABLED to prevent white WiFi page after OTA updates
  // popup = lv_obj_create(lv_scr_act());
  // if (popup) lv_obj_add_flag(popup, LV_OBJ_FLAG_HIDDEN);
  // Serial.println("Popup created");
  
  // popup_label = lv_label_create(popup);
  // if (popup_label) Serial.println("Popup label created");
  
  // password_ta = lv_textarea_create(popup);
  // if (password_ta) Serial.println("Password textarea created");
  
  // kb = lv_keyboard_create(lv_scr_act());
  // if (kb) lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN);
  // Serial.println("Keyboard created");
  
  // cancel_btn = lv_btn_create(popup);
  // if (cancel_btn) Serial.println("Cancel button created");
  
  // connect_btn = lv_btn_create(popup);
  // if (connect_btn) Serial.println("Connect button created");
  
  // connecting_label = lv_label_create(popup);
  // if (connecting_label) {
  //   lv_obj_add_flag(connecting_label, LV_OBJ_FLAG_HIDDEN);
  //   Serial.println("Connecting label created");
  // }

  // Load universal alerts
  Serial.println("Loading universal alerts...");
  loadAlerts();
  // Show bell icon if there are active alerts
  bool has_alerts = false;
  for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
    if (coin_alerts[i].active) {
      has_alerts = true;
      break;
    }
  }
  if (has_alerts) {
    showAlertBellIcon();
  }
  Serial.println("Alerts initialized");

  Serial.printf("Free heap at end of setup: %d bytes\n", ESP.getFreeHeap());
  Serial.println("Setup complete!");
}
/* ===== Loop ===== */
void loop() {
  lv_timer_handler();
  delay(1); // Reduced delay to allow faster timers

  // Ensure Wi-Fi icon appears automatically once connected
  if (WiFi.status() == WL_CONNECTED) {
    if (!wifi_signal || !lv_obj_is_valid(wifi_signal)) {
      lv_obj_t *cur = lv_scr_act();
      // Hide WiFi on crypto_display_screen during initial loading (no candles yet)
      bool is_loading_crypto = (cur == crypto_display_screen && pairs[current_pair].candle_count == 0);
      if (cur != ota_progress_screen && !is_loading_crypto) {
        createWiFiSignal(cur);
      }
    }
  }

  bool has_portfolio_coins = (portfolioCoinCount > 0);
  bool needs_portfolio_bootstrap = false;
  if (has_portfolio_coins) {
    for (int i = 0; i < portfolioCoinCount; i++) {
      if (portfolioCoins[i].last_price_update == 0) {
        needs_portfolio_bootstrap = true;
        break;
      }
    }
  }
  if (has_portfolio_coins &&
      (needs_portfolio_bootstrap || millis() - last_portfolio_price_check > PORTFOLIO_PRICE_REFRESH_MS)) {
    ensurePortfolioPrices(false);
  }

  if (connecting && !wifi_screen_transitioning) {
    if (WiFi.status() == WL_CONNECTED) {
      connecting = false;
      wifi_screen_transitioning = true;

      // Stop timer immediately
      if (wifi_connecting_timer) {
        lv_timer_del(wifi_connecting_timer);
        wifi_connecting_timer = nullptr;
      }
      
      // Reset all WiFi connecting pointers
      wifi_connecting_label = nullptr;
      
      // Original approach: just hide popup elements and return to WiFi list
      if (wifi_settings_popup && lv_obj_is_valid(wifi_settings_popup)) {
        lv_obj_add_flag(wifi_settings_popup, LV_OBJ_FLAG_HIDDEN);
      }
      if (wifi_settings_kb && lv_obj_is_valid(wifi_settings_kb)) {
        lv_obj_add_flag(wifi_settings_kb, LV_OBJ_FLAG_HIDDEN);
      }
      
      // Hide the connecting screen
      hideWiFiConnectingScreen();
      
      // Show all background elements again
      if (wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
        lv_obj_clear_flag(wifi_settings_list, LV_OBJ_FLAG_HIDDEN);
        // Recolor connected SSID to green without rescanning
        updateConnectedWiFiHighlight();
      }
      if (wifi_settings_logo && lv_obj_is_valid(wifi_settings_logo)) {
        lv_obj_clear_flag(wifi_settings_logo, LV_OBJ_FLAG_HIDDEN);
      }
      if (wifi_settings_back_btn && lv_obj_is_valid(wifi_settings_back_btn)) {
        lv_obj_clear_flag(wifi_settings_back_btn, LV_OBJ_FLAG_HIDDEN);
      }
      if (wifi_settings_refresh_btn && lv_obj_is_valid(wifi_settings_refresh_btn)) {
        lv_obj_clear_flag(wifi_settings_refresh_btn, LV_OBJ_FLAG_HIDDEN);
      }
      
      // Reset transition flag
      wifi_screen_transitioning = false;

      // Save connected credentials
      String curSsid = WiFi.SSID();
      if (curSsid.length() > 0) {
        wifi_save_credentials(curSsid, pendingPassword);
      }
    }
    else if (millis() - connectStart > 20000) {
      connecting = false;
      lv_obj_add_flag(connecting_label, LV_OBJ_FLAG_HIDDEN);
      if (wifi_settings_connecting_label) {
        lv_obj_add_flag(wifi_settings_connecting_label, LV_OBJ_FLAG_HIDDEN);
      }
      lv_label_set_text(popup_label, "Connection failed!");
      if (wifi_settings_popup_label) {
        lv_label_set_text(wifi_settings_popup_label, "Connection failed!");
      }
    }
  }

  // WS loop - run current pair and all pairs with active alerts
  if (WiFi.status() == WL_CONNECTED) {
    // Always run current pair's websocket
    pairs[current_pair].ws_client.loop();
    
    // Also run websockets for all coins with active alerts (background price tracking)
    for (int i = 0; i < MAX_TOTAL_ALERTS; i++) {
      if (!coin_alerts[i].active) continue;
      
      // Find the pair index for this alert's coin
      for (int p = 0; p < active_pair_count; p++) {
        if (p == current_pair) continue; // Already running above
        if (pairs[p].symbol == coin_alerts[i].coin_symbol) {
          pairs[p].ws_client.loop();
          break;
        }
      }
    }
  }

  // Price tick (3s color flash)
  if (pairs[current_pair].last_price > 0.0f && millis() - lastPriceUpdate > 3000) {
    static float prevPrice = 0.0f;
    static char buf[20];
    formatPriceWithCommas(pairs[current_pair].last_price, buf, sizeof(buf), current_pair);
    if (price_label && lv_obj_is_valid(price_label)) {
      lv_label_set_text(price_label, buf);
      if (prevPrice > 0.0f) {
        lv_obj_set_style_text_color(price_label,
          (pairs[current_pair].last_price > prevPrice) ? COLOR_GREEN :
          (pairs[current_pair].last_price < prevPrice) ? COLOR_RED : COLOR_WHITE, 0);
      }
      prevPrice = pairs[current_pair].last_price;
    }
    lastPriceUpdate = millis();
  }

  // Clock each second
  if (WiFi.status() == WL_CONNECTED && millis() - lastClockUpdate > 1000) {
    updateClock();
    lastClockUpdate = millis();
  }
  // Rotary encoder reading with improved quadrature decoding
  if (millis() - last_encoder_check >= ENCODER_DEBOUNCE_MS) {
    last_encoder_check = millis();
    
    int encoder_A = digitalRead(ENCODER_PIN_A);
    int encoder_B = digitalRead(ENCODER_PIN_B);
    int encoder_sw = digitalRead(ENCODER_PIN_SW);
    
    // Improved quadrature decoding using state machine
    // Encoder states: 00, 01, 10, 11 (binary representation)
    int new_state = (encoder_A << 1) | encoder_B;
    
    if (new_state != encoder_state) {
      // State has changed - decode direction using transition table
      // Valid transitions for clockwise: 00->01->11->10->00
      // Valid transitions for counterclockwise: 00->10->11->01->00
      static const int8_t state_transitions[4][4] = {
        // From state 00 (0), 01 (1), 10 (2), 11 (3)
        {0,  1, -1,  0},  // To state 00: invalid, CW, invalid, CCW
        {-1,  0,  0,  1},  // To state 01: invalid, no change, CCW, CW
        {1,  0,  0, -1},  // To state 10: CCW, no change, no change, invalid
        {0, -1,  1,  0}   // To state 11: CW, invalid, CW, no change
      };
      
      int direction = state_transitions[encoder_state][new_state];
      
      if (direction != 0) {
        bool is_clockwise = (direction > 0);
        
        // Accumulate pulses and check for direction consistency
        // Reset if direction changes (prevents false detections during fast rotation)
        if ((encoder_last_direction > 0 && !is_clockwise) || 
            (encoder_last_direction < 0 && is_clockwise)) {
          // Direction changed, reset pulse count to prevent false detections
          encoder_pulse_count = 0;
        }
        encoder_last_direction = is_clockwise ? 1 : -1;
        encoder_pulse_count++;
        
        // Only act on complete detents (full pulse cycle)
        bool complete_detent = (encoder_pulse_count >= ENCODER_PULSES_PER_DETENT);
        
        // Handle brightness, alert, and TF only on complete detents
        if (complete_detent) {
          encoder_pulse_count = 0;  // Reset for next detent
          
          // Handle alert price digit editing (only if not in alert mode)
          // Check alert first, then brightness, then TF
          if (alert_encoder_mode && alert_popup && lv_obj_is_valid(alert_popup)) {
            hideRotaryMenu();
            // Clockwise (PIN_B/IO48) = increase digit, Counterclockwise (PIN_A/IO38) = decrease
            changeAlertDigit(is_clockwise);
          }
          // Handle brightness control (REVERSED direction) - check control panel first, then brightness screen
          else if (control_panel_visible && control_brightness_slider && lv_obj_is_valid(control_brightness_slider)) {
            hideRotaryMenu();
            // Control panel is open - control brightness there
            int32_t new_val = is_clockwise ? 
              current_brightness_percent - 2 :  // Reversed: CW decreases
              current_brightness_percent + 2;   // CCW increases
            updateBrightnessFromEncoder(new_val);
            Serial.printf("Encoder: %s - Brightness (Control Panel): %d%%\n", 
                         is_clockwise ? "Clockwise" : "Counterclockwise", 
                         current_brightness_percent);
          }
          else if (lv_scr_act() == brightness_screen && brightness_slider && lv_obj_is_valid(brightness_slider)) {
            hideRotaryMenu();
            if (encoderFocusIsActive() && !encoderFocusHasHighlight()) {
              if (encoderFocusEnsureHighlight()) {
                return;
              }
            }
            // Brightness screen
            int32_t new_val = is_clockwise ? 
              current_brightness_percent - 2 :  // Reversed: CW decreases
              current_brightness_percent + 2;   // CCW increases
            updateBrightnessFromEncoder(new_val);
            Serial.printf("Encoder: %s - Brightness: %d%%\n", 
                         is_clockwise ? "Clockwise" : "Counterclockwise", 
                         current_brightness_percent);
          }
          // Check Edit page FIRST before anything else to prevent rotary menu
          else if (customization_bg && lv_obj_is_valid(customization_bg) && 
                   !lv_obj_has_flag(customization_bg, LV_OBJ_FLAG_HIDDEN)) {
            // On Edit page - use encoder focus for navigation, don't open rotary menu
            hideRotaryMenu();
            Serial.printf("[Edit] Encoder on Edit page, encoderFocusIsActive=%d\n", encoderFocusIsActive());
            if (encoderFocusIsActive()) {
              encoderFocusMove(is_clockwise ? -1 : 1);
            } else {
              Serial.println("[Edit] WARNING: Encoder focus not active on Edit page!");
            }
          }
          // Check if All Alerts popup is open and has focus
          else if (alerts_popup_bg && lv_obj_is_valid(alerts_popup_bg) && 
                   !lv_obj_has_flag(alerts_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
            hideRotaryMenu();
            Serial.printf("[Alerts] Encoder on All Alerts page, encoderFocusIsActive=%d\n", encoderFocusIsActive());
            if (encoderFocusIsActive()) {
              encoderFocusMove(is_clockwise ? -1 : 1);
            } else {
              Serial.println("[Alerts] WARNING: Encoder focus not active on All Alerts page!");
            }
          }
          // Check if Coins popup is open and has focus
          else if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg) && 
                   !lv_obj_has_flag(coins_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
            hideRotaryMenu();
            Serial.printf("[Coins] Encoder on Coins popup, encoderFocusIsActive=%d\n", encoderFocusIsActive());
            if (encoderFocusIsActive()) {
              encoderFocusMove(is_clockwise ? -1 : 1);
            } else {
              Serial.println("[Coins] WARNING: Encoder focus not active on Coins popup!");
            }
          }
          // Rotary quick menu / TF control on live price screen (encoder-driven)
          // ONLY allow on crypto_display_screen with NO popups/overlays open
          else if (!control_panel_visible && lv_scr_act() == crypto_display_screen) {
            // Check if any popups or overlays are open
            bool has_popup_open = false;
            
            // Check all possible popups
            if (alert_popup && lv_obj_is_valid(alert_popup) && !lv_obj_has_flag(alert_popup, LV_OBJ_FLAG_HIDDEN)) {
              has_popup_open = true;
            }
            if (alerts_popup_bg && lv_obj_is_valid(alerts_popup_bg) && !lv_obj_has_flag(alerts_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
              has_popup_open = true;
            }
            if (coin_info_popup_bg && lv_obj_is_valid(coin_info_popup_bg) && !lv_obj_has_flag(coin_info_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
              has_popup_open = true;
            }
            if (customization_bg && lv_obj_is_valid(customization_bg) && !lv_obj_has_flag(customization_bg, LV_OBJ_FLAG_HIDDEN)) {
              has_popup_open = true;
            }
            if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg) && !lv_obj_has_flag(coins_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
              has_popup_open = true;
            }
            
            bool tf_exists = (tf_menu && lv_obj_is_valid(tf_menu));
            bool tf_visible = tf_exists && !lv_obj_has_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);

            if (tf_visible) {
              if (!tf_encoder_mode) {
                tf_encoder_mode = true;
                tf_preview_index = tf_current_index;
                Serial.println("[TF Menu] Encoder control enabled (rotary)");
              }

              if (tf_encoder_mode) {
                if (is_clockwise) {
                  tf_preview_index = (tf_preview_index - 1 + tfCount) % tfCount;
                } else {
                  tf_preview_index = (tf_preview_index + 1) % tfCount;
                }
                updateTFHighlights(tf_preview_index, true);
                reset_tf_timer();
                Serial.printf("[TF Menu] Preview -> %s (index %d)\n", tfOptions[tf_preview_index], tf_preview_index);
              }
            } else if (!has_popup_open) {
              // Only show rotary menu if no popups are open
              tf_encoder_mode = false;
              rotaryMenuStep(is_clockwise);
            } else {
              // Popup is open - don't show rotary menu
              hideRotaryMenu();
            }
          }
          else if (encoderFocusIsActive()) {
            hideRotaryMenu();
            Serial.printf("[Encoder] encoderFocusIsActive=true, calling encoderFocusMove\n");
            encoderFocusMove(is_clockwise ? -1 : 1);
          }
          // Debug output for other screens
          else {
            hideRotaryMenu();
            Serial.printf("Encoder: %s (detent complete) - encoderFocusIsActive=%d, screen=%p\n", 
                         is_clockwise ? "Clockwise" : "Counterclockwise",
                         encoderFocusIsActive(), encoder_focus_ctx.screen);
          }
        }
      } else {
        // Invalid transition detected - reset pulse count to prevent false detections
        // This happens when encoder is moved too fast or there's noise
        encoder_pulse_count = 0;
        encoder_last_direction = 0;
      }
      
      encoder_state = new_state;
      encoder_last_A = encoder_A;
      encoder_last_B = encoder_B;
    }
    
    // Detect button press (active low when pressed)
    if (encoder_sw == LOW && encoder_last_sw == HIGH && (millis() - last_sw_press > ENCODER_SW_DEBOUNCE_MS)) {
      last_sw_press = millis();
      
      // CRITICAL: Block button actions during wake cooldown (first 2 seconds after wake)
      // This prevents the wake-up press or release from triggering actions
      // Note: lastWakeTime == 0 means never woken (fresh boot), so no cooldown
      if (lastWakeTime > 0 && millis() - lastWakeTime < 2000) {
        Serial.printf("[Sleep] Button press IGNORED - in wake cooldown (%lu ms remaining)\n", 
                     2000 - (millis() - lastWakeTime));
        // Don't process any button actions during cooldown
      }
      else {
        // Normal button processing (not in cooldown)
      encoderPressStart = last_sw_press; // start hold timer
        Serial.printf("[Sleep] Button pressed - hold timer started (will sleep after 2s)\n");
        
        // Dismiss alert flash if active
        if (alert_triggered) {
          dismissAlertFlash(nullptr);
        }
      
      // Handle TF selection confirmation
      bool on_crypto_screen = (lv_scr_act() == crypto_display_screen);
      bool menu_exists = (tf_menu && lv_obj_is_valid(tf_menu));
      bool menu_visible = tf_menu_visible && menu_exists && !lv_obj_has_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
      
      Serial.printf("Encoder click - Alert mode: %d, TF mode: %d, Control panel: %d\n", 
                   alert_encoder_mode, tf_encoder_mode, control_panel_visible);
      
      // Handle alert digit advancement (click moves to next digit)
      if (alert_encoder_mode && alert_popup && lv_obj_is_valid(alert_popup)) {
        nextAlertDigit();
      }
      // TF selection: must be on crypto screen, in encoder mode, control panel closed, and menu exists
      else if (rotary_menu_active && on_crypto_screen && !control_panel_visible) {
        activateRotaryMenuSelection();
      }
      else if (on_crypto_screen && tf_encoder_mode && !control_panel_visible && menu_exists) {
        // Confirm the preview selection
        tf_current_index = tf_preview_index;
        currentTFStr = tfOptions[tf_current_index];
        tf_encoder_mode = false;
        
        // Save the timeframe setting
        customPrefs.putInt("tf_index", tf_current_index);
        
        // Update main TF button label
        if (tf_label && lv_obj_is_valid(tf_label)) {
          lv_label_set_text(tf_label, currentTFStr);
        }
        
        // Update highlights to full brightness
        updateTFHighlights(tf_current_index, false);
        
        Serial.printf("TF confirmed: %s (index %d)\n", currentTFStr, tf_current_index);
        
        // Hide menu and apply new timeframe
        lv_timer_t *hide_timer = lv_timer_create([](lv_timer_t *t){
          if (tf_menu && lv_obj_is_valid(tf_menu)) {
            lv_obj_add_flag(tf_menu, LV_OBJ_FLAG_HIDDEN);
          }
          tf_menu_visible = false;
          if (tf_timer) {
            lv_timer_del(tf_timer);
            tf_timer = nullptr;
          }
          
          // Start loading new data
          fetchHistory(currentTFStr);
          startKlineWS(currentTFStr);
        }, 250, NULL);
        lv_timer_set_repeat_count(hide_timer, 1);
      } else if (encoderFocusIsActive()) {
        encoderFocusActivate();
      }
      // Close coin info popup on encoder button click
      else if (coin_info_popup_bg && lv_obj_is_valid(coin_info_popup_bg) && 
               !lv_obj_has_flag(coin_info_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
        // Coin info popup is open - close it
        if (coin_info_popup_bg && lv_obj_is_valid(coin_info_popup_bg)) {
          lv_obj_del(coin_info_popup_bg);
          coin_info_popup_bg = nullptr;
          coin_info_popup = nullptr;
          coin_info_label = nullptr;
        }
      }
      // Close coins navigation popup on encoder button click
      else if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg) && 
               !lv_obj_has_flag(coins_popup_bg, LV_OBJ_FLAG_HIDDEN)) {
        // Coins popup is open - close it
        if (coins_popup_bg && lv_obj_is_valid(coins_popup_bg)) {
          // CRITICAL: Reset sleep timer to prevent accidental sleep mode
          encoderPressStart = 0;
          Serial.println("[Coins Popup] Encoder close - reset sleep timer");
          
          // Reset encoder focus
          encoderFocusReset();
          
          lv_obj_del(coins_popup_bg);
          coins_popup_bg = nullptr;
          coins_popup = nullptr;
          coins_popup_list = nullptr;
        }
      } else {
        Serial.println("Encoder: Button clicked (not in TF selection mode)");
      }
    }
    }
    // Detect long press (>= 2s) to enter sleep mode
    // Only check if: button was pressed, held for 2s, not already sleeping, and not in wake cooldown
    // Note: lastWakeTime == 0 means never woken (fresh boot), so no cooldown active
    if (encoderPressStart > 0 && (millis() - encoderPressStart >= 2000) && !sleepRequested && 
        (lastWakeTime == 0 || millis() - lastWakeTime >= 2000)) {
      sleepRequested = true;
      unsigned long holdTime = millis() - encoderPressStart;
      Serial.printf("[Sleep] 2-second hold detected - preparing for sleep (hold: %lu ms)\n", holdTime);
      
      // Dim display with smooth fade to black
      for (int brightness = current_brightness_percent; brightness >= 0; brightness -= 10) {
        int mapped = map(brightness, 10, 100, 25, 255);
        amoled.setBrightness(mapped);
        delay(30); // 30ms per step for smooth fade
      }
      amoled.setBrightness(0);
      
      // CRITICAL: Wait for user to RELEASE the button before entering sleep
      // This prevents immediate wake-up since button is still pressed
      Serial.println("[Sleep] Waiting for button release before sleeping...");
      unsigned long wait_start = millis();
      while (digitalRead(ENCODER_PIN_SW) == LOW) {
        delay(10);
        // Safety timeout after 10 seconds in case button is stuck
        if (millis() - wait_start > 10000) {
          Serial.println("[Sleep] WARNING: Button release timeout - sleeping anyway");
          break;
        }
      }
      Serial.printf("[Sleep] Button released after %lu ms - entering sleep now\n", millis() - wait_start);
      
      // Configure wakeup on encoder button PRESS (LOW level) - not release
      gpio_wakeup_enable((gpio_num_t)ENCODER_PIN_SW, GPIO_INTR_LOW_LEVEL);
      esp_sleep_enable_gpio_wakeup();
      
      delay(50); // Brief stabilization delay
      
      esp_light_sleep_start();
      
      // === WOKEN UP HERE ===
      Serial.println("[Sleep] Woke from light sleep!");
      
      // Set wake cooldown timer (2 seconds minimum to avoid release click waking)
      lastWakeTime = millis();
      Serial.printf("[Sleep] Wake cooldown active for 2 seconds (until %lu ms)\n", lastWakeTime + 2000);
      
      // Restore brightness with smooth fade from black
      for (int brightness = 0; brightness <= current_brightness_percent; brightness += 10) {
        int mapped = map(brightness, 10, 100, 25, 255);
        amoled.setBrightness(mapped);
        delay(30); // 30ms per step for smooth fade
      }
      int restored = map(current_brightness_percent, 10, 100, 25, 255);
      amoled.setBrightness(restored);
      
      // Reattach status icons to current screen
      ensureStatusIcons(lv_scr_act());
      
      // Reset hold state
      encoderPressStart = 0;
      sleepRequested = false;
      
      Serial.println("[Sleep] Wake complete - device ready");
    }
    
    // Button released: reset hold timer only if sleep wasn't triggered
    if (encoder_sw == HIGH && encoder_last_sw == LOW) {
      if (encoderPressStart > 0 && !sleepRequested) {
        encoderPressStart = 0;
        Serial.printf("[Sleep] Button released early (hold < 2s) - sleep cancelled\n");
      }
    }
    encoder_last_sw = encoder_sw;
  }

  // Wi-Fi bars every 5s (only if WiFi signal exists)
  if (WiFi.status() == WL_CONNECTED && millis() - lastWiFiUpdate > 5000) {
    if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
      updateWiFiSignal();
    }
    lastWiFiUpdate = millis();
  }
  
  // Update 24h ticker data every 60 seconds for ALL favorite coins at once (batch request)
  if (WiFi.status() == WL_CONNECTED && millis() - lastTickerUpdate >= 60000) {
    if (active_pair_count > 0) {
      // Fetch all coins in one batch API call - fast and doesn't freeze!
      fetchAll24hTickers();
      
      // Refresh Favorites page if it's currently visible
      if (lv_scr_act() == new_favorites_screen && new_favorites_list && lv_obj_is_valid(new_favorites_list)) {
        refreshNewFavoritesList();
      }
    }
    
    lastTickerUpdate = millis();
  }
  
  // WiFi auto-reconnect: Check every 20 seconds if disconnected OR if connection is stale
  if (millis() - lastWiFiReconnectCheck >= 20000) {
    bool needsReconnect = false;
    String reconnectReason = "";
    
    if (WiFi.status() != WL_CONNECTED) {
      needsReconnect = true;
      reconnectReason = "Disconnected";
    } else {
      // Check for "phantom" connection (shows connected but not actually working)
      // This happens when you move between locations (home to office, etc.)
      int32_t rssi = WiFi.RSSI();
      
      // RSSI of 0 or greater than -10 indicates an invalid reading (connection is dead)
      // RSSI less than -90 indicates extremely weak signal (likely out of range)
      if (rssi >= 0 || rssi > -10 || rssi < -90) {
        needsReconnect = true;
        reconnectReason = "Phantom connection detected (RSSI: " + String(rssi) + ")";
      }
    }
    
    if (needsReconnect) {
      lastWiFiReconnectCheck = millis();
      Serial.printf("[WiFi] %s - attempting auto-reconnect...\n", reconnectReason.c_str());
      
      // Fully disconnect to clear the phantom connection
      WiFi.disconnect(true, false); // Disconnect but preserve saved credentials
      delay(200); // Give WiFi time to fully disconnect
      
      // Ensure WiFi is in station mode before attempting reconnect
      WiFi.mode(WIFI_STA);
      delay(100);  // Give WiFi time to switch modes
      
      wifi_try_autoconnect();
      
      // Update WiFi icon after reconnect attempt
      if (wifi_signal && lv_obj_is_valid(wifi_signal)) {
        updateWiFiSignal();
      }
    } else {
      // Connection is healthy, just update the timer
      lastWiFiReconnectCheck = millis();
    }
  }

  // Check for alert triggers every loop (price updates trigger this)
  checkAlertTriggers();

  // Battery DISABLED
  // if (millis() - lastBatteryUpdate > 60000) {
  //   updateBatteryLabel();
  //   lastBatteryUpdate = millis();
  // }

  // Ensure status icons exist and are attached to the current screen (once per second)
  if (millis() - lastStatusIconsUpdate > 1000) {
    lv_obj_t *cur = lv_scr_act();
    ensureStatusIcons(cur);
    lastStatusIconsUpdate = millis();
  }

  // Check for OTA updates every 24 hours
  if (WiFi.status() == WL_CONNECTED && 
      !ota_update_in_progress && 
      millis() - last_ota_check > OTA_UPDATE_INTERVAL) {
    checkForUpdates();
  }
  // Check for WiFi scan completion
  if (wifi_scan_in_progress) {
    int scanResult = WiFi.scanComplete();
    
    // Check for timeout
    if (millis() - wifi_scan_start_time > WIFI_SCAN_TIMEOUT) {
      wifi_scan_in_progress = false;
      Serial.println("WiFi scan timeout - resetting");
      
      // Show error message
      lv_obj_t *current_screen = lv_scr_act();
      if (current_screen == wifi_settings_screen && wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
        lv_obj_clean(wifi_settings_list);
        lv_obj_t *label = lv_label_create(wifi_settings_list);
        lv_label_set_text(label, "Scan failed - try again");
        lv_obj_set_style_text_font(label, &poppins_light_20, 0);
        lv_obj_set_style_text_color(label, COLOR_RED, 0);
        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
      }
    }
    // Check for scan completion or failure
    else if (scanResult >= 0) {
      // Successful scan
      wifi_scan_in_progress = false;
      int networksFound = scanResult;
      
      // Only update if we're currently on the WiFi settings screen
      lv_obj_t *current_screen = lv_scr_act();
      if (current_screen == wifi_settings_screen && wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
        lv_obj_clean(wifi_settings_list);
      
      if (networksFound <= 0) {
        // No networks found - show centered message
        lv_obj_t *label = lv_label_create(wifi_settings_list);
        lv_label_set_text(label, "No networks found");
        lv_obj_set_style_text_font(label, &poppins_light_20, 0);
        lv_obj_set_style_text_color(label, COLOR_WHITE, 0);
        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
      } else {
        // Create array of WiFi networks with signal strength for sorting
        int limit = (networksFound > 6) ? 6 : networksFound;
        WiFiNetwork networks[6];
        
        // Collect network data
        for (int i = 0; i < limit; i++) {
          networks[i].ssid = WiFi.SSID(i);
          networks[i].rssi = WiFi.RSSI(i);
          networks[i].index = i;
        }
        
        // Get connected SSID first
        String connectedSSID = "";
        if (WiFi.status() == WL_CONNECTED) {
          connectedSSID = WiFi.SSID();
          Serial.printf("Connected to WiFi: '%s' (status: %d)\n", connectedSSID.c_str(), WiFi.status());
        } else {
          Serial.println("Not connected to any WiFi");
        }
        
        // Sort networks: Connected FIRST, then Saved, then by signal strength
        for (int i = 0; i < limit - 1; i++) {
          for (int j = 0; j < limit - i - 1; j++) {
            bool j_is_connected = (networks[j].ssid == connectedSSID && connectedSSID.length() > 0);
            bool j1_is_connected = (networks[j + 1].ssid == connectedSSID && connectedSSID.length() > 0);
            bool j_is_saved = wifi_is_network_saved(networks[j].ssid);
            bool j1_is_saved = wifi_is_network_saved(networks[j + 1].ssid);
            
            bool should_swap = false;
            
            // Priority 1: Connected network always comes first
            if (!j_is_connected && j1_is_connected) {
              should_swap = true;
            }
            // Priority 2: If neither connected, saved networks come before unsaved
            else if (!j_is_connected && !j1_is_connected) {
              if (!j_is_saved && j1_is_saved) {
                should_swap = true;
              }
              // Priority 3: Within same category, sort by signal strength
              else if (j_is_saved == j1_is_saved && networks[j].rssi < networks[j + 1].rssi) {
                should_swap = true;
              }
            }
            
            if (should_swap) {
              WiFiNetwork temp = networks[j];
              networks[j] = networks[j + 1];
              networks[j + 1] = temp;
            }
          }
        }
        
               // Create iOS-style network list items
               const int item_height = 40;
               const int item_spacing = 8;
               
               for (int i = 0; i < limit; i++) {
                 // Create container for each network item
                lv_obj_t *item_container = lv_obj_create(wifi_settings_list);
                lv_obj_set_size(item_container, 460, item_height); // 500 - 40 padding
                lv_obj_align(item_container, LV_ALIGN_TOP_MID, 0, i * (item_height + item_spacing) - 5); // Moved up 15 pixels total
         lv_obj_set_style_bg_opa(item_container, LV_OPA_TRANSP, 0); // Transparent background
         lv_obj_set_style_border_width(item_container, 0, 0);
         lv_obj_set_style_radius(item_container, 0, 0);
         lv_obj_set_style_pad_all(item_container, 0, 0);
         lv_obj_add_flag(item_container, LV_OBJ_FLAG_CLICKABLE);
         lv_obj_add_event_cb(item_container, wifi_settings_network_btn_cb, LV_EVENT_CLICKED, (void*)(intptr_t)networks[i].index);
          
          // Check if this is the currently connected WiFi
          bool is_connected = (WiFi.status() == WL_CONNECTED && networks[i].ssid == connectedSSID && connectedSSID.length() > 0);
          
          // Check if this network is saved
          bool is_saved = wifi_is_network_saved(networks[i].ssid);
          
          Serial.printf("WiFi List: %s - Connected: %s, Saved: %s\n", 
                        networks[i].ssid.c_str(), 
                        is_connected ? "YES" : "NO", 
                        is_saved ? "YES" : "NO");
          
                 // Network name (left-aligned) - green if connected or saved, white otherwise
                 lv_obj_t *name_label = lv_label_create(item_container);
                 
                 lv_label_set_text(name_label, networks[i].ssid.c_str());
                 lv_obj_set_style_text_font(name_label, &poppins_light_20, 0);
                 
                 // Set color: GREEN for connected OR saved, WHITE for others
                 if (is_connected || is_saved) {
                   lv_obj_set_style_text_color(name_label, COLOR_GREEN, 0);
                   Serial.printf("  -> Setting %s to GREEN (connected/saved)\n", networks[i].ssid.c_str());
                 } else {
                   lv_obj_set_style_text_color(name_label, COLOR_WHITE, 0);
                   Serial.printf("  -> Setting %s to WHITE (unsaved)\n", networks[i].ssid.c_str());
                 }
                 
                 lv_obj_align(name_label, LV_ALIGN_LEFT_MID, 0, 0);
          
          // Lock icon (if password protected) - positioned before signal strength
          bool is_secured = (WiFi.encryptionType(networks[i].index) != WIFI_AUTH_OPEN);
          if (is_secured) {
            lv_obj_t *lock_icon = lv_img_create(item_container);
            LV_IMG_DECLARE(Lock);
            lv_img_set_src(lock_icon, &Lock);
            lv_img_set_zoom(lock_icon, 179); // Scale to 70% (30% smaller than original)
            lv_obj_align(lock_icon, LV_ALIGN_RIGHT_MID, -40, 0); // Position to left of signal strength
          }
          
          // Signal strength (right-aligned) - iOS-style WiFi symbol
          lv_obj_t *wifi_icon = createWiFiSignalIcon(item_container, networks[i].rssi);
          lv_obj_align(wifi_icon, LV_ALIGN_RIGHT_MID, 0, 0);
          
                 // No checkmark box - just green text for connected networks
        }
        setupWiFiSettingsFocus();
      }
      }
    }
    // Handle scan failure - but only show error after a short delay to prevent immediate failures
    else if (scanResult == WIFI_SCAN_FAILED) {
      // Only show error if scan has been running for at least 2 seconds
      if (millis() - wifi_scan_start_time > 2000) {
        wifi_scan_in_progress = false;
        Serial.println("WiFi scan failed");
        
        // Show error message
        lv_obj_t *current_screen = lv_scr_act();
        if (current_screen == wifi_settings_screen && wifi_settings_list && lv_obj_is_valid(wifi_settings_list)) {
          lv_obj_clean(wifi_settings_list);
          lv_obj_t *label = lv_label_create(wifi_settings_list);
          lv_label_set_text(label, "Scan failed - try again");
          lv_obj_set_style_text_font(label, &poppins_light_20, 0);
          lv_obj_set_style_text_color(label, COLOR_RED, 0);
          lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
        }
      }
    }
    // If scanResult == WIFI_SCAN_RUNNING, continue waiting
  }
}
